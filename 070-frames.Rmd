# Data Frames {#frames}

```{block2, half-good-programmer, type='leadquote'}
*Can one be a good data analyst without being a half-good programmer?  The short answer to that is, 'No.' The long answer to that is, â€˜No.'*

---Frank Harrell
```


Up to this point we have given a great deal of attention to vectors, and we have always treated them as one-dimensional objects:  a vector has a length, but not a "width."

It is time to begin working in two dimensions.  In this Chapter we will study *matrices*, which are simply vectors that have both length and width.  Matrices are immensely useful for scientific computation in R, but for the most part we will treat them as a warm-up for *data frames*---the two-dimensional R-objects that are especially designed for the storage of data collected in the course of practical data analysis. Once you understand how to construct and manipulate data frames, you will be ready to learn how to visualize and analyze data using R.

\newpage

## Introduction to Matrices

In R, a *matrix* \index{matrix} is actually an atomic vector---it can only hold one type of element---but with two extra attributes:

* a certain number of rows, and
* a certain number of columns.

One way to create is matrix is to take a vector and *give* it those two extra attributes, via the `matrix()` function. \index{R-functions!matrix()@\texttt{matrix()}} Here is an example:

```{r}
numbers <- 1:24  # this is an ordinary atomic vector
numbersMat <- matrix(numbers, nrow = 6, ncol = 4)  # make a matrix
numbersMat
```

Of course if you are making a matrix out of 24 numbers and you know that it's going to have 6 rows, then you know it must have 4 columns.  Similarly, if you know the number of columns then the number of rows is determined.  Hence you could have constructed the matrix with just one of the row or column arguments, like this:

```{r eval =FALSE}
numbersMat <- matrix(numbers, nrow = 6)
```

Notice that the numbers went down the first column, then down the second, and so on.  If you would rather fill up the matrix row-by-row, then set the `byrow` parameter, which is `FALSE` by default, to `TRUE`:

```{r}
matrix(numbers, nrow = 6, byrow = TRUE)
```

Sometimes we like to give names to our rows, or to our columns, or even to both:

```{r}
rownames(numbersMat) <- letters[1:6]
colnames(numbersMat) <- LETTERS[1:4]
numbersMat
```

Matrices don't have to be numerical.  They can be character or logical matrices as well:

```{r}
creatures <- c("Dorothy", "Lion", "Scarecrow", "Oz",
               "Toto", "Boq")
matrix(creatures, ncol = 2)
```

If you have to spread out the elements of a matrix into a one-dimensional vector, you can do so:

```{r}
as.vector(numbersMat)
```

### Practice Exercises

Let's work with the following vector:

```{r}
dozen <- letters[1:12]
```

1.  Starting with `dozen` write a command that produces the following matrix:

    ```{r echo = FALSE}
    matrix(dozen, nrow = 3)
    ```
    
1.  Starting with `dozen` write a command that produces the following matrix:

    ```{r echo = FALSE}
    matrix(dozen, nrow = 4)
    ```
    
1.  Starting with `dozen` write a command that produces the following matrix:

    ```{r echo = FALSE}
    matrix(dozen, nrow = 4, byrow = TRUE)
    ```
    
1.  Starting with `dozen`, write commands that produce the following matrix:

    ```{r echo = FALSE}
    answerMatrix <- matrix(dozen, nrow = 4, byrow = TRUE)
    rownames(answerMatrix) <- c("r1", "r2", "r3", "r4")
    colnames(answerMatrix) <- c("c1", "c2", "c3")
    answerMatrix
    ```

1. Suppose you make the following matrix:

    ```{r}
    smallMat <- matrix(c(8, 5, 3, 4), nrow =2)
    smallMat
    ```
    
    What's a one-line command to get the folowing vector from `smallMat`?
    
    ```{r echo = FALSE}
    as.vector(smallMat)
    ```
    
1. `nrow()` is a function that, when given a matrix, will tell you the number of rows in that matrix.  Write a one-line command to find the number of rows in a matrix called `mysteryMat`.

1. `ncol()` is a function that, when given a matrix, will tell you the number of rows in that matrix.  Write a one-line command to find the number of columns in a matrix called `mysteryMat`.

### Solutions to Practice Exercises

1.  Here's one way to do it:

    ```{r eval = FALSE}
    matrix(dozen, nrow = 3)
    ```
    
    Here's another way:
    
    ```{r eval = FALSE}
    matrix(dozen, ncol = 4)
    ```
    
1.  Here's one way to do it:

    ```{r eval = FALSE}
    matrix(dozen, nrow = 4)
    ```
    
1.  Here's one way to do it:

    ```{r eval = FALSE}
    matrix(dozen, nrow = 4, byrow = TRUE)
    ```
    
1.  Here's one way to do it:

    ```{r eval = FALSE}
    answerMatrix <- matrix(dozen, nrow = 4, byrow = TRUE)
    rownames(answerMatrix) <- c("r1", "r2", "r3", "r4")
    colnames(answerMatrix) <- c("c1", "c2", "c3")
    answerMatrix
    ```

1. Here's how:
    
    ```{r eval = FALSE}
    as.vector(smallMat)
    ```
    
1. The command `nrow(mysteryMat)` will work.

1. The command `ncol(mysteryMat)` will work.

## Matrix Indexing

Matrices are incredibly useful in data analysis, but the primary reason we are talking about them now is to get you used to working in two dimensions.  Let's practice sub-setting with matrices.

We use the sub-setting operator `[` to pick out parts of a matrix.  For example, in order to get the element in the second row and third column of `numbersMat`, ask for:

```{r}
numbersMat[2,3]
```

The row and column numbers are called *indices*.

If we want the entire second row, then we could ask for:

```{r}
numbersMat[2,1:4]
```

The result is a one-dimensional vector consisting of the elements in the second row of `numbersMat`.  It inherits as its names the column names of `numbersMat`.

Actually, if you want the entire row you don't have to specify which columns you want.  Just leave the spot after the comma empty, like this:

```{r}
numbersMat[2, ]
```

What if you want some items on the second row, but only the items in columns 1, 2 and 4?  Then frame your request in terms of a vector of column-indices:

```{r}
numbersMat[2, c(1, 2, 4)]
```

You can specify a vector of row-indices along with a vector of column-indices, if you like:

```{r}
numbersMat[1:2, 1:3]
```

If the vector has row or column names then you may use them in place of indices to make a selection:

```{r}
numbersMat[, c("B", "D")]
```


You can use sub-setting to change the values of the elements of a matrix

```{r}
numbersMat[2,3] <- 0
numbersMat
```

You can assign a value to an entire row:

```{r}
numbersMat[2,] <- 0
numbersMat
```

In the code above, the 0 was "recycled" \index{recycling} into each of the four elements of the second row 

You can assign the elements of a vector to corresponding selected elements of a matrix:

```{r}
numbersMat[2,] <- c(100, 200, 300, 400)
numbersMat
```

### To Drop or Not?

Note that when we ask for a single row of `numbersMat` we got a regular one-dimensional vector:

```{r}
numbersMat[3, ]
```

The same things happens if we ask for a single column:

```{r}
numbersMat[ , 2]
```

We get the second column of `numbersMat`, but as a regular vector.  It's not a "column" anymore.  (Note that it inherits the row names from `numbersMat`.)

When a subset of a matrix comes from only one row or column, R takes the opportunity to "drop" the class of the subset from "matrix" to "vector."  If you would like the subset to stay a vector, set the `drop` parameter, which by default is `TRUE`, to `FALSE`.  Thus the second column of `numbersMat`, kept as a matrix with six rows and one column, is found as follows:

```{r}
numbersMat[ , 2, drop = FALSE]
```

In most applications people want the simpler vector structure, so they usually leave `drop` at its default value.

### Practice Exercises

In these exercises we'll work with the following matrix:

```{r}
numbers <- 1:40
practiceMatrix <- matrix(numbers, nrow = 4)
rownames(practiceMatrix) <- letters[1:4]
colnames(practiceMatrix) <- LETTERS[1:10]
practiceMatrix
```

1. Write two different one-line commands to get this matrix:

    ```{r echo = FALSE}
    practiceMatrix[c(1,3), 2:5]
    ```
    
1. Write a one-line command to get this matrix:

    ```{r echo = FALSE}
    practiceMatrix[ , seq(1, 9, by = 2)]
    ```
    
1. Write a one-line command to get this vector:

    ```{r echo = FALSE}
    practiceMatrix[ , 1]
    ```
    
1. Write a one-line command to get this vector:

    ```{r echo = FALSE}
    practiceMatrix[2, ]
    ```
    
1. Write a one-line command to get this matrix:

    ```{r echo = FALSE}
    practiceMatrix[ , 1, drop = FALSE]
    ```
    
1.  Write a convenient one-line command to get this matrix:

    ```{r echo = FALSE}
    practiceMatrix[ , -10]
    ```

1.  Write a convenient one-line command to get this matrix:

    ```{r echo = FALSE}
    practiceMatrix[ , -c(2, 10)]
    ```
    
### Solutions to Practice Exercises

1. Here are two ways:

    ```{r eval = FALSE}
    practiceMatrix[c(1,3), 2:5]
    practiceMatrix[c("a","c"), 2:5]
    ```
    
1. Here's one way:

    ```{r eval = FALSE}
    practiceMatrix[ , seq(1, 9, by = 2)]
    ```
    
1. Here's one way:

    ```{r eval = FALSE}
    practiceMatrix[ , 1]
    ```
    
1. Here's one way:

    ```{r eval = FALSE}
    practiceMatrix[2, ]
    ```
    
1. Here's one way:

    ```{r eval = FALSE}
    practiceMatrix[ , 1, drop = FALSE]
    ```
    
1.  Here's one way:

    ```{r eval = FALSE}
    practiceMatrix[ , -10]
    ```

1.  Here's one way:

    ```{r eval = FALSE}
    practiceMatrix[ , -c(2, 10)]
    ```

## Operations on Matrices

Matrices can be involved in arithmetical and logical operations.

### Arithmetical Operations

The usual arithmetic operations apply to matrices, operating element-wise.  For example, suppose that we have:

```{r}
mat1 <- matrix(rep(1, 4), nrow = 2)
mat2 <- matrix(rep(2, 4), nrow = 2)
```

To get the sum of the above two matrices, R adds their corresponding elements and forms a new matrix out of their sums, thus:

```{r}
mat1 + mat2
```

R applies recycling as needed.  For example, suppose we have:

```{r}
mat <- matrix(1:4, nrow = 2)
mat
```

In order to multiply each element of `mat` by 2, we need not create a 2-by-2 matrix of 2's.  We can simply multiply by 2, and R will take care of recycling the 2:

```{r}
2 * mat
```

Or we could subtract 3 from each element of `mat`:

```{r}
mat - 3
```

### Matrix Multiplication

This section is optional reading, but it may interest you if you know about matrix multiplication in linear algebra.

In order to accomplish matrix multiplication, we have to keep in mind that the regular multiplication operator `*` works element-wise on matrices, as we have already seen.  For matrix multiplication R provides the special operator `%*%`.  For example, consider the following matrices:

```{r}
a <- matrix(1:6, ncol = 3)
a
b <- matrix(c(2, 1, -1), nrow = 3)
b
```

Observe that the number of columns of `a` is equal to the number of rows of `b`.  Hence it is possible to form the matrix product `a %*% b`:

```{r}
a %*% b
```

As expected, the result is a matrix having as many rows as the rows of `a`and as many columns as the columns of `b`.

It is also interesting to recall how matrix multiplication works when the second matrix has only one column.  The product is obtained by multiplying each column of `a` by the element on the corresponding row of `b`, and adding the resulting matrices:

```{r eval =FALSE}
b[1,1]*a[ ,1, drop = FALSE] + b[2,1, drop = FALSE]*a[ ,2] + b[3,1]*a[ ,3, drop = FALSE]
```

```{r echo =FALSE}
suppressWarnings(b[1,1]*a[ ,1, drop = FALSE] + b[2,1, drop = FALSE]*a[ ,2] + b[3,1]*a[ ,3, drop = FALSE])
```

### Logical Operations

Boolean operations apply to matrices element-wise, just as they do to ordinary vectors.  The result is a matrix of logical values.  For examples, consider the original matrix `numbersMat`:

```{r}
numbersMat <- matrix(1:24, nrow = 6)
```


Suppose we wish to determine which elements of `numbersMat` are odd.  Then we simply ask whether the remainder of an element after division by 2 is equal to 1:

```{r}
numbersMat %% 2 == 1
```

We can select elements from a matrix using a Boolean operator, too:

```{r}
numbersMat[numbersMat %% 2 == 1]
```

Note that the result is an ordinary, one-dimensional vector.

### Practice Exercises

We'll work with the following three matrices:

```{r}
a <- matrix(c(7, 4, 9, 10), nrow = 2)
a
b <- matrix(1:4, nrow = 2)
b
c <- matrix(letters[1:24], nrow = 6, byrow = TRUE)
c
```

1. Find a one-line command using `a` that results in:

    ```{r echo = FALSE}
    a + 3
    ```
    
1. Find a one-line command using `a` that results in:

    ```{r echo = FALSE}
    2 * a
    ```
    
1. Find a one-line command using `a` that results in:

    ```{r echo = FALSE}
    a^2
    ```

1.  Find a one-line command using `a` and `b` that results in:

    ```{r echo = FALSE}
    a - b
    ```
    
1.  Describe in words what the following command does:

    ```{r eval = FALSE}
    a > 5
    ```
    
1.  Write a one-line command using `a` that tells you which elements of `a` are one more than a multiple of 3.
    
1.  Using `c`, write a one-line boolean expression that produces the following:

    ```{r echo = FALSE}
    c >= "h"
    ```
    
### Solutions to Practice Exercises

1. Here's one way:

    ```{r eval = FALSE}
    a + 3
    ```
    
1.  Here's one way:

    ```{r eval = FALSE}
    2 * a
    ```
    
1.  Here's one way:

    ```{r eval = FALSE}
    a^2
    ```

1.   Here's one way:

    ```{r eval = FALSE}
    a - b
    ```
    
1.   It produces a logical matrix of the same dimensions as `a`.  The new matrix will have `TRUE` in a cell when the corresponding cell of `a` is greater than 5.  Otherwise, the cell will have `FALSE` in it.
    
1.  Here's one way:

    ```{r eval = FALSE}
    a %% 3 == 1
    ```
    
1.  Here's one way:

    ```{r eval = FALSE}
    c >= "h"
    ```

## Introduction to Data Frames

R is known as a *domain-specific programming language*, meaning that although it can in principle perform any sort of computation that a human can perform (given enough pencil, paper and time), it was originally designed to perform tasks in a particular area of application.  R's area of application is data analysis and statistics, especially when performed *interactively*---i.e., in a setting where the analyst asks for a relatively small computation, examines the results, modifies his or her requests and asks again, and so on.^[Domain-specific languages (DSLs for short) stand in contrast to general-purpose programming languages that were designed to solve a wide variety of problems.  Examples of important general-purpose languages include C and C++, Java, Python and Ruby.  Although R is by now the one of the most widely-used DSLs in the world, there a number of other important ones, including Matlab, Octave and Julia for scientific computing, Emacs Lisp for the renowned Emacs editor, and SQL for querying databases. JavaScript is an interesting case:  it started out as a DSL for web browsers, but has since expanded to power many web applications and is now being used to develop desktop applications as well.]  Although R can be used effectively for a wide range of programming tasks, data analysis is where it really shines.

The data structures of R reflect its orientation to data analysis.  We have met a data-oriented structure already---the table, which is one of many convenient ways to display the results of data analysis.  For the purpose of organizing data in preparation for analysis, R provides the structure known as the *data frame*\index{data frame}.  A data frame facilitates the storage of related data in one location, in a form that makes the most sense to human users.

A data frame is like a matrix in that it is two-dimensional---it has rows and columns.  Unlike a matrix, though, the elements of a data frame do not have to be all of the same data-type.  Each column of a data frame is a vector---of the same length as all the others---but these vectors may be of different types:  some numerical, some logical, etc.

### Viewing a Data Frame

Let's take a close look at a data frame:  the frame `m111survey`, which is available from the **tigerstats** package [@R-tigerstats].  First let's attach the package itself:

```{r eval =FALSE}
library(tigerstats)
```

```{r include =FALSE}
library(tigerstats)
```

In the R Studio IDE, we can get a look at the frame in a tab in the Editor pane if we use the `View()` function:

```{r eval =FALSE}
View(m111survey)
```

As with many objects provided by a package, we can get more information about it:

```{r eval =FALSE}
help("m111survey")
```

From the Help we see that `m111survey` records the results of a survey conducted in a number of sections of an elementary statistics course at Georgetown College.  From the View we see that the frame is arranged in rows and columns.  Each row corresponds to what in data analysis is known as a *case* or an *individual*:  here, each row goes with a student who participated in the survey.  The columns correspond to *variables*:  measurements made on each individual.  For a student on a given row, the values in the columns are the values recorded for that student.  

When you are not working in R Studio, there are still a couple of way so view the frame.  You could print it all out to the console:

```{r eval =FALSE}
m111survey
```

You could also use the `head()` function \index{R-functions!head()@\texttt{head()}} to view a specified number of initial rows:

```{r eval =FALSE}
head(m111survey, n = 6)  # see first six rows
```


### The Stucture of a Data Frame

Further information about the frame may be obtained with the `str()` function: \index{R-functions!str()@\texttt{str()}}

```{r}
str(m111survey)
```

The concept of *structure* extends far beyond the domain of computer programming.^[As an example outside of programming, consider what happens when you read a piece of literature "for structure." You begin by asking:  "What kind of literature is this?  Is it drama, a novel, or something else?"  The answer lets you know what to expect as you read:  if it's a novel, you know to suspend disbelief, whereas if it's a journalistic piece then you know to examine critically whatever it presents as fact.  Next, you might outline the piece.  When you make an outline, you are breaking the piece up into parts, and indicating how the parts relate to each other to advance the plot and/or message of the piece.  Note that in the process of "reading for structure" you are following the pattern of the definition of structure offered above.]  In general the structure of any object consists of:

* the kind of thing that the object is;
* the parts of the object is made up of;
* the relationships between these parts---the rules, if you will, for how the parts work together to make the object do what it does.

In the case of `m111survey` the kind of thing this is its *class*: it's a data frame.

```{r}
class(m111survey)
```

Next we see the account of the parts of the object and the way in which the parts relate to one another:

```
## 71 obs. of  12 variables
```

From this we know that there are 71 individuals in the study.  The data consists of 12 "parts"---the variables---which are related in the sense that they all provide information about the same set of 71 people.  

After that the output of `str()` launches into an account of the structure of each of the parts, for example:

```
## $ height         : num  76 74 64 62 72 70.8 70 79 59 67 ...
```

We are told the kind of thing that height is: it's a numerical vector (a vector of type `double`, in fact).  Next we are given the beginning of a statement of its parts: the heights of the individuals.  So R is actually giving us the structure of the parts, as well as of the whole `m11survey`.

The variable `fastest` refers to the fastest speed---in miles per hour---that a person has ever driven a car.  Note that it is a vector of type `integer`.  Officially this is a numerical variable, too, but R is calling attention to the fact that the fastest-speed data is being stored as integers rather than as floating-point decimals.

The variables of a data frame are typically associated with the *names* \index{R-functions!names()@\texttt{names()}}of the frame:

```{r}
names(m111survey)
```

By means of the names we can isolate a vector in any column, identified in our code in the format `frame$variable`.  For example, to see the first ten elements of the `fastest` variable, we ask for:

```{r}
m111survey$fastest[1:10]
```

In order to compute the mean fastest speed our subjects drove their cars, we can ask for:

```{r}
mean(m111survey$fastest, na.rm = TRUE)
```

If you want to see the speeds that are at least 150 miles per hour, you could ask for:

```{r}
m111survey$fastest[m111survey$fastest >= 150]
```

If you worry that the form `frame$variable` will require an annoying amount of typing---as seems to be the case in the the example above---then you can use the `with()` function: \index{R-functions!with()@\texttt{with()}}

```{r}
with(m111survey, fastest[fastest >=150])
```

It's instructive to consider how `with()` works.  If we were to includes the names of the parameters of `with()` explicitly, then the call would have looked like this:

```{r eval =FALSE}
with(data = m111survey, expr = fastest[fastest >=150])
```

For the `data` parameter we can supply a data frame or any other R-object that can be used to construct an environment \index{environment}.  In this case `m111survey` provides a miniature environment consisting of the names of its variables. For the `expr` parameter we supply an expression for R to evaluate.  As R evaluates the expression, it encounters names (such as `fastest`).  Now ordinarily R would first search whatever counts as the \index{active environment}active environment---in this case it's the \index{global environment}Global Environment---for the names in the expression, but `with()` forces R to look first within the environment created by the `data` argument.  In our example, R finds `fastest` inside `m111survey` and evaluates the expression on that basis.  If it had not found `fastest` in `m111survey`, R would have moved on to the Global Environment and then the rest of the usual search path and (probably) would have found nothing, causing it to throw an "object not found" error message.  In R, as in any other programming language, good programming depends very much on paying attention to how the language searches for the objects to which names refer.

### Factors {#factor-variables}

Some of the variables in `m111survey` are called *factors*; an example is `seat`, which pertains to where one prefers to sit in a classroom:

```{r}
str(m111survey$seat)
```

Seating preference is an example of a *categorical* variable:  \index{categorical variable}one whose values are not meaningfully expressed in terms of numbers.  When a categorical variable has a relatively small number of possible values, it can be convenient to store its values in a vector of class `factor`.

The *levels* of  factor variable are its possible values.  In the case of `seat`, these are:  Front, Middle and Back.  As a memory-saving measure, R stores the values in the factor as numbers, where 1 stands for the first level, 2 for the second level, and so on.  But please bear in mind that we are dealing with a categorical variable, so the numbers don't relate to the possible values in any natural way:  they are just storage conventions.

It's possible to create a factor from any type of vector, but most often this is done with a character vector.  Suppose for instance, that eight people are asked for their favorite Wizard of Oz character and they answer:

```{r}
ozFavs <- c("Glinda", "Toto", "Toto", "Dorothy", "Toto",
            "Glinda", "Scarecrow", "Dorothy")
```

We can create a factor variable as follows:

```{r}
factorFavs <- factor(ozFavs)
factorFavs
```

Note that the levels are given in alphabetical order:  this is the default procedure when R creates a factor.  It is possible to ask for a different order, though:

```{r}
factor(ozFavs, levels = c("Toto", "Scarecrow", "Glinda", "Dorothy"))
```

In many instances it is appropriate to convert a character vector to a factor, but sometimes this is not such a great idea.  Consider something like your address, or your favorite inspirational quote:  pretty much every person in a study will have a different address or favorite quote than others in the study.  Hence there won't be any memory-storage benefit associated with creating a factor:  the vector of levels---itself a character vector---would require as much storage space as the original character vector itself!  In addition, we will see that the status of a variable as class "factor" can affect how R's statistical and graphical functions deal with it.  It's not a good idea to treat a categorical variable as a factor unless its set of possible values is considered important.

We will think more about how to deal with factor variables later on, when we begin data analysis in earnest.

### Practice Exercises

1.  How would you learn more about the data frame `RailTrail` from the **mosaicData** package?

1.  Write a one-line command to see the first 10 rows of `RailTrail` in the Console.

1.  Write a one-line command to get the names of all of the variables in `mosaicData::RailTrail`.

1. Regarding `RailTrail`:  write a one-line command to get the high temperature on all the days when the precipitation was more than 0.5 inches.

1. Regarding `RailTrail`:  write a one-line command to sort the average temperatures from highest to lowest.

### Solutions to the Practice Exercises

1.  One way is to attach, then then ask for help:

    ```{r eval = FALSE}
    library(mosaicData)
    help(RailTrail)
    ```
    
    Another way is to refer to the data frame through the package, with double colons:
    
    ```{r eval = FALSE}
    library(mosaicData::RailTrail)
    ```
    
    That way you don't have to add all the items in **mosaicData** to your search path.

1. Here's one way:

    ```{r eval = FALSE}
    head(mosaicData::RailTrail, n = 10)
    ```
    
1.  It's `names(mosaicData::RailTrail)`.

1. Here's one way:

    ```{r eval = FALSE}
    with(mosaicData::RailTrail, hightemp[precip > 0.5])
    ```
    
1.  Try this:

    ```{r eval = FALSE}
    sort(mosaicData::RailTrail$avgtemp, decreasing = TRUE)
    ```
    


## Creating Data Frames

There are many ways to create data frames in R.  Here we will introduce just two ways.

### Creation from Vectors

Whenever you have vectors of the same length, you can combine them into a data frame, using the `data.frame()` function: \index{R-functions!data.frame()@\texttt{data.frame()}}

```{r}
n <- c("Dorothy", "Lion", "Scarecrow")
h <- c(58, 75, 69)
a <- c(12, 0.04, 18)
ozFolk <- data.frame(name = n, height = h, age = a)
ozFolk
```

Note that at the time of creation you can provide the variables with any names that you like.  If later on you change your mind about the names, you can always revise them:

```{r}
names(ozFolk)  
names(ozFolk)[2] <- "Height"  # "height" was at index 2"
ozFolk
```

Let's check the structure of the frame we have made:

```{r}
str(ozFolk)
```

Maybe we would prefer that the `name` variable not be a factor.  We have a couple of options to accomplish this.

1. We could coerce `names` to a character variable, and assign it to the data frame:

    ```{r}
    ozFolk$name <- as.character(ozFolk$name)
    str(ozFolk)
    ```

2. We could prevent `names` from being made into a factor at the time of creation:

    ```{r}
    ozFolk <- data.frame(name = n, height = h, age = a,
                         stringsAsFactors = FALSE)
    str(ozFolk)
    ```


### Creation From Other Frames

If two frames have the same number of rows, you may combine their columns to form a new frame with the `cbind()` function:  \index{R-functions!cbind()@\texttt{cbind()}}

```{r}
ozMore <- data.frame( color = c("blue", "red", "yellow"),
                      desire = c("Kansas", "courage", "brains"))
cbind(ozFolk, ozMore)
```

Similarly if two data frames have the same number *and type* of columns then we can use the `rbind()` function to combine them:  \index{R-functions!rbind()@\texttt{rbind()}}

```{r}
ozFolk2 <- data.frame(name = c("Toto", "Glinda"),
                      height = c(12, 66), age = c(3, 246),
                      stringsAsFactors = FALSE)
rbind(ozFolk, ozFolk2)
```

**Note**:  `cbind()` and `rbind()` work for matrices, too.

## Subsetting Data Frames

Our study of sub-setting matrices can be applied to the selection of parts of a data frame.  As with a vector, one or both of the dimensions of the frame can come into play.

We can create a new data frame consisting of any columns we like from the original frame:

```{r}
df <- m111survey[, c("height", "ideal_ht")]
head(df)
```

If we select just one column, then the result is a vector rather than a data frame:

```{r}
df <- m111survey[, "height"]
is.vector(df)
```

If for some reason you want to prevent this, set `drop` to `FALSE`:

```{r}
df <- m111survey[, "height", drop =FALSE]
head(df)
```


You may select particular rows, too:

```{r}
m111survey[10:15, c("height", "ideal_ht")]
```

You can even select some of the rows at random.  Here is a random sample of size six:

```{r echo = 2:4}
set.seed(2929)
n <- nrow(m111survey)
df <- m111survey[sample(1:n, size = 6, replace = FALSE), ]
df[c("sex", "seat")]  # show just two columns
```

Note the function `nrow()` \index{R-functions!nrow()@\texttt{nrow()}} that gives the number of rows of the frame.  When we sample six items without replacement from the vector `1:n`, we are picking six numbers at random from the row-numbers of the vector.  Specifying these six numbers in the selection operator `[` yields the desired random sample of rows.


### Boolean Expressions

It is especially common to select rows by the values of a logical vector.  For example, to select the rows where the fast speed ever driven is at least 150 miles per hour, try this:

```{r}
df <- m111survey[m111survey$fastest >= 150, ]
df[, c("sex", "fastest")]  # show just two of the variables
```

When you are selecting rows it can be convenient to use the `subset()` function.  \index{R-functions!subset()@\texttt{subset()}}  The first argument to the function is the frame from which you plan to select, and the second is the Boolean expression by which to select:

```{r}
df <- subset(m111survey, fastest >= 150)
df[, c("sex", "fastest")] 
```

Note that we did not need to type `m111survey$fastest`:  the first argument to `subset()` provides the environment in which to search for names that appear in the Boolean expression.

The Boolean sub-setting expressions can be quite complex:

```{r}
df <- subset(m111survey, seat == "3_back" & height < 72 & sex == "female")
df[, c("sex", "height", "seat")]
```

### Practice Exercises

We'll use the `CPS85` data frame from the **mosaicData** package.  You should go ahead and load the package and then read about the data frame:

```{r eval = FALSE}
library(mosaicData)
?CPS85
```

Each row in the data frame corresponds to an employee in the survey.

1. Write a command that gives the number of employees in the data frame.

2. Select the employees who are between 40 and 50 years old.

3. Select the employees who are married and have fewer than 30 years of experience.

4. Select the nonunion employees who either live in the South or who have more than 12 years of education (or both).

5. Select the employees who work in the clerical, construction, management or professional sector.

6.  Select the employees who make more than 30 dollars per hour, and keep only their wage, sex and sector of employment

7.  Select 10 employees at random, keeping only their wage and sex.

8. Select all of the employees, keeping all information about them except for their union status and whether or not they are from the South.

### Solutions to Practice Exercises

1.  The command is  `nrow(CPS85)`.

2. Try this:

    ```{r eval = FALSE}
    subset(CPS85, age > 40 & age < 50)
    ```
    
3. Try this:

    ```{r eval = FALSE}
    subset(CPS85, married == "Married" & exper < 30)
    ```

4. Try this:

    ```{r eval = FALSE}
    subset(CPS85, union == "Not" & (south == "S" | educ > 12))
    ```
    
5. Try this:

    ```{r eval = FALSE}
    subset(CPS85, sector %in% c("clerical", "construction",
                                "management", "professional"))
    ```
    
6. Try this:

    ```{r eval = FALSE}
    CPS85[CPS85$wage > 30, c("wage", "sex", "sector")]
    ```
    
7. Try this:

    ```{r eval = FALSE}
    CPS85[sample(1:nrow(CPS85), size = 10, replace = FALSE),
          c("wage", "sex")]
    ```
    
8. Try this (`south` and `union` are columns 6 and 9, respectively):

    ```{r eval = FALSE}
    CPS85[ , -c(6, 9)]
    ```

## Ordering Data Frames

You can reorder as well as select.  For example, the following code selects the first five rows of`m111survey` and then reverses them:

```{r}
df <- m111survey[, c("height", "ideal_ht")]
dfRev <- df[5:1, ]
head(dfRev)
```

If you want, you can even scramble the rows of the data frame in a random order:

```{r echo = 2:5}
set.seed(3535)
n <- nrow(m111survey)
shuffle <- sample(1:n, size = n, replace = FALSE)
df <- m111survey[shuffle, ]
head(df[c("sex", "seat")])  #show just two columns
```

It is quite common to order the rows of a frame according to the values of a particular variable.  For example, you might want to arrange the rows by `height`,  so that the frame begins with the shortest subject and ends with the tallest.

Accomplishing this task requires a study of R's `order()` \index{R-functions!order()@\texttt{order()}}function.  Consider the following vector:

```{r}
vec <- c(15, 12, 23, 7)
```

Call `order()` with this vector as an argument:

```{r}
order(vec)
```

`order()` returns the indices of the elements of `vec`, in the following order:

* the index of the smallest element (7, at index 4 of `vec`);
* the index of the second-smallest element (12, at index 2 of `vec`);
* the index of the third-smallest element (15, at index 1 of `vec`);
* the index of the largest element (23, at index 3 of `vec`).

Can you guess the output of the following function-call without looking for the answer underneath?

```{r}
vec[order(vec)]
```

Sure enough, the result is `vec` sorted:  from smallest to largest element.

Now the sorting of `vec` could have been accomplished with R's `sort()`function:  \index{R-functions!sort()@\texttt{sort()}}

```{r}
sort(vec)
```

The power of `order()` comes with the rearrangement of rows of a data frame.  In order to "sort" the frame from shortest to tallest subject, call:

```{r}
df <- m111survey[order(m111survey$height), ]
head(df[, c("sex", "height")])  # to show that it worked
```

If you want to order the rows from tallest to shortest instead, then use the `decreasing` parameter, which by default is `FALSE`:

```{r}
df <- m111survey[order(m111survey$height, decreasing = TRUE), ]
head(df[, c("sex", "height")])  # to show that it worked
```

Sometimes you want to order by two or more variables.  For example suppose you want to arrange the frame so that the folks preferring to sit in front come first, followed by the people who prefer the middle and ending with the people who prefer the back.  Within these groups you would like people to be arranged from shortest to tallest.  Then call:

```{r}
ordering <- with(m111survey, order(seat, height))
df <- m111survey[ordering, ]
head(df[, c("seat", "height")], n = 10)  # see if it worked
```

### Practice Exercises

1.  Consider the following vector:

    ```{r}
    creatures <- c("Mole", "Frog", "Rat", "Badger")
    ```
    Write down what you think will be the result of the call:
    
    ```{r eval = FALSE}
    order(creatures)
    ```
    
    Then check your answer by actually running:

    ```{r eval = FALSE}
    creatures <- c("Mole", "Frog", "Rat", "Badger")
    order(creatures)
    ```
    
2.  What will be the result of the following?

    ```{r eval = FALSE}
    order(creatures, decreasing = TRUE)
    ```
    
3.  Arrange the rows of the data frame `mosaicData::CPS85` in order, from the lowest to the highest wage. Break ties by experience (less experience coming before more experience).

4. Arrange the rows of the data frame `mosaicData::CPS85` in order, from the lowest to the highest wage. Break ties by experience (more experience coming before less experience).

### Solutions to Practice Exercises

1.  Here's what you get:

    ```{r}
    order(creatures)
    ```

2. Here's what you get:

    ```{r}
    order(creatures, decreasing = TRUE)
    ```
    
3. Here is one way:

    ```{r eval = FALSE}
    CPS85[order(CPS85$wage, CPS85$exper), ]
    ```

4.  Here is one way:

    ```{r eval = FALSE}
    CPS85[order(CPS85$wage, CPS85$exper, 
                decreasing = c(FALSE, TRUE)), ]
    ```


## New Variables from Old

Quite often you will want to *transform*  one or more variables in a data frame. Transforming a variable means changing its values in a systematic way.

For example, you might want to measure height in feet rather than inches.  Then you want the following

```{r}
heightInFeet <- with(m111survey, height/12)  # 12 inches in a foot
```

If you plan to use this new variable in your analysis later on, it might be a good idea to add it to the data frame:

```{r}
m111survey$height_ft <- heightInFeet
```

Another common need is to *recode* the values of a categorical variable.  For example, you might want to divide people into two groups:  those who prefer to sit in the back and those who don't.  This is a good time to use `ifelse()`:

```{r}
seat2 <- ifelse(m111survey$seat == "3_back", "Back", "Other")
m111survey$seat2 <- seat2
```

If you plan to re-code into a variable that involves more than two values, then you might want to look into the `mapvalues()` function from the **plyr** package [@R-plyr]:

```{r}
seat3 <- plyr::mapvalues(m111survey$seat,
                from = c("1_front", "2_middle", "3_back"),
                to = c("Front", "Middle", "Back"))
str(seat3)
```

The do-it-yourself approach is to write a loop.  Remember `switch()`? \index{R-functions!switch()@\texttt{switch()}}

```{r}
seat <- m111survey$seat
seat3 <- character(length(seat))  # this will be the recoded variable
for ( i in 1:length(seat) ) {
  seat3[i] <- switch(as.character(seat[i]),
                     "1_front" = "Front",
                     "2_middle" = "Middle",
                     "3_back" = "Back")
}
str(seat3)
```

The re-coding is done but the result is a character vector and not a factor. We have to make it a factor ourselves:

```{r}
m111survey$seat3 <- factor(seat3, levels = c("Front", "Middle", "Back"))
```

This seems like a lot of work!

Another common transformation involves turning a numerical variable into a factor.  For example, we might need to classify people as:

* Tall (height over 70 inches)
* Medium (65 - 70 inches)
* Short (less than 65 inches)

The `cut()` function \index{R-functions!cut()@\texttt{cut()}} will be helpful.

```{r}
heightClass <- cut(m111survey$height,
                   breaks = c(-Inf, 65, 70, Inf),
                   labels = c("Short", "Medium","Tall"),
                   right = TRUE)
str(heightClass)
```

Setting `right = TRUE` indicates that the upper bound of each interval is included in the interval.  Thus, a person with a height of 70 inches is classed as Medium, not Tall.

### Getting Rid of Variables

We have added several variables to `m111survey`.  In order to remove them (or any other variables we don't want) we can assign them the value `NULL`.

```{r}
names(m111survey)
m111survey$height_ft <- NULL
m111survey$seat2 <- NULL
m111survey$seat3 <- NULL
names(m111survey)  # the extra variables are gone
```

### Practice Exercises

1. Remove the variables `hispanic` and `married` from the `mosaicData::CPS85` data frame.

2.  Change the units of `wage` in `mosaicData::CPS85` from dollars per hour to dollars per day.  Assume an eight-hour working day.

3.  For `CPS85`, create a new variable `experGrp` that has the following values

    * `low` for experience less than 10 years;
    * `medium` for experience of at least 10 years but less than 25 years;
    * `high` for experience at least 25 years.
    
4. You've made some changes to `CPS85`, but in fact you haven't changed the original data frame in the **mosaicData** package---you've simply made your own copy, which should now be in your Global Environment.  Since the Global Environment comes before any package on your search path, if you want to get to the original `CPS85` you will either have to refer to it as `mosaicData::CPS85`.  Another option, though, is to remove the modified copy from your Global Environment.  Go ahead an remove it now.

### Solutions to Practice Exercises

1.  Here's one way to do it:

    ```{r eval = FALSE}
    CPS85$hispanic <- NULL
    CPS85$married <- NULL
    ```
    
2. Here's one way to do it:

    ```{r eval = FALSE}
    CPS85$wage <- CPS85$wage * 8
    ```
    
3. Here's one way to do it:

    ```{r eval = FALSE}
    CPS85$experGrp <- cut(CPS85$exper,
                       breaks = c(-Inf, 10, 25, Inf),
                       labels = c("low", "medium", "high"))
    ```
    
4. Here' what to do:

    ```{r eval = FALSE}
    rm(CPS85)
    ```

\newpage

## Glossary {-}

Matrix  \index{matrix}

:  An atomic vector that has two additional attributes:  a number of rows and a number of columns.

Data Frame \index{data frame}

:  A two-dimensional data structure in R in which the columns are atomic vectors that can be of different types.

Case (also called an Individual) \index{case}

:  An individual unit under study.  In a data frame in R, the rows correspond to cases.  

Variable (in Data Analysis)

:  In data analysis, a *variable* is a measurement made on the individuals in a study.

Categorical Variable (in Data Analysis)

:  In data analysis, a *categorical variable* is a variable whose values cannot be expressed meaningfully by numbers.

\newpage

## Exercises {- #frames-exercises}

```{r echo=FALSE, fig.pos='!h', out.width="50%", fig.align="center"}
knitr::include_graphics("images/thinking.png")
```

```{r echo =FALSE}
dimSum <- function(mat, dim = c("row", "column")) {
  dim <- match.arg(dim)
  if (dim == "column") mat <- t(mat)
  sums <- numeric(nrow(mat))
  for ( i in 1:nrow(mat) ) {
    sums[i] <- sum(mat[i, ])
  }
  sums
}

transpose <- function(mat) {
  matrix(as.vector(mat), nrow = ncol(mat), byrow = TRUE)
}

dfRandSelect <- function(df, n) {
  rows <- nrow(df)
  if ( n > rows ) {
    return(cat("No can do!  The frame has only", rows, "rows."))
  }
  df[sample(1:rows, n, FALSE), ]
}

set.seed(4040)
lowerLetters <- character(100)
for ( i in 1:100 ) {
  lowerLetters[i] <- paste0(sample(letters, 3, TRUE), collapse = "")
}
height <- runif(100, 60, 75)
sex <- sample(c("female", "male"), 100, TRUE)
myFrame <- data.frame(lowerLetters = lowerLetters,
                      height = height,
                      sex = sex,
                      stringsAsFactors = FALSE)
myFrame$sex <- factor(myFrame$sex)
```

1.  R has a function called `t()` that computes the *transpose* of a given matrix.  This means that it switches around the rows and columns of the matrix, like this:

    ```{r}
    myMatrix <- matrix(1:24, nrow = 6)
    myMatrix
    t(myMatrix)
    ```
    
    Write your own function called `transpose()` that will perform the same task on any given matrix.  The function should take a single parameter called `mat`, the matrix to be transposed.  **Of course you may NOT use `t()` in the code for your function!**
    
    **Hints:**  Your function will have to:
    1. break `mat` down into the vector of its elements, and then
    2. build the new matrix from those elements, with a number of rows equal to the number of columns of `mat`.
    
    For the first task, `as.vector()` will be useful.  For the second task, recall that the function `nrow()` returns the number of rows of a given matrix.  You will be interested to know that there is also a function `ncol()` that computes the number of columns of a given matrix.

1. R has functions called `rowSums()` and `colSums()` that will respectively sum the rows and the columns of a matrix.  Here is an example:

    ```{r}
    myMatrix <- matrix(1:24, nrow = 6)
    rowSums(myMatrix)
    ```
    
    Your task is to write your own function called `dimSum()` that will sum either the rows or the columns of a given matrix.  The function should have two parameters:
    * `mat`:  the matrix to be summed.
    * `dim`:  the dimension to sum along, either rows or columns.  The default value should be `c("rows", "columns")`, and you should use argument-matching (see Section \@ref(argument-matching)) so that the user doesn't have to spell out all of the possible arguments.
    
    **You may NOT use `rowSums()` or `colSums()` in the code for your function.**  A typical example of use should look like this:
    
    ```{r}
    myMatrix <- matrix(1:24, nrow = 6)
    dimSum(myMatrix, "c")
    ```
    
    **Hint**:  To start, take it easy on yourself.  Instead of writing a function that sums rows or columns as per the user's request, write a function called `myRowSums()` that will just find the row-sums of any given matric.  You could use a loop, here.  Your function can loop along the rows of the matrix, computing the row sums and storing them in a results vector that you set up prior to the loop.
    
    Once you have `myRowSums()` working, write a function called `myColSums()` that find the column-sums of any given matrix.
    
    Finally, use the two previously-created functions to write the function `dimsum()`.

1. Starting with `m111survey` in the **tigerstats** package, write the code necessary to create a new data frame called `smaller` that consists precisely of the male students who believe in extraterrestrial life and who are more than 68 inches tall.  The new data frame should contain all of the original variables except for `sex` and `extra_life`.

1.  Write a function called `dfRandSelect()` that randomly selects (without replacement) a specified number of rows from a given data frame.  The function should have two parameters:
    * `df`:  the data frame from which to select;
    * `n`:  the number of rows to select.
    
    If `n` is greater than the number of rows in `df`, the function should return immediately with a message informing the user that the required task is not possible and informing him/her of the number of rows in `df`.  Typical examples of use should be as follows:
    
    ```{r echo=2:2}
    set.seed(2020)
    dfRandSelect(tigerstats::fuel, 5)
    ```
    
    ```{r eval=FALSE}
    dfRandSelect(tigerstats::fuel, 200)
    ```
    
    ```
    ## No can do!  The frame has only 15 rows.
    ```
    
    **Hint**:  Use the function `nrow()`, which gives the number of rows of a matrix or data frame.
    
1.  (\*) Create your own data frame, named `myFrame`.  The frame should have 100 rows, along with the following variables:
    * `lowerLetters`:  a character vector randomly-produced 3-letter strings, like "chj", "bbw", and so on.  The letters should all be lowercase.
    * `height`:  a numerical vector consisting of real numbers chosen randomly between the values of 60 and 75.
    * `sex`:  a factor whose possible value are "female" and "male".  Again, these values should be chosen randomly.
    
    A call to `str(myFrame)` would come out *like* this (although your results will vary a bit since the vectors are constructed randomly):
    
    ```{r}
    str(myFrame)
    ```
    
    `summary()` is useful when working with data frames.  Here is how a call to `summary(myFrame)` might look:
    
    ```{r}
    summary(myFrame)
    ```
    
    **Hint**:  If you have a vector of three letters, such as
    
    ```{r}
    vec <- c("g", "a", "r")
    ```
    
    then you can paste them together as follows:
    
    ```{r}
    paste0(vec, collapse = "")
    ```
    
1.  (\*) Study the data frame `fuel` in the **tigerstats** package.  Note that the fuel efficiency is reported as the number of liters of fuel required to travel 100 kilometers.  Look up the conversion between gallons and liters and between kilometers and miles, and use this information to create a new variable called `mpg` that gives the fuel efficiency as miles per gallon.  While you are at it, create a new variable `mph` that gives the speed in miles per hour.  Finally, add these new variables to the `fuel` data frame.  

1. (\*) Use matrices to generalize the simulation in the Appeals Court Paradox (see Section \@ref(appeals-court-paradox)).  Your goal is to write a simulation function called `appealsSimPlus()` that comes with all the options provided in the text, but with additional parameters so that the user can choose:
    * the number of judges on the court;
    * the probability for each judge to make a correct decision;
    * the voting pattern (how many votes each judge gets).
    
    A typical call to the functions should look like this:

    ```{r eval =FALSE}
    appealsSimPlus(reps = 10000, seed = 5252, 
                   probs = c(0.95, 0.90, 0.90, 0.90, 0.80),
                   votes = c(2, 1, 1, 1, 0))
    ```
    
    In the above call the court consists of five judges.  The best one decides cases correctly 95\% of the time, three are right 90\% of the time and one is right 80\%of the time.  The voting arrangement is that the best judge gets two votes, the next three get one vote each, and the worst gets no vote. Any voting scheme---even a scheme involving fractional votes---should be allowed so long as the votes add up to the number of judges.
    
    **Here is a hint.**  When you write the function it may be helpful to use the fact that `rbinom()` can take a `prob` parameter that is a vector of any length.  Here's an example:
    
    
    ```{r echo=2:3}
    set.seed(5252)
    results <- rbinom(6, size = 100, prob = c(0.10, 0.50, 0.90))
    results
    ```

    The first and fourth entries simulate a person tossing a fair coin 100 times when she has only a 10\% chance of heads.  The second and fifth entries simulate the same, when the chance of heads is 50\%.  The third and sixth simulate coin-tossing when there is a 90\% chance of heads.
    
    If you would like to arrange the results more nicely---say in a matrix where each column gives the results for a different person---you can do so:
    
    ```{r}
    resultsMat <- matrix(results, ncol = 3, byrow = TRUE)
    resultsMat
    ```
    
    Of course judges don't flip a coin 100 times, they decide one case at a time.  Suppose you have five judges with probabilities as follows:
    
    ```{r}
    probCorrect <- c(0.95, 0.90, 0.90, 0.90, 0.80)
    ```
    
    If you would like to simulate the judges deciding, say, 6 cases, try this:

    ```{r echo = 2:4}
    set.seed(4848)
    results <- rbinom(5*6, size = 1, prob= rep(probCorrect, 6))
    resultsMat <- matrix(results, nrow = 6, byrow = TRUE)
    resultsMat
    ```    
    
    When it comes to applying the voting pattern to compute the decision in each case, consider matrix multiplication.  For example, suppose that the pattern is:
    
    ```{r}
    votes <- c(2, 1, 1, 1, 0)
    ```
    
    Then make `votes` a one-column matrix and perform matrix multiplication:

    ```{r}
    correctVotes <- resultsMat %*% matrix(votes, nrow = 5)
    correctVotes
    ```
    
    Think about how to encapsulate all of this into a nice, general simulation function.