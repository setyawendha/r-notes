[
["index.html", "Beginning Computer Science with R Preface", " Beginning Computer Science with R Homer White 2020-04-09 Preface Welcome to Beginning Computer Science with R! These notes will be your primary source for CSC 115: Computer Science I, offered at Georgetown College. They will also carry you most of the way through CSC 215. For the first semester you won’t need a computer of your own: you can do all of your work on the R Studio Server, which you will access with your College network username and password. Eventually, though, you will need to learn how to install and maintain professional software development tools on your own machine, so at some point early on in CSC 215 you will install R, R Studio and various other tools on a laptop of your own. Then you will bring the laptop to class for your daily work. These Notes are available not only on the web but also as a PDF document that can be downloaded from the website (click the PDF icon, found among the icons at the top of the page). The PDF is useful when you are working offline, and it also has an index. Instructional videos on selected topics will be published from time to time on this YouTube Channel: https://www.youtube.com/user/GCstats, in the CSC playlist. These notes are about the R programming language as such, so although in the class we will work within the R Studio Integrated Development Environment right from the start, R Studio is not directly covered here. Eventually we will begin to write documents in R Markdown, which is also not treated in these Notes. For a resource on these topics in written form that will supplement class instruction and the videos on our YouTube Channel, you might want to consult the excellent little book Getting used to R, RStudio, and R Markdown (Ismay 2016). References "],
["the-why-of-these-notes-remarks-for-colleagues.html", "0.1 The Why of These Notes: Remarks for Colleagues", " 0.1 The Why of These Notes: Remarks for Colleagues There is a plethora of books on R, covering pretty much every domain of application of the language, from ecology to spatial statistics to machine learning and data science. There are even some books—among the very finest of R-books, in my view—on R as a programming language. These Notes are not intended to supersede or to compete with any of the existing literature on R. Instead they are intended to serve the curricular needs of the Computer Science minor at the College where I teach—a minor that emphasizes data analysis primarily, but with a strong focus also on web design and on the increasingly important interfaces between these two areas (e.g., interactive graphics and web apps for working with data and/or reporting the results of data analysis). Students will undertake a serious study of two major scripting languages: R for data analysis and JavaScript for web programming, both from a fairly systematic programming point of view, with due attention to procedural, functional and (to a lesser extent) object-oriented programming paradigms. The question is: which language to use in the freshman year? Some institutions are moving toward JavaScript: in fact Stanford University piloted JavaScript in several sections of its introductory CS course in the Fall of 2017. There are certainly considerations in favor of a JavaScript-first approach: it’s a popular language, with Node available as an interactive run-time environment and the browser as a environment in which exciting applications can be built quickly. And whereas R is less widely-used and is still considered a domain-specific language, JavaScript can rightly be said to have made the leap into the ranks of general-purpose programming languages. R also has the reputation of being a prickly language with a somewhat inconsistent syntax and with documentation that is “expert-friendly” at best. On the other hand R is designed for one-line interactivity at the console, so it’s possible for a beginner to get simple programs working quickly. The R-ecosystem has also become a lot more user-friendly in recent years. The RStudio IDE is comparable to top-flight integrated development environments for many other major languages and yet is still relatively lightweight and accessible to beginners. The Server version of R Studio is especially useful for new programmers, as it saves them from having to deal with installation and other IT issues on their own machines, permitting them to focus on coding. It’s also quite convenient, in a server setting, to make class materials available and to collect and return assignments. R Markdown is fine platform for producing course notes (this book is written in R Markdown with the excellent bookdown package (Xie 2019b)) and slides as well. Students, too, can use R Markdown to both write and discuss their programs in a single document. The blogdown package (Xie 2019a) permits students to begin writing for the public about technical programming issues—or about anything at all, really, as more than a few of them are taking majors in the Humanities—thus building up a professional resume of online work. When it’s time to learn about databases, students can leverage a body of recent work (see Databases Using R) that renders the R Studio environment nearly as friendly for interaction with databases as dedicated tools such as MySQL Workbench. Finally, the shiny package (Chang et al. 2020) permits students to build simple interactive web apps for data analysis that can be used by non-coders. Both blogdown and shiny prompt students to consider early on—even in the first year, if the pacing is right—concepts of web design, the other focus of the minor. Hence the choice was made to teach a first-year computer science course, to beginning programmers, with R. As I pointed out earlier, there do exist some excellent books on R as a programming language that do not presume previous experience with R. One example is Norman Matloff’s The Art of R Programming (Matloff 2011). Matloff, however, presumes that the reader either has prior programming experience in some other language or else possesses sufficient computational maturity, acquired perhaps through extensive prior training in the mathematical sciences. Another great text is Garrett Grolemund’s Hands-on Programming with R (Grolemund 2014). Grolemund’s book is lively and to-the-point, and starts off with excellent motivating examples. Grolemund is also a master explainer, and he has put considerable effort into visual representation of programming concepts such as element-wise operations on vectors and the enclosure-relationships between environments. On the other hand, even though he doesn’t assume that the reader has prior coding experience, Grolemund does assume some prior background in data analysis and a strong motivation, on the reader’s part, to persevere with nontrivial R-programming issues such as lexical scoping in the hopes of eventual payoffs in programming for data science. In short, Grolemund also assumes more computational maturity than will be usually be found among beginning programmers at many small liberal arts colleges. Hence the niche for the Notes offered here. I aim to be more copious and slower-paced than Grolemund and less sophisticated than Matloff. These notes will also contain a more extensive set of problems, ranging in difficulty from practice exercises to fairly extended projects that students might write up in R Markdown documents. Experienced programmers and R enthusiasts will be struck by the absence of certain topics. Programmers will observe that there is no real attention to algorithms (sorting is just sort() or order()), and although functions receive lots of attention there is no mention of recursion. In future editions I might cover recursion, as I believe that it is wonderful for the development of thinking skills, but it’s not likely that a web developer or data analyst would have the need to write a recursive function. Time spent on recursion and on various efficient algorithms for sorting and searching may be better spent, in my view, on extended programming projects, Shiny apps and blogging, and the introduction of programmer’s trade-tools such as version control and GitHub. I hope by the end of the first year to have made time for all of these out-of-book topics. The Notes give more attention to base R functions than other introductory texts directed to data analysts, but we do introduce elements of the tidyverse as appropriate. The pipe operator is introduced in connection with data frames, ggplot2 and graphing are treated in some detail, string operations and regular expressions are managed primarily with stringr, and the approach to higher-order functions is through purrr. Full treatment of the data wrangling is deferred, however, to later courses. The first-semester course is required for mathematics and physics majors and for students in our pre-engineering program, so a central application of the early material is simulation of random processes. I believe that this makes the Notes relevant for students in other disciplines—e.g., biology and finance—in a way that complements their use of R for data analysis. Two of the most fundamental topics in any comprehensive discussion of the R language—lexical scoping and computing on the language—are absent from this book. Lexical scoping and its implications are mentioned only in a brief footnote. Partly this is due the fact that most of the elementary applications of lexical scoping mentioned in the literature are related to scientific computing, which won’t be a concern for most of my students. Certainly lexical scoping is important for understanding how R-packages work, but elementary students don’t author packages. As for computing on the language it is true that users are affected by it all the time (e.g., whenever they use functions with a formula interface), but generally one need not perform any computation on the language until one begins writing formula-interface functions for the benefit of casual R-users. On the other hand I have made some effort to explore programming paradigms other than procedural programming, perhaps in a bit more depth than in other elementary texts that teach with a scripting language. There is a chapter on functional programming that, although it admittedly does not get far into the functional paradigm, at least does treat extensively of R’s support for higher-order functions. A chapter on object-oriented programming covers not only the generic-function OO that has been with R from the start but also an implementation of message-passing OO (Winston Chang’s R6 package (Chang 2019)). My hope is that these topics will not only sharpen my students’ R-programming skills but also prepare them for encounters with the OO-methods and higher-order functions that are ubiquitous in JavaScript. Finally, there is a pretty serious chapter on regular expressions, because: they are useful in data analysis; I have not found a treatment of regular expressions in R that a person without significant prior exposure to them in other languages has a prayer of following; and because if you master regular expressions then you feel like a wizard. As for the numerous Wizard of Oz-themed examples, I can offer no defense other than haste in composition and the fact that the Wizard of Oz is now in the public domain. References "],
["history-of-r.html", "0.2 History of R", " 0.2 History of R The story of R begins at Bell Labs in 1975, with the development, by John Chambers and several other colleagues, of the S language for statistical computing. The language became well-known among statisticians and data analysts, especially in the academic community. In the early 1990’s Ross Ihaka of the University of Auckland in New Zealand was making a study of the Scheme language as described in the classic MIT textbook Structure and Interpretation of Computer Programs (Harold Abelson and Sussman 1996), and was impressed with the possibilities of the language for data analysis applications. Desiring to build a free analysis tool for his graduate students, Ihaka recruited his Auckland colleague Robert Gentleman in the project of developing a language with an external syntax similar to S but with an underlying engine based heavily upon Scheme. Because of the similarity with the better-known S—or, by some accounts, because of the initial letter in the first names of both men—they named their new language “R”. Initially the Ihaka and Gentleman assumed that their work on the new language was scarcely more than “playing games” and that it would not be used outside of the University of Auckland. Eventually, though, the two placed a small announcement of their project on the s-news email list and began to draw the interest of other statisticians, including Martin Machler of the Swiss Federal Institute of Technology in Zurich, Switzerland. Machler saw great potential for R, and in 1995 persuaded Ihaka and Gentleman to release it as “free software” under a GNU Public License. The decision to make R free stimulated further interest in the language and encouraged many experts in statistical computation to become involved in its further development. The first official public release of R (version 1.0.0) occurred on February 29, 2000. Since that time R has grown in popularity at an increasing rate, to the point where it is by now one of the world’s most widely-used domain-specific computer languages, ranking among the top dozen computer languages overall. Many people have contributed to the development of R. As of the composition of this History, the Comprehensive R Archive Network (CRAN) hosted 10,633 contributed packages, each of which aims to extend the capabilities of R in a specific way. R is usually the platform in which new statistical techniques are first implemented by the researchers who develop them. It is widely used in the sciences, business and finance. References "],
["acknowledgements.html", "0.3 Acknowledgements", " 0.3 Acknowledgements I am greatly indebted to: Norman Matloff and Hadley Wickham for their excellent foundational books ((Matloff 2011), (Wickham 2014)) on the R language. Garrett Grolemund, for his informal but precise expository style, as exemplified in numerous R Studio webinars and in (Grolemund 2014). Allen Downey, for Think Python (Downey 2015). This book formed my ideas about ordering and selection of topics for computer science at an elementary level, and helped me think about teaching computer science in a way that was as independent as possible from the specific language of instruction. Everyone at R Studio, including Hadley, Yihui Xie for R Markdown and the family of R Markdown-related packages, Joe Cheng for conceiving and pioneering shiny, Winston Chang for shiny and R6, and of course JJ Allaire for developing the IDE and calling together the remarkable constellation of developers and evangelists who have contributed so much to the R community and ecosystem. Danny Kaplan, Nick Horton and Randall Pruim for pioneering the Mosaic Project that has enabled so many faculty to teach undergraduate statistics with R. I am especially indebted to Danny for curricular inspiration and to Randall for R-programming advice in the incipient stages of my journey as an R-developer. Nick has been a great encourager of everyone associated with the Mosaic community. My former colleague Rebekah Robinson who, upon learning of Mosaic and R Markdown, insisted that at Georgetown College we take up the challenge of teaching elementary statistics with R. My colleagues William Harris and Christine Leverenz, who patiently learned to teach in the R way. My students, especially Woody Burchett, Luke Garnett, Shawn Marcom, Jacob Townsend and Andrew Giles, for work with me on various R-related research projects. Luke has gone on to become a valued colleague at Georgetown. Georgetown College, for granting me the sabbatical time in Spring 2017 to work on these Notes, and on other programming topics prerequisite to teaching Computer Science. My wife Mary Lou and daughters Clare, Catherine and Agnes, for patience and support. By now they have heard quite enough about programming. References "],
["miscellaneous-information.html", "0.4 Miscellaneous Information", " 0.4 Miscellaneous Information 0.4.1 R Packages This book uses the following contributed R packages that are currently available from CRAN, the Comprehensive R Archive Network: devtools ggplot2 mosaicData R6 tidyverse If you are working on the Georgetown College R Studio Server then they are already installed for you. If you have your own installation then you can get them via the install.packages() function, e.g., install.packages(&quot;devtools&quot;) In addition we use two packages from the author’s Github repositories: bcscr (functions and data sets to accompany the text) tigerData (data sets used in examples and exercises) If you aren’t working on the R Studio Server at Georgetown College then you may have to install them yourself, as follows: devtools::install_github(&quot;homerhanumat/bcscr&quot;) devtools::install_github(&quot;homerhanumat/tigerData&quot;) 0.4.2 Typographical Conventions Computer code, whether within a line of text or as displayed text, appears like this: code snippet. Identifiers and are represented as is (e.g., variableName, if, else, while, etc.) except for the names of functions, which are followed by a pair of parentheses in order to stress their status as functions. Thus we write length() for the length-function. Displayed text representing output to the console appears with double hash-tags at the beginning of each line, thus: ## R is free software and comes with ABSOLUTELY NO WARRANTY. ## You are welcome to redistribute it under certain conditions. ## Type &#39;license()&#39; or &#39;licence()&#39; for distribution details. The hash-tags themselves are not present in the output itself. Names of R-package are in boldface, thus: package devtools. Terms are italicized when they are first introduced, e.g.: “R follows a set of internal rules to coerce some of the values to a new type in such a way that all resulting values are of the same type.” Italicization can also indicate emphasis. 0.4.3 License These Notes are licensed under the Creative Commons Attribution-ShareAlike 4.0 International Public License: https://creativecommons.org/licenses/by-sa/4.0/legalcode. "],
["idea.html", "Chapter 1 Our First Computer Programs", " Chapter 1 Our First Computer Programs Figure 1.1: The Yellow Brick Road, by Jorge Cruz. clipartfest.com. "],
["hello-world.html", "1.1 Hello, World!", " 1.1 Hello, World! Let’s write our very first computer program. Type the following code into the console and press Enter: cat(&quot;Hello, World!&quot;) In the console you should see the following output: ## Hello, World! That’s it—you just wrote a computer program. A computer program is simply a sequence of instructions that perform a specific task when they are executed (carried out) by the computer. In the above example, there was only one instruction in the sequence: it was the command to reproduce the string “Hello, World” in the console exactly as it is. The name of that command is cat(). Let’s try another small program. Type the following code into the console and press Enter: cat(2+2) In the console you should see the following output: ## 4 We have been using the cat() function so far. Actually you can get output without it. For example, suppose you type: &quot;Hello, World!&quot; Then in the console you see: ## [1] &quot;Hello World&quot; There are quote-marks around the text: that’s not so pretty, but we still get the basic output. Similarly, you can try: 2 + 2 ## [1] 4 Notice that when we don’t use cat() the output begins with a strange [1]. In the next chapter we’ll learn why this happens; for now, just ignore it. "],
["idea-tour.html", "1.2 A Quick Tour", " 1.2 A Quick Tour We now embark on a tour of some of R’s basic capabilities. In later chapters we will examine in detail the programming concepts that underlie the features we explore now. 1.2.1 Basic Arithmetic R can be treated like a calculator. You can: add numbers (+) subtract numbers (-) multiply numbers (*) divide numbers (/) raise a number to a power (^) Just as on a graphing calculator, parentheses can be used to clarify the order of operations. Here are some examples: To get \\(\\frac{27-3}{10}\\), use: (27-3)/10 ## [1] 2.4 To get \\(3^2 + 4^2\\) try: 3^2+4^2 ## [1] 25 Sometimes you’ll want to take roots. As with a calculator, you can accomplish this by raising your number to a fractional power. So if you want \\(\\sqrt[3]{64}\\) then you could try: 64^(1/3) ## [1] 4 If you would like square roots then you can either raise your number to the \\(1/2\\)-power or you could use R’s special square-root function: sqrt(64) ## [1] 8 One way or another, you can evaluate quite complex mathematical expressions. For example, to get \\(\\sqrt{3^2 + 4^2}\\) simply type: sqrt(3^2+4^2) ## [1] 5 1.2.2 Read-Evaluate-Print-Loop So far you have been using R in what computer scientists call interactive mode. This means that you type something in at the console; R immedidately reads what you type and evaluates it, and prints the resulting value to the console for you to see. Then you type something else, and so on. This back-and-forth process is often called the Read-Evaluate-Print-Loop, or REPL for short. R is one of several computer languages that make it easy for you to see the results of its computations in the console. That’s because it was originally designed for use by statisticians and data analysts, who often want to run a small procedure, check on the results and then try a new or related procedure and check on the results … until their analysis is complete. From our point of view as beginning programmers, though, the REPL makes it easy to see what R is doing and to get immediate feedback on the very simple programs that we are now writing. 1.2.3 Variables Quite often you will want to use the same value several different times. You can so this by creating a variable with the assignment operator &lt;-. a &lt;- 10 The previous statement puts the value 10 in the computer’s memory and causes the name a to be bound to it. This means that if you ask R to show you a, you’ll get that value: a ## [1] 10 Now you can use a as much as you like. Whenever you use it, R will know that it stands for the value 10: a + 23 ## [1] 33 sqrt(a) ## [1] 3.162278 Later on if you want to bind the name a to a different value, you can do so, with another assignment-statement: a &lt;- 4 a + 23 ## [1] 27 Let’s write some code to introduce creatures of various types. A creature should give his or her name, say what type of creature he or she is, and name a favorite food. creatureType &lt;-&quot;Munchkin&quot; creatureName &lt;- &quot;Boq&quot; creatureFood &lt;- &quot;corn&quot; Notice that I chose variable-names that are descriptive of the values to which they are bound. That’s often a good practice. Next, let’s combine our items into a greeting: paste(&quot;Hello, I am a &quot;, creatureType, &quot;. My name is &quot;, creatureName, &quot;. I like to eat &quot;, creatureFood, &quot;.&quot;, sep = &quot;&quot;) ## [1] &quot;Hello, I am a Munchkin. My name is Boq. I like to eat corn.&quot; We see that paste() function puts strings together. The sep = &quot;&quot; argument at the end specifies that no space is to be inserted between the strings when they combined. Another thing we notice in the previous code is that R can ignore white space: we were able to place the parts of the command on different lines. This helps prevent our lines from being too long, and allows us to arrange the code so that it’s easy to read. Spaces do matter inside a string, though: kalidah &lt;- &quot;Teddy&quot; kalidah ## [1] &quot;Teddy&quot; kalidah2 &lt;- &quot;Ted dy&quot; kalidah2 ## [1] &quot;Ted dy&quot; You must also be careful not to insert spaces within the name of any object: kali dah2 ## Error: unexpected symbol in &quot;kali dah2&quot; R got confused by the unexpected space: it knows about the name kalidah2, but kali dah2 means nothing to R. Getting back to the Oz-creatures: it would be nice if a creatures’s greeting could be split over several lines. This is possible if you use the special string “\\n”, which produces a newline. Just incorporate it into your message, as follows: paste(&quot;Hello, I am a &quot;, creatureType, &quot;.\\nMy name is &quot;, creatureName, &quot;.\\nI like to eat &quot;, creatureFood, &quot;.&quot;, sep = &quot;&quot;) ## [1] &quot;Hello, I am a Munchkin.\\nMy name is Boq.\\nI like to eat corn.&quot; That doesn’t look like an improvement at all! But what if we were to cat() it? message &lt;- paste(&quot;Hello, I am a &quot;, creatureType, &quot;.\\nMy name is &quot;, creatureName, &quot;.\\nI like to eat &quot;, creatureFood, &quot;.&quot;, sep = &quot;&quot;) cat(message) ## Hello, I am a Munchkin. ## My name is Boq. ## I like to eat corn. That’s much nicer. That last example showed that you can use variables together with functions to create new variables. Here is another example: a &lt;- 10 b &lt;- 27 mySum &lt;- a + b mySum ## [1] 37 1.2.4 Functions Let’s say that we want to introduce George the Quadling. We might try: creatureName &lt;- &quot;George&quot; creatureType &lt;- &quot;Quadling&quot; creatureFood &lt;- &quot;cookies&quot; cat(message) ## Hello, I am a Munchkin. ## My name is Boq. ## I like to eat corn. Hmm, that didn’t go so well: we got Boq instead. The problem is that the variablemessage was created using the original values of creatureName, creatureType and creatureFood, not the new values that we are interested in. To do it right we should have re-made message, as follows: creatureName &lt;- &quot;George&quot; creatureType &lt;- &quot;Quadling&quot; creatureFood &lt;- &quot;cookies&quot; message &lt;- paste(&quot;Hello, I am a &quot;, creatureType, &quot;. \\nMy name is &quot;, creatureName, &quot;.\\nI like to eat &quot;, creatureFood, &quot;.&quot;, sep = &quot;&quot;) cat(message) ## Hello, I am a Quadling. ## My name is George. ## I like to eat cookies. That’s great, but it seems that every time we introduce a new creature we have to type a lot of code. It would be much better if we could find a way to re-use code, rather than repeating it. Functions allow us to re-use code. Let’s define a function to do introductions: intro &lt;- function(name, type, food) { message &lt;- paste(&quot;Hello, I am a &quot;, type, &quot;. \\nMy name is &quot;, name, &quot;.\\nI like to eat &quot;, food, &quot;.&quot;, sep = &#39;&#39;) cat(message) } In the console nothing happens. We only created the function intro(), we haven’t called it yet. Let’s call intro: intro(name = &quot;Frederick&quot;, type = &quot;Winkie&quot;, food = &quot;macaroni&quot;) ## Hello, I am a Winkie. ## My name is Frederick. ## I like to eat macaroni. R allows you to be lazy: you can omit the parameters name, type and food, so long as you indicate what their values should be, in the correct order: intro(&quot;Frederick&quot;, &quot;Winkie&quot;, &quot;macaroni&quot;) ## Hello, I am a Winkie. ## My name is Frederick. ## I like to eat macaroni. 1.2.5 Data and Graphics Anyone can use R, but it was created for statisticians, so it has many features that are helpful in data analysis. Let’s take a quick look at a data set from a contributed R package, the package mosaicData (Pruim, Kaplan, and Horton 2018). First, we’ll attach the package, so R can find all of the goodies it contains: library(mosaicData) Package mosaicData contains a number of interesting datasets that are useful in the teaching of statistics. Let’s look into one of them—Births78—using R’s help() function: help(&quot;Births78&quot;) We learn that Births78 is a data frame containing information on the number of births each day, during the year 1978. (A data frame is one of R’s most important data structures. We’ll learn more about them in Chapter 7.) The frame has 365 rows, one for each day in the year, and four columns. Each column contains the values of a variable recorded for each day: the calendar date of that day; births: the number of children born in the United States on that day; dayofyear: the number of the day within the year 1978 (1 being January 1, 2 being January 2, and so on); wday: the day of week for that day (Sunday, Monday, etc.). We can view the first few row of the data frame using R’s head() function: head(Births78, n = 10) ## date births wday year month day_of_year day_of_month day_of_week ## 1 1978-01-01 7701 Sun 1978 1 1 1 1 ## 2 1978-01-02 7527 Mon 1978 1 2 2 2 ## 3 1978-01-03 8825 Tue 1978 1 3 3 3 ## 4 1978-01-04 8859 Wed 1978 1 4 4 4 ## 5 1978-01-05 9043 Thu 1978 1 5 5 5 ## 6 1978-01-06 9208 Fri 1978 1 6 6 6 ## 7 1978-01-07 8084 Sat 1978 1 7 7 7 ## 8 1978-01-08 7611 Sun 1978 1 8 8 1 ## 9 1978-01-09 9172 Mon 1978 1 9 9 2 ## 10 1978-01-10 9089 Tue 1978 1 10 10 3 We might wonder whether the number of births varies with the time of year. One way to investigate this question is to make a scatterplot, where the days of the year (numbered 1 through 365) are on the horizontal axis and the number of births for each day are on the vertical axis. Figure 1.2 shows such a plot.1 Figure 1.2: A simple scatterplot with R’s ggplot2 graphics system. Clearly the number of births varies seasonally: more babies are born in late summer and early fall, whereas spring births are not as frequent. But there is something mysterious about the plot: Why do there are appear to be two clearly separated groups of days, one with considerably more births than the other? What is going on here? As we learn to program in R, we will gradually acquire the skills needed to answer this and many other intriguing questions. References "],
["idea-debugging.html", "1.3 Debugging", " 1.3 Debugging It’s easy to make mistakes when you program—even when you are very experienced! Incorrect computer code is said to have a bug, and the art of finding bugs and correcting them is called debugging. Consider the following code: scarecrowQuote &lt;- &quot;It is such an uncomfortable feeling to know one is a fool.&quot; paste(&quot;The Scarecrow says: &quot;, scarecrowquote) When we run it we get the following error message in the console: ## Error in paste(&quot;The Scarecrow says: &quot;, scarecrowquote) : ## object &#39;scarecrowquote&#39; not found R’s error messages are often quite mysterious—they are intended to be maximally useful to experienced R programmers—but it’s always a good idea to read them anyway. In this case the message clearly tells us the problem: R cannot find the object scarecrowquote on its search path. This prompt us to look more closely at the name scarecrow, and sooner or later we will realize that we have a misspelling: the variable that was actually defined was scarecrowQuote, with a capital Q. The correct code is: scarecrowQuote &lt;- &quot;It is such an uncomfortable feeling to know one is a fool.&quot; paste(&quot;The Scarecrow says: &quot;, scarecrowQuote) ## [1] &quot;The Scarecrow says: It is such an uncomfortable feeling to know one is a fool.&quot; Always bear in mind that R is case-sensitive! Here’s another buggy bit of code: SermonMountComment &lt;- paste(&quot;Oh, it&#39;s &quot;blessed are the meek.&quot;&quot;, &quot;\\nI&#39;m glad they are getting something:\\n&quot;, &quot;they have a hell of a time.&quot;) cat(SermonMountComment) The idea is to produce: ## Oh, it&#39;s &quot;blessed are the meek. ## I&#39;m glad they are getting something: ## they have a hell of a time. But when we run the code we get the following result instead: &gt; rm(SermonMountComment) &gt; SermonMountComment &lt;- paste(&quot;Oh, it&#39;s &quot;blessed are the meek.&quot;&quot;, Error: unexpected symbol in &quot;SermonMountComment &lt;- paste(&quot;Oh, it&#39;s &quot;blessed&quot; &gt; &quot;\\nI&#39;m glad they are getting something: &quot;, Error: unexpected &#39;,&#39; in &quot; &quot;\\nI&#39;m glad they are getting something: &quot;,&quot; &gt; &quot;they have a hell of a time.&quot;) Error: unexpected &#39;)&#39; in &quot; &quot;they have a hell of a time.&quot;)&quot; &gt; cat(SermonMountComment) Error in cat(SermonMountComment) : object &#39;SermonMountComment&#39; not found This can be a bit more difficult to read. The problems appear to start near the beginning of the construction of the string SermonMountComment. After looking at it a while we focus on the first string argument to the paste() function: &quot;Oh, it's &quot;blessed are the meek.&quot;&quot; We see that this string has quotes within quotes. Now R uses quotes as delimiters for strings: that is, quote-marks indicate where a string begins and where it ends. Hence from R’s point of view, the first string consists of just: &quot;Oh, it's &quot;. But then there is no comma to separate this string from the next string argument that the paste() functions expects. Instead R sees the b in blessed; that’s an unexpected symbol. Things go downhill from there. There are a couple of ways to correct the problem. One approach is to use single quotes inside any string that is delimited with double quotes, thus: SermonMountComment &lt;- paste(&quot;Oh, it&#39;s &#39;blessed are the meek.&#39;&quot;, &quot;\\nI&#39;m glad they are getting something:\\n&quot;, &quot;they have a hell of a time.&quot;) cat(SermonMountComment) ## Oh, it&#39;s &#39;blessed are the meek.&#39; ## I&#39;m glad they are getting something: ## they have a hell of a time. On the other hand if you really want those double-quotes inside the string, you can escape their special meaning as string-delimiter by prepending a backslash (\\) to them, thus: SermonMountComment &lt;- paste(&quot;Oh, it&#39;s \\&quot;blessed are the meek.\\&quot;&quot;, &quot;\\nI&#39;m glad they are getting something:\\n&quot;, &quot;they have a hell of a time.&quot;) cat(SermonMountComment) ## Oh, it&#39;s &quot;blessed are the meek.&quot; ## I&#39;m glad they are getting something: ## they have a hell of a time. There are a number of special characters that are formed by “escaping” the usual meaning of some other character. Some common examples are: \\n: produces a newline instead of n \\t: produces a tab-space instead of t \\&quot;: produces an actual quote-mark, instead of beginning or ending a string. Strings are a tricky topic in any computer programming language: in fact we will devote all of Chapter 11 to them. "],
["idea-glossary.html", "Glossary", " Glossary Computer Program A sequence of instructions that performs a specific task when executed by a computer. String A value in a computer program that constitutes text (as opposed to numbers of some other type of data). Interactive Mode A type of engagement between a human and a computer in which the computer prompts the humand for data and/or commands and may respond with output that the human can read and/or interpret. Read-Evaluate-Print Loop An interactive cycle in which the R-interpreter reads an expression from the console, evaluates it, and prints out the value to the console. Data Structure A particular way of organizing information in an computer program so that it can be used efficiently. Delimiter A character in a programing languages that is used to mark the beginning and/or end of a value. "],
["idea-exercises.html", "Exercises", " Exercises Write a program that modifies the function intro() (see Section 1.2.4) so that the person who introduces him or herself states a favorite sport. For example, the result of the following function call: intro(name = &quot;Bettina&quot;, type = &quot;human&quot;, sport = &quot;lacrosse&quot;) should be: ## Hello, I am a human. ## My name is Bettina. ## My favorite sport is lacrosse. Write a program that modifies the function intro() (see Section 1.2.4) so that the person who introduces him or herself says what planet he or she is from. For example, the result of the following function call: intro(name = &quot;Zarg&quot;, planet = &quot;Jupiter&quot;, food = &quot;rubber bands&quot;) should be: ## Hello, my name is Zarg! ## My home planet is Jupiter. ## I like to eat rubber bands. Write a program to produce the following output to the console: ## * ## ** ## *** ## ** ## * Write a program to produce the following output to the console: ## meow! ## hiss! hiss! ## meow! ## hiss! hiss! hiss! ## meow Suppose we want to cat “Hello, World” to the console, and we enter: cat(Hello, World!) What does R say? What did we do wrong? Suppose we want to cat “Hello, World” to the console, and we enter: cat[&quot;Hello, World!&quot;] What does R say? What did we do wrong? "],
["vectors.html", "Chapter 2 Vectors", " Chapter 2 Vectors Figure 2.1: rep(yarn, times = 4). This Chapter gets you started officially with R. While the theme is vectors, the most important data structure in R, we’ll learn also about variables and variable names, vector types, reserved words, assignment and many of R’s basic operators. "],
["what-is-a-vector.html", "2.1 What is a Vector?", " 2.1 What is a Vector? If you have heard of vectors before in mathematics, you might think of a vector as something that has a magnitude and a direction, and that can be represented by a sequence of numbers. In its notion of a vector, R keeps the idea of a sequence but discards magnitude and direction. The notion of “numbers” isn’t even necessary. For R, a vector is simply a sequence of elements. There are two general sort of vectors: atomic vectors that come in one of six forms called vector types; non-atomic vectors, called lists, whose elements can be any sort of R-object at all. For now we’ll just study atomic vectors. Let’s make a few vectors, as examples. We can make a vector of numbers using the c() function: numVec &lt;- c(23.2, 45, 631, -273, 0, 48.371, 100000, 85, 92, -236, 8546, 98774, 0, 0, 1, 3) numVec ## [1] 23.200 45.000 631.000 -273.000 0.000 48.371 100000.000 85.000 ## [9] 92.000 -236.000 8546.000 98774.000 0.000 0.000 1.000 3.000 You can think of c as standing for “combine.” c() takes its arguments, all of which are separated by commas, and combines them to make a vector. If you closely examine the above output, you’ll notice that R printed out all of the numerical values in the vector to three decimal places, which happened to be the largest number of decimal places we assigned to any of the numbers that made up numVec. You’ll also notice the numbers in brackets at the beginning of the lines. Each number represents the position within the vector occupied by the first element of the vector that is printed on the line. The position of an element in a vector is called its index. Reporting the indices of leading elements helps you locate particular elements in the output. 2.1.1 Types of Atomic Vectors The numbers in numVec are what programmers call double-precision numbers. You can verify this for yourself with the typeof() function: typeof(numVec) ## [1] &quot;double&quot; The typeof() function returns the type of any object in R. As far as vectors are concerned, there are six possible types, of which we will deal with only four: double integer character logical Let’s look at examples of the other types. Here is a vector of type integer: intVec &lt;- c(3L, 17L, -22L, 45L) intVec ## [1] 3 17 -22 45 The L after each number signifies to R that the number should be stored in memory as an integer, rather than in double-precision format. Officially, the type is integer: typeof(intVec) ## [1] &quot;integer&quot; You should know that if you left off one or more of the L’s, then R would create a vector of type double: numVec2 &lt;- c(3, 17, -22, 45) typeof(numVec2) ## [1] &quot;double&quot; We won’t work much with integer-type vectors, but you’ll see them out in the wild. We can also make vectors out of pieces of text called strings: these are called character vectors. As noted in the previous chapter, we use quotes to delimit strings: strVec &lt;- c(&quot;Brains&quot;, &quot;are&quot;, &quot;not&quot;, &quot;the&quot;, &quot;best&quot;, &quot;things&quot;, &quot;in&quot;, &quot;the&quot;, &quot;world&quot;, &quot;93.2&quot;) strVec ## [1] &quot;Brains&quot; &quot;are&quot; &quot;not&quot; &quot;the&quot; &quot;best&quot; &quot;things&quot; &quot;in&quot; &quot;the&quot; &quot;world&quot; &quot;93.2&quot; typeof(strVec) ## [1] &quot;character&quot; Notice that &quot;93.2&quot; makes a string, not a number. The last type of vectors to consider are the logical vectors. Here is an example: logVec &lt;- c(TRUE, FALSE, T, T, F, F, FALSE) logVec ## [1] TRUE FALSE TRUE TRUE FALSE FALSE FALSE In order to represent a logical value you can use: TRUE or T to represent truth; FALSE or F to represent falsity. You can’t represent truth or falsity any other way. If you try anything else—like the following—you get an error: badVec &lt;- c(TRUE, false) ## Error: object &#39;false&#39; not found Note: Although R allows T to be interpreted as TRUE and F as FALSE, it can be dangerous to use them in some circumstances. Best to get into the habit of always using TRUE and FALSE, rather than the permitted abbreviations. 2.1.2 Coercion What would happen if you tried to represent falsity with the string &quot;false&quot;? newVector &lt;- c(TRUE, &quot;false&quot;) newVector ## [1] &quot;TRUE&quot; &quot;false&quot; newVector is not a logical vector. Check it out: typeof(newVector) ## [1] &quot;character&quot; In order to understand what just happened here, you must recall that all of the elements of an atomic vector have to be of the same type. If the c() function is presented with values of different types, then R follows a set of internal rules to coerce some of the values to a new type in such a way that all resulting values are of the same type. You don’t need to know all of the coercion rules, but it’s worth noting that character beats double, which in turn beats integer, which in in turn beats logical. The following examples show this: typeof(c(&quot;one&quot;, 1, 1L, TRUE)) ## [1] &quot;character&quot; typeof(c(1, 1L, TRUE)) ## [1] &quot;double&quot; typeof(c(1L, TRUE)) ## [1] &quot;integer&quot; Automatic coercion can be convenient in some circumstances, but in others it can give unexpected results. It’s best to keep track of what types you are dealing with and to exercise caution when combining values to make new vectors. You can also coerce vectors “manually” with the functions: as.numeric() ; as.integer() ; as.character() ; as.logical() . Here are some examples: numVec &lt;- c(3, 2.5, -7.32, 0) as.character(numVec) ## [1] &quot;3&quot; &quot;2.5&quot; &quot;-7.32&quot; &quot;0&quot; as.integer(numVec) ## [1] 3 2 -7 0 as.logical(numVec) ## [1] TRUE TRUE TRUE FALSE Note that in coercion from numerical to logical, the number 0 becomes FALSE and all non-zero numbers become TRUE. 2.1.3 Combining Vectors You can combine vectors you have already created to make new, bigger ones: numVec1 &lt;- c(5, 3, 10) numVec2 &lt;- c(1, 2, 3, 4, 5, 6) numCombined &lt;- c(numVec1, numVec2) numCombined ## [1] 5 3 10 1 2 3 4 5 6 You can see here that vectors are different from sets: they are allowed to repeat the same value in different indices, as we see in the case of the 3’s above. 2.1.4 NA Values Consider the following vector, which we may think of as recording the heights of people, in inches: heights &lt;- c(72, 70, 69, 58, NA, 45) The NA in the fifth position of the vector is a special value that may be considered to mean “Not Assigned.” It’s R’s way of letting us indicate that a value was not recorded or has gone missing for some reason. 2.1.5 “Everything in R is a Vector” Some folks say that everything in R is a vector. That’s a bit of an exaggeration but it’s remarkably close to the truth. And yet it seems implausible. What about the elements of an atomic vector, for instance? A single element doesn’t look at all like a vector: it’s a value, not a sequence of values. Or so we might think. But really, in R there are no “single values” that can exist by themselves. Consider, for instance, what we think of as the number 17: 17 ## [1] 17 See the [1] in front, in the output above? It indicates that the line begins with the first element of a vector. So 17 doesn’t exist on its own: it exists a vector of type double—a vector of length 1. Even NA is, all along, a vector of length 1 NA ## [1] NA It is of type logical: typeof(NA) ## [1] &quot;logical&quot; Note that even the type of NA evaluates, in R, to a vector: a character vector of length 1 whose only element is the string “logical”! 2.1.6 Named Vectors The elements of a vector can have names, if we like: ages &lt;- c(Bettina = 32, Chris = 64, Ramesh = 101) ages ## Bettina Chris Ramesh ## 32 64 101 Having names doesn’t keep the vector from being a vector of type double: it has to be double because its elements are double. typeof(ages) ## [1] &quot;double&quot; We can names the elements of a vector when we create it with c(), or we can name them later on. One way to do this is with the names() function: names(heights) &lt;- c(&quot;Scarecrow&quot;, &quot;Tinman&quot;, &quot;Lion&quot;, &quot;Dorothy&quot;, &quot;Toto&quot;, &quot;Boq&quot;) heights ## Scarecrow Tinman Lion Dorothy Toto Boq ## 72 70 69 58 NA 45 2.1.7 Special Character Vectors R comes with two handy, predefined character vectors: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; ## [24] &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; ## [24] &quot;X&quot; &quot;Y&quot; &quot;Z&quot; We will make use of them from time to time. 2.1.8 Length of Vectors The length() function tells us how many elements a vector has: length(heights) ## [1] 6 2.1.9 Practice Exercises Consider the following vector: upperLower &lt;- c(LETTERS, letters) What should the length of upperLower be? Check you answer using the length() function. True or False: c(&quot;a&quot;, 2, TRUE) yields a vector of length three consisting of the string &quot;a&quot;, the number 2 and the logical value TRUE. The function as.numeric() tries to coerce its input into numbers. How well can it pick out the “numbers” in strings. Try the following calls. When did as.numeric() find the numbers that was probably intended? as.numeric(&quot;3.214&quot;) as.numeric(&quot;3L&quot;) as.numeric(&quot;fifty&quot;) as.numeric(&quot;10 + 3&quot;) as.numeric(&quot;3.25e-3&quot;) # scientific notation: 3.25 times 10^(-2) as.numeric(&quot;31,245&quot;) 2.1.10 Solutions to Practice Exercises There are 26 letters, so the length of upperlower should be \\(2 \\times 26 = 52\\). Let’s check: length(upperLower) ## [1] 52 False! The resulting vector will be atomic—all of its elements will be the same data type. The non-strings will be coerced to strings, yielding: c(&quot;a&quot;, 2, TRUE) ## [1] &quot;a&quot; &quot;2&quot; &quot;TRUE&quot; as.numeric() isn’t very smart: it picked out the number in &quot;3.214&quot; and 3.25e-3, but in the other cases it returned NA. "],
["constructing-patterned-vectors.html", "2.2 Constructing Patterned Vectors", " 2.2 Constructing Patterned Vectors Quite often we need to make lengthy vectors that follow simple patterns. R has a few functions to assist us in these tasks. 2.2.1 Sequencing Consider the seq() function: seq(from = 5, to = 15, by = 1) ## [1] 5 6 7 8 9 10 11 12 13 14 15 The default value of the parameter by is 1, so we could get the same thing with: seq(from = 5, to = 15) ## [1] 5 6 7 8 9 10 11 12 13 14 15 Further reduction in typing may be achieved as long as we remember the order in which R expects the parameters (from before to, then by if supplied): seq(5, 15) ## [1] 5 6 7 8 9 10 11 12 13 14 15 Some more complex examples: seq(3, 15, 2) ## [1] 3 5 7 9 11 13 15 seq(0, 1, 0.1) ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 R will go up to the to value, but not past it: seq(3, 16, 2) ## [1] 3 5 7 9 11 13 15 Negative steps are fine: seq(5, -4, -1) ## [1] 5 4 3 2 1 0 -1 -2 -3 -4 The colon operator : is a convenient abbreviation for seq: 1:5 # 1 is from, 5 is to ## [1] 1 2 3 4 5 If the from number is greater than the to number the step for the colon operator is -1: 5:1 ## [1] 5 4 3 2 1 2.2.2 Repeating With rep() we may repeat a given vector as many times as we like: rep(3, times = 5) ## [1] 3 3 3 3 3 We can apply rep() to a vector of length greater than 1: vec &lt;- c(7, 3, 4) rep(vec, times = 3) ## [1] 7 3 4 7 3 4 7 3 4 rep() applies perfectly well to character-vectors: rep(&quot;Toto&quot;, 4) ## [1] &quot;Toto&quot; &quot;Toto&quot; &quot;Toto&quot; &quot;Toto&quot; rep() also takes an each parameter that determines how many times each element of the given vector will be repeated before the times parameter is applied. This is best illustrated with an example: vec &lt;- c(7, 3, 4) rep(vec, each = 2, times = 3) ## [1] 7 7 3 3 4 4 7 7 3 3 4 4 7 7 3 3 4 4 If we combine seq() and rep() we can create fairly complex patterns concisely: vec &lt;- seq(5, -3, -2) rep(vec, each = 2, times = 2) ## [1] 5 5 3 3 1 1 -1 -1 -3 -3 5 5 3 3 1 1 -1 -1 -3 -3 In order to create fifty 10’s followed by fifty 30’s followed by fifty 50’s I would write: rep(seq(10, 50, 20), each = 50) 2.2.3 Practice Exercises Use rep() to make the following vector: ## [1] &quot;Kansas&quot; &quot;Kansas&quot; &quot;Kansas&quot; &quot;Kansas&quot; &quot;Kansas&quot; Use rep() to make the following vector: ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE Use seq() to make the following vector: ## [1] 5 8 11 14 17 20 23 26 Use seq() to make all of the multiples of 4, beginning with 8 and going down to -32. Use the colon operator to make all of the whole numbers from 10 to 20. Use the colon operator to make all of the whole numbers from 10 to -30. You have a vector named myVec. Use the colon operator and the length() function to make all of the whole numbers from 1 to the length of myVec. Use rep() and seq() together to make the following vector: ## [1] 2 3 4 5 6 7 8 9 10 2 3 4 5 6 7 8 9 10 2 3 4 5 6 7 8 9 10 Use rep() and seq() together to make the following vector: ## [1] 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 7 7 7 8 8 8 9 9 9 10 10 10 Read the Help for rep() ?rep It tells you that the first argument of rep() is the vector that you want to repeat, and that it’s called x. It goes on to say that times is: “an integer-valued vector giving the (non-negative) number of times to repeat each element if of length length(x), or to repeat the whole vector if of length 1.” Use this information to describe in words what will be the output of: rep(seq(10, 100, by = 10), times = 1:10) 2.2.4 Solutions to Practice Exercises Here’s how: rep(&quot;Kansas&quot;, times = 5) Here’s how: rep(c(TRUE, FALSE), times = 4) Here’s how: seq(5, 26, by = 3) Here’s how: seq(8, -32, by = -4) Here’s how: 10:20 Here’s how: 10:-30 All you need is this: 1:length(myVec) Here’s how: rep(seq(2, 10), times = 3) Here’s how: rep(seq(2, 10), each = 3) You’ll get one 10, two 20s, three 30s, …, all the way up to ten 100s. rep(seq(10, 100, by = 10), times = 1:10) ## [1] 10 20 20 30 30 30 40 40 40 40 50 50 50 50 50 60 60 60 60 60 60 70 70 ## [24] 70 70 70 70 70 80 80 80 80 80 80 80 80 90 90 90 90 90 90 90 90 90 100 ## [47] 100 100 100 100 100 100 100 100 100 "],
["subsetting-vectors.html", "2.3 Subsetting Vectors", " 2.3 Subsetting Vectors Quite often we need to select one or more elements from a vector. The subsetting operator [ allows us to do this. Recall the vector heights: heights ## Scarecrow Tinman Lion Dorothy Toto Boq ## 72 70 69 58 NA 45 If we want the fourth element, we ask for it with the subsetting operator like this: heights[4] ## Dorothy ## 58 If we want two or more elements, then we specify their indices in a vector. Thus, to get the first and fifth elements, we might do this: desired &lt;- c(1,5) heights[desired] ## Scarecrow Toto ## 72 NA We could also ask for them directly: heights[c(1,5)] ## Scarecrow Toto ## 72 NA Negative numbers are significant in subsetting: heights[-2] #select all but second element ## Scarecrow Lion Dorothy Toto Boq ## 72 69 58 NA 45 heights[-c(1,3)] # all but first and third ## Tinman Dorothy Toto Boq ## 70 58 NA 45 If you specify a nonexistent index, you get NA, the reasonable result: heights[7] ## &lt;NA&gt; ## NA Patterned vectors are quite useful for subsetting. If you want the first three elements of heights, you don’t have to type heights[c(1,2,3)]. Instead you can just say: heights[1:3] ## Scarecrow Tinman Lion ## 72 70 69 The following gives the same as heights: heights[1:length(heights)] ## Scarecrow Tinman Lion Dorothy Toto Boq ## 72 70 69 58 NA 45 If you desire to quickly provide names for a vector, subsetting can help: vec &lt;- c(23, 14, 82, 33, 33, 45) names(vec) &lt;- LETTERS[1:length(vec)] vec ## A B C D E F ## 23 14 82 33 33 45 If a vector has names we can refer to its elements using the subsetting operator and those names: heights[&quot;Tinman&quot;] ## Tinman ## 70 heights[c(&quot;Scarecrow&quot;, &quot;Boq&quot;)] ## Scarecrow Boq ## 72 45 Finally, we can use subsetting to modify parts of a vector. For example, Dorothy’s height is reported as: heights[&quot;Dorothy&quot;] ## Dorothy ## 58 If Dorothy grows two inches, then we can modify her height as follows: heights[&quot;Dorothy&quot;] &lt;- 60 We can replace more than one element, of course. Thus: heights[c(&quot;Scarecrow&quot;, &quot;Boq&quot;)] &lt;- c(73, 46) The subset of indices may be as complex as you like: vec &lt;- c(3,4,5,6,7,8) vec[seq(from = 2, to = 6, by = 2)] &lt;- c(100, 200, 300) vec ## [1] 3 100 5 200 7 300 In the above example, seq(2,6,2) identified 2, 4 and 6 as the indices of elements of vec that were to be replaced by the corresponding elements of c(100, 200, 300). We can even use subsetting to rearrange the elements of a vector. Consider the example below: inhabitants &lt;- c(&quot;Oz&quot;, &quot;Toto&quot;, &quot;Boq&quot;, &quot;Glinda&quot;) permuted &lt;- inhabitants[c(3,4,1,2)] permuted ## [1] &quot;Boq&quot; &quot;Glinda&quot; &quot;Oz&quot; &quot;Toto&quot; 2.3.1 Practice Exercises We’ll work with the following vector: practiceVec &lt;- c(4, 3, 7, 10, 5, 3, 8) Select the fifth element of practiceVec. Select the third and sixth elements of practiceVec. Select the first, second, third and fourth elements of practiceVec. How would you select the last element of the vector mysteryVec if you did not know how many elements it had? Select all but the fourth element of practiceVec. Select all but the fourth and sixth elements of practiceVec. Select the even-numbered elements of practiceVec. Replace the third element of practiceVec with the number 5. Replace the even-numbered elements of practiceVec with zeroes. Replace the second, third and fifth elements of practiceVec with 3, 10, and 20 respectively. Reverse the order of the elements of practiceVec. 2.3.2 Solutions to Practice Exercises practiceVec[5] practiceVec[c(3,6)] practiceVec[1:4] mysteryVec[length(mysteryVec)] practiceVec[-4] practiceVec[-c(4,5)] practiceVec[seq(2, length(practiceVec), by = 2)] practiceVec[3] &lt;- 5 Here is one way: zeroes &lt;- rep(0, times = length(seq(2 length(practiceVec)))) practiceVec[seq(2, length(practiceVec), by = 2)] &lt;- zeroes Here’s a quicker way: practiceVec[seq(2, length(practiceVec), by = 2)] &lt;- 0 The latter approach involves “recycling” the zero. We’ll discuss recycling soon. practiceVec[c(2, 3, 5)] &lt;- c(3, 10, 20) practiceVec[length(practiceVec):1] "],
["more-on-logical-vectors.html", "2.4 More on Logical Vectors", " 2.4 More on Logical Vectors Consider the following expression: 13 &lt; 20 ## [1] TRUE We constructed it with the “less-than” operator &lt;. You can think of it as saying that 13 is less than 20, which is a true statement, and sure enough, R evaluates the expression 13 &lt; 20 as TRUE. When you think about it, we’ve seen lots of expressions so far. Here are just a few of them: sqrt(64) heights heights[1:3] 13 &lt; 20 When we type any one of them into the console, it evaluates to a particular value. In the examples above, the value was always a vector. Expressions like 13 &lt; 20 that evaluate to a logical vector are often called Boolean expressions.2 2.4.1 Boolean Operators Let’s look further into Boolean expressions. Define the following two vectors: a &lt;- c(10, 13, 17) b &lt;- c(8, 15, 12) Now let’s evaluate the expression a &lt; b: a &lt; b ## [1] FALSE TRUE FALSE The &lt; operator, when applied to vectors, always works element-wise; that is, it is applied to corresponding elements of the vectors on either side of it. R’s evaluation of a &lt; b involves evaluation of the following three expressions: 10 &lt; 8 (evaluates to FALSE) 13 &lt; 15(evaluates to TRUE) 17 &lt; 12(evaluates to FALSE) The result is a logical vector of length 3. The &lt; operator is an example of a Boolean operator in R. Table 2.4.1 shows the available Boolean operators. Table 2.1: The Boolean Operators Operation What It Means &lt; less than &gt; greater than &lt;= less than or equal to &gt;= greater than or equal to == equal to &amp; and | or &amp;&amp; and (scalar version) || or (scalar version) ! not 2.4.1.1 Inequalities The “numerical-looking operators” (&lt;, &lt;=, &gt;, &gt;=) have their usual meanings when one is working with numerical vectors3 When applied to character vectors they evaluate according to an alphabetical order: a&lt;- c(&quot;Dorothy&quot;, &quot;toto&quot;, &quot;Boq&quot;) b &lt;- c(&quot;tinman&quot;, &quot;Toto&quot;, &quot;2017&quot;) a &lt; b ## [1] TRUE TRUE FALSE The reasons for the evaluation above are as follows: D comes before t in the alphabet; lowercase t comes before uppercase T, according to R; characters for numbers come before letter-characters, according to R. 2.4.1.2 Equality The equality (==) operator indicates whether the expressions being compared evaluate to the same value. Note that it’s made with two equal-signs, not one! It’s all about evaluation to the same value, not strict identity. The following examples will help to clarify this. a &lt;- c(Dorothy = 1,Toto = 2) # a named vector b &lt;- c(Glinda = 1, Tinman = 2) a == b ## Dorothy Toto ## TRUE TRUE (Note that the resulting logical vector inherits the names of a, the vector on the left.). But a and b aren’t identical. We can see this because R has the function identical() to test for identity: identical(a, b) ## [1] FALSE Corresponding elements of a and b have the same values, but the two vectors don’t have the same set of names, so they aren’t considered identical. Here’s another way to see that “evaluating to the same value” is not the same as “identity”: TRUE == 1 ## [1] TRUE When TRUE (itself oftype logical) is being compared with something numerical (type integer or double) it is coerced into the numerical vector 1. (In the same situation FALSE would be coerced to 0.) But clearly TRUE and 1 are not identical: identical(TRUE, 1) ## [1] FALSE 2.4.1.3 And, Or, Not We consider an “and” statement to be true when both of its component statements are true; otherwise it is counted as false. The &amp; Boolean operator accords with our thinking: a &lt;- c(TRUE, TRUE, FALSE, FALSE) b &lt;- c(TRUE, FALSE, TRUE, FALSE) a &amp; b ## [1] TRUE FALSE FALSE FALSE In logic and mathematics, an “or” statement is considered to be true when at least one of its component statements are true. (This is sometimes called the “inclusive” use of the term “or.”) R accords with this line of thinking: a &lt;- c(TRUE, TRUE, FALSE, FALSE) b &lt;- c(TRUE, FALSE, TRUE, FALSE) a | b ## [1] TRUE TRUE TRUE FALSE The &amp;&amp; and || operators follow the “and” and “or” logic respectively, but are applied only to the first elements of the vectors being compared: a &lt;- c(TRUE, TRUE) b &lt;- c(TRUE, TRUE) a &amp;&amp; b ## [1] TRUE a &lt;- c(TRUE, FALSE) b &lt;- c(FALSE, FALSE) a || b ## [1] TRUE These operators will come in handy later on, when we study conditionals. The final Boolean operator is !, which works like “not”: a &lt;- c(TRUE, FALSE) !a ## [1] FALSE TRUE e &lt;- c(2, 5, 6) f &lt;- c(3, 1, 2) e &gt; f ## [1] FALSE TRUE TRUE !(e &gt; f) ## [1] TRUE FALSE FALSE So-called after George Boole, a nineteenth century British logician.↩ A vector is said to be numerical if it is of type integer or double.↩ "],
["vector-recycling.html", "2.5 Vector Recycling ", " 2.5 Vector Recycling Consider the vector vec &lt;- c(2, 6, 1, 7, 3) Look at what happens when we evaluate the expression: vec &gt; 4 ## [1] FALSE TRUE FALSE TRUE FALSE At first blush this doesn’t make any sense: vec has length 5, whereas 4 is a vector of length 1. How can the two of them be compared? They cannot, in fact, be compared. Instead the shorter of the two vectors—the 4—is recycled into the c(4,4,4,4,4) a vector of length five, which may then be compared element-wise with vec. Recycling is a great convenience as it allows us to express an idea clearly and concisely. Recycling is always performed on the shorter of two vectors. Consider the example below: vec2 &lt;- 1:6 vec2 &gt; c(3,1) ## [1] FALSE TRUE FALSE TRUE TRUE TRUE Here, c(3,1) was recycled into c(3,1,3,1,3,1) prior to being compared with vec2. What happens if the length of the longer vector is not a multiple of the shorter one? We should look into this: vec2 &lt;- 1:7 vec2 &gt; c(3, 8) ## longer object length is not a multiple of shorter object length ## [1] FALSE FALSE FALSE FALSE TRUE FALSE TRUE We get a warning, but R tries to do the job for us anyway, recycling the shorter vector to c(3,8,3,8,3,8,3) and then performing the comparison. By the way, if you don’t want to see the warning you can put the expression into the suppressWarnings() function: suppressWarnings(vec2 &gt; c(3, 8)) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE 2.5.1 Practice Exercises We’ll work with the following vectors: person &lt;- c(&quot;Dorothy&quot;, &quot;Scarecrow&quot;, &quot;Tin Man&quot;, &quot;Lion&quot;, &quot;Toto&quot;) age &lt;- c(12, 0.04, 15, 18, 6) likesDogs &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE) Think of the vectors as having corresponding elements. Thus, there is a person named Dorothy who is 12 years old and likes dogs, a person named Tin Man who is 0.04 years old and doesn’t like dogs, etc. Write a Boolean expression that is TRUE when a person is less than 14 years old and FALSE otherwise. Write a Boolean expression that is TRUE when a person is between 10 and 15 years old (not including 10 but not 15) and FALSE otherwise. Write a Boolean expression that is TRUE when a person is more than 12 years old and likes dogs, and FALSE otherwise. Write a Boolean expression that is TRUE when a person is more than 12 years old and does not like dogs, and FALSE otherwise. Write a Boolean expression that is TRUE when a person is more than 12 years old and or likes dogs, and FALSE otherwise. Write a Boolean expression that is TRUE when the person is Dorothy, and FALSE otherwise. Write a Boolean expression that is TRUE when the person is Dorothy or Tin Man, and FALSE otherwise. Write a Boolean expression that is TRUE when the person’s name comes after the letter “M” in the alphabet, and FALSE otherwise. Write a Boolean expression that is FALSE when the person is Dorothy, and TRUE otherwise. 2.5.2 Solutions to Practice Exercises Here’s the code: age &lt; 14 ## [1] TRUE TRUE FALSE FALSE TRUE Here’s the code: age &gt;= 10 &amp; age &lt; 15 ## [1] TRUE FALSE FALSE FALSE FALSE Here’s the code: age &gt; 12 &amp; likesDogs ## [1] FALSE FALSE TRUE FALSE FALSE Here’s the code: age &gt; 12 &amp; !likesDogs ## [1] FALSE FALSE FALSE TRUE FALSE Here’s the code: age &gt; 12 | likesDogs ## [1] TRUE FALSE TRUE TRUE TRUE Here’s the code: person == &quot;Dorothy&quot; ## [1] TRUE FALSE FALSE FALSE FALSE Here’s the code: person == &quot;Dorothy&quot; | person == &quot;Tin Man&quot; ## [1] TRUE FALSE TRUE FALSE FALSE Here’s the code: person &gt; &quot;M&quot; ## [1] FALSE TRUE TRUE FALSE TRUE Here’s the code: person != &quot;Dorothy&quot; ## [1] FALSE TRUE TRUE TRUE TRUE "],
["subsetting-with-logical-vectors.html", "2.6 Subsetting with Logical Vectors", " 2.6 Subsetting with Logical Vectors The subsetting we have seen up to now involves specifying the indices of the elements we would like to select from the original vector. It is also possible to say, for each element, whether or not it is to be included in our selection. This is accomplished by means of logical vectors. Recall our heights vector: heights ## Scarecrow Tinman Lion Dorothy Toto Boq ## 73 70 69 60 NA 46 Let’s say that we want the heights of Scarecrow, Tinman and Dorothy. We can use a logical vector to do this: wanted &lt;- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE) heights[wanted] ## Scarecrow Tinman Dorothy ## 73 70 60 The TRUE’s at indices 1, 2, and 4 in wanted inform R that we want the heights vector at indices 1, 2 and 4. The FALSE’s say: “don’t include this element!” Subsetting can be used powerfully along with logical vectors and Boolean operators. For example, in order to select those persons whose heights exceed a certain amount, we might say something like this: #heights of some people: people &lt;- c(55, 64, 67, 70, 63, 72) tall &lt;- (people &gt;= 70) tall ## [1] FALSE FALSE FALSE TRUE FALSE TRUE people[tall] ## [1] 70 72 As you can see, the tall vector specifies which elements we would like to select from the people vector. We need not define the tall vector along the way. It is quite common to see something like the following: people[people &gt;= 70] ## [1] 70 72 I like to pronounce the above as: people, where people is at least 70 The word “where” in the above phrase corresponds to the subsetting operator. Your subsetting logical vector need not have been constructed with the original vector in mind. Consider the following example: age &lt;- c(23, 21, 22, 25, 63) height &lt;- c(68, 67, 71, 70, 69) age[height &lt; 70] ## [1] 23 21 63 Here the selection is done from the age vector, using a logical vector that was constructed from height—another vector altogether. It concisely expresses the idea: the ages of people whose height is less than 70 There is no limit to the complexity of selection. Consider the following: age &lt;- c(23, 21, 22, 25, 63) height &lt;- c(68, 67, 71, 70, 69) likesToto &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) height[age &lt; 60 &amp; likesToto] ## [1] 68 67 2.6.1 Counting Logical subsetting provides a convenient way to count the elements of a vector that possess a given property. For example, to find out how many elements of people are less than 70 we could say: length(people[people &lt; 70]) ## [1] 4 2.6.2 Cautions about NA You should be aware of the effect of NA-values on subsetting. heights ## Scarecrow Tinman Lion Dorothy Toto Boq ## 73 70 69 60 NA 46 tall &lt;- (heights &gt; 65) tall ## Scarecrow Tinman Lion Dorothy Toto Boq ## TRUE TRUE TRUE FALSE NA FALSE Since Toto’s height was missing, R can’t say whether or not he was more than 65 inches tall. Hence it assigns NA to the Toto-element of the tall vector. When we subset using this vector we get an odd result: heights[tall] ## Scarecrow Tinman Lion &lt;NA&gt; ## 73 70 69 NA Since R doesn’t know whether or not to select Toto, it records its indecision by including an NA in the result. That NA, however, is not the NA for Toto’s height in the vector heights, so it can’t inherit the “Toto” name. Since it has no name, R presents its name as &lt;NA&gt;. If we try to count the number of tall persons, we get a misleading result: length(heights[tall]) ## [1] 4 We would have preferred something like: “Three, with another one undecided.” Counting is one those situations in which we might wish to remove NA values at the start. If the vector is small we could remove them by hand, e.g.: knownHeights &lt;- heights[-5] # remove Toto tall &lt;- (knownHeights &gt; 65) length(knownHeights[tall]) ## [1] 3 For longer vectors the above approach won’t be practical. Instead we may use the is.na() function. is.na(heights) ## Scarecrow Tinman Lion Dorothy Toto Boq ## FALSE FALSE FALSE FALSE TRUE FALSE Then we may select those elements that are not NA: knownHeights &lt;- heights[!is.na(heights)] knownHeights ## Scarecrow Tinman Lion Dorothy Boq ## 73 70 69 60 46 length(knownHeights[knownHeights &gt; 65]) ## [1] 3 2.6.3 Which, Any, All There are several functions on logical vectors that are worth keeping in your back pocket: which() any() all() 2.6.3.1 which() Applied to a logical vector, the which() function returns the indices of the vector that have the value TRUE: boolVec &lt;- c(TRUE,TRUE,FALSE,TRUE) which(boolVec) ## [1] 1 2 4 Thus if we want to know the indices of heights where the heights are at least 65, then we write: which(heights &gt; 65) ## Scarecrow Tinman Lion ## 1 2 3 (Recall that height was a named vector. The logical vector heights &gt; 65 inherited these names and passed them on to the result of whihc().) Note also that Toto’s NA height was ignored by which(). 2.6.3.2 any() Is anyone more than 71 inches tall? any() will tell us: heights ## Scarecrow Tinman Lion Dorothy Toto Boq ## 73 70 69 60 NA 46 any(heights &gt; 71) ## [1] TRUE Yes: the Scarecrow is more than 71 inches tall. We can use any() along with the equality Boolean operator == to determine whether or not a given value appears a a given vector: vec &lt;- c(&quot;Dorothy&quot;, &quot;Tin Man&quot;, &quot;Scarecrow&quot;, &quot;Glinda&quot;) any(vec == &quot;Tin Man&quot;) ## [1] TRUE any(vec == &quot;Wizard&quot;) ## [1] FALSE The above question occurs so frequently that R provides the %in% operator as a short-cut: &quot;Tin Man&quot; %in% vec ## [1] TRUE &quot;Wizard&quot; %in% vec ## [1] FALSE 2.6.3.3 all() Is everyone more than 71 inches tall? all(heights &gt; 71) ## [1] FALSE 2.6.3.4 NA-Caution Is everyone more than 40 inches tall? all(heights &gt; 40) ## [1] NA Everyone with a known height is taller than 40 inches, but because Toto’s height is NA R can’t say whether all the heights are bigger than 40. 2.6.4 Practice Exercises Consider the following vectors: person &lt;- c(&quot;Abe&quot;, &quot;Bettina&quot;, &quot;Candace&quot;, &quot;Devadatta&quot;, &quot;Esmeralda&quot;) numberKids &lt;- c(2, 1, 0, 2, 3) yearsEducation &lt;- c(12, 16, 13, 14, 18) hasPets &lt;- c(FALSE, FALSE, TRUE, TRUE, FALSE, TRUE) Think of these vectors as providing information about siz people. Write a command that produces the names of people who have more than 1 child. Write a command that produces the numbers of children of people who have a pet. Write a command that produces the years of education who have at least 13 years of education. Write a command that produces the names of people who have more than one child and fewer than 15 years od education. Write a command that produces the names of people who don’t have pets. Write a command that produces the number of people who have pets. Write a command that produces the number of people who don’t have pets. Write a command that says whether or not there is someone who has more 15 years of education and at least one child, but doesn’t have any pets. 2.6.5 Solutions to the Practice Exercises person[numberKids &gt; 1] numberKids[hasPets] yearsEducation[yearsEducation &gt;= 13] person[numberKids &gt; 1 &amp; yearsEducation &lt; 15] person[!hasPets] Here is one way. We’ll learn an easier way in the next section. length(person[hasPets]) ## [1] 3 Here is one way. We’ll learn an easier way in the next section. length(person[!hasPets]) ## [1] 3 any(yearsEducation &gt; 15 &amp; numberKids &gt;= 1 &amp; !hasPets) "],
["basic-arithmetical-operations-on-vectors.html", "2.7 Basic Arithmetical Operations on Vectors", " 2.7 Basic Arithmetical Operations on Vectors R provides a number of arithmetical operations on pairs of numerical vectors. Table 2.2 shows the basic operators. Table 2.2: Basic arithmetical operations on vectors. Operation What It Means x + y addition x - y subtraction x * y multiplication x / y division x^y exponentiation (raise x to the power y) x %/% y integer division (quotient after dividing x by y) x %% y x mod y (remainder after dividing x by y) The operators are applied element-wise to vectors: x &lt;- c(10, 15, 20) y &lt;- c(3, 4, 5) x + y ## [1] 13 19 25 x - y ## [1] 7 11 15 x * y ## [1] 30 60 100 x / y ## [1] 3.333333 3.750000 4.000000 x^y ## [1] 1000 50625 3200000 As an illustration, the final result is: \\[10^3, 15^4, 20^5.\\] The “mod” operator %% can be quite useful. Here is an example: even numbers have a remainder of 0 after division by 2, whereas odd numbers have a remainder of 1. Hence we may use %% to quickly locate the even numbers in a vector, as follows: vec &lt;- c(2, 7, 9, 12, 15, 24) vec[vec %% 2 == 0] ## [1] 2 12 24 Recycling applies in vector arithmetic (as in most of R): vec &lt;- c(2, 7, 9, 12, 15, 24) 2 * vec # the 2 will be recycled ## [1] 4 14 18 24 30 48 vec + 100 # the 100 will be recycled ## [1] 102 107 109 112 115 124 vec^3 # the 3 will be recycled ## [1] 8 343 729 1728 3375 13824 2.7.1 More Math Functions You have already met sqrt(). Here are a few more useful math functions involving vectors. 2.7.1.1 Rounding You can use the round() function to round off numbers to any desired number of decimal places. roots &lt;- sqrt(1:5) roots # Too much information! ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 round(roots, digits = 3) # nicer ## [1] 1.000 1.414 1.732 2.000 2.236 2.7.1.2 Ceiling and Floor The ceiling() function returns the least integer that is greater than or equal to the given number: vec &lt;- c(-2.9, -1.1, 0.2, 1.35, 3, 4.01) ceiling(vec) ## [1] -2 -1 1 2 3 5 The floor() function returns the greatest integer that is less than or equal to the given number: floor(vec) ## [1] -3 -2 0 1 3 4 2.7.1.3 Vectorization All of the above operations follow the “vector-in, vector-out” principle—often referred to by R users as vectorization—to which R often adheres. Not only does vectorization permit us to express ideas concisely and in human-readable fashion, but the computations themselves tend to be performed very quickly. 2.7.1.4 Summing and the Mean There are some functions on vectors that return only a vector of length 1. Among examples we have met so far are: length() any() all() Another very important function that returns a vector of length 1 is sum() : vecs &lt;- 1:100 sum(vecs) ## [1] 5050 In statistics we are often interested in the mean of a list of numbers. The mean is defined as: \\[\\frac{\\text{sum of the numbers}}{\\text{how many numbers there are}}\\] You can find the mean of a numerical vector as follows: vec &lt;- c(-3, 4, 17, 23, 51) meanVec &lt;- sum(vec)/length(vec) The way we compute the mean in R looks a great deal like its mathematical definition. You might be interested to know that there is a function in R dedicated to finding the mean. Unsurprisingly, it is called mean() : mean(vec) ## [1] 18.4 2.7.1.5 Maximum and Minimum The max() function delivers the maximum value of the elements of a numerical vector: max(c(3, 7, 2)) ## [1] 7 The min() function delivers the minimum value of a numerical vector: min(c(3, 7, 2)) ## [1] 2 You can enter more than one vector into min() or max(): the function will combine the vectors and then do its job: a &lt;- c(5, 6, 10) b &lt;- c(2, 3, 12, 15, 1) # the max of both is 15 max(a, b) ## [1] 15 Both functions yield NA when one of the elements is NA: max(3, 7, -2, NA) ## [1] NA Like sum() and mean(), they respond to the na.rm parameter: max(3, 7, -2, NA, na.rm =TRUE) ## [1] 7 The pmax() function compares corresponding elements of each input-vector and produces a vector of the maximum values: a &lt;- c(3, 7, 10) b &lt;- c(5, 2, 12) pmax(a, b) ## [1] 5 7 12 There is a pmin() function that computes pair-wise minima as well. 2.7.2 NA and NaN Considerations What happens when you are doing mathematics on a vector, one of whose values is NA? A vectorizing function will simply pass it along: vec &lt;- c(1, 2, 3, 4, NA) sqrt(vec) ## [1] 1.000000 1.414214 1.732051 2.000000 NA On the other hand a function like sum() needs to know all of the values. If one of them is NA, it will report their sum as NA. sum(vec) ## [1] NA The same is true for the mean: mean(vec) ## [1] NA If we want the sum or the mean of the known values, we could first remove the NA values as demonstrated in previous sections. We could also make use of the na.rm parameter that these functions provide: sum(vec, na.rm = TRUE) ## [1] 10 mean(vec , na.rm = TRUE) ## [1] 2.5 The results of some arithmetical operations sometimes are not defined. (Examples: you can’t divide by 0; you can’t take the square root of a negative number.) R reports the results of such operations as NaN—“not a number.” R also issues a warning: sqrt(c(-4, 2, 4)) ## Warning in sqrt(c(-4, 2, 4)): NaNs produced ## [1] NaN 1.414214 2.000000 Keep in mind, though, that the result is a perfectly good vector as far as R is concerned. After the warning R will permit you to use it in further computations: vec&lt;- sqrt(c(-4, 2, 4)) ## Warning in sqrt(c(-4, 2, 4)): NaNs produced vec + 3 ## [1] NaN 4.414214 5.000000 2.7.3 Practice Exercises Consider the following vectors: Write a command that produces the squares of the first 10 whole numbers. Write a command that produces the square roots of: the numbers from 1 to 100 that are one more than a multiple of 3. Write a command that raises 2 to the second power, 3 to third power, 4 to the fourth power, … up to 100 to the hundredth power. Using the sum() function and the vector hasPets from the practice exercises of the previous section, write a command that says how many people have pets. Using the sum() function and the vector hasPets from the practice exercises of the previous section, write a command that says how many people do not have pets. Using the vectors from the practice exercises of the previous question, find the name of the person who has the most education. 2.7.4 Solutions to the Practice Exercises (1:10)^2 Here are a couple of ways: sqrt(seq(1, 100, by = 3)) sqrt((1:100)[1:100 %% 3 == 1]) (2:100)^(2:100) When given a logical vector, the sum() function converts TRUE to 1 and FALSE to 0, and then adds. Accordingly, you can count how many people have pets like this: sum(hasPets) ## [1] 3 Do this: sum(!hasPets) ## [1] 3 Try this: person[yearsEducation == max(yearsEducation)] ## [1] &quot;Esmeralda&quot; "],
["further-notes-on-syntax.html", "2.8 Further Notes on Syntax", " 2.8 Further Notes on Syntax In the process of learning about R, you have been unconsciously imbibing some of its syntax. The syntax of a computer-programming is the complete set of rules that determine what combinations of symbols are considered to make a well-formed program in the language—something that R can interpret and attempt to execute. 2.8.1 Syntax Errors vs. Run-time Errors vs. Semantic Errors For the most part you will learn the syntax informally. By now, for example, you have probably realized that when you call a function you have to supply a closing parenthesis to match the open parenthesis. Thus the following is completely fine: sum(1:5) ## [1] 15 On the other hand if you were to type sum(1:5 alone on a single line in a R script, R Studio’s code-checker would show a red warning-circle at that line. Hovering over the circle you would see the message: unmatched opening bracket '(' If you were to attempt to run the command sum(1:5 from the script you would get the following error message: ## Error: Incomplete expression: sum(1:5 Such an error is called a syntax error.4 The R Studio IDE can detect most—but not all—syntax errors. Syntax errors in computer programming are similar to grammatical errors in ordinary language, such as: “Mice is scary.” (Number of the subject does not match the number of the verb.) “Mice are.” (Incomplete expression.) A run-time error is an error that occurs when the syntax is correct but R is unable to finish the execution of your code for some other reason. The following code, for example, is perfectly fine from a syntactical point of view: sum(&quot;hello&quot;) When run, however, it produces an error: ## Error in sum(&quot;hello&quot;) : invalid &#39;type&#39; (character) of argument Here is another example: sum(emeraldCity) Unless for some reason you have defined the variable emeraldCity, an attempt to run the above command will produce the following run-time error: ## Error: object &#39;emeraldCity&#39; not found Many run-time errors in computer programming resemble errors in ordinary language where the sentence is grammatically correct by does not mean anything, as in: “Beelbubs are juicy.” (What’s a “beelbub”?) There is a third type of error, known in the world of programming as a semantic error. The term “semantics” refers to the meaning of things. Computer code is said to contain a semantic error when it is syntactically correct and can be executed, but does not deliver the results one knows to expect. As an example, suppose you have defined, at some point, two variables: emeraldCity &lt;- 15 emeraldcity &lt;- 4 Suppose now that—wanting R to compute \\(15^2\\)—you run the following code: emeraldcity^2 ## [1] 16 You don’t get the results you wanted, because you accidentally asked for the square of the wrong number. Semantic errors are usually the most difficult errors for programmers to detect and repair. 2.8.2 The Assignment Operator We have been using the assignment operator &lt;- to assign values to variables. You should be aware that there is another assignment operator that works the other way around: 4 -&gt; emeraldCity emeraldCity ## [1] 4 Most people don’t use it. A popular alternative to &lt;- as an assignment operator is the equals sign =: emeraldCity = 5 emeraldCity ## [1] 5 I myself prefer to stay away from it, as it can be confused with other uses of =, such as the setting of values to parameters in functions: rep(&quot;Dorothy&quot;, times = 3) ## [1] &quot;Dorothy&quot; &quot;Dorothy&quot; &quot;Dorothy&quot; When you have to assign the same value to several values, R allows you to abbreviate a bit. Consider the following code: a &lt;- b &lt;- c &lt;- 5 The above code has the same effect as: a &lt;- 5 b &lt;- 5 c &lt;- 5 2.8.3 Multiple Expressions R allows you to write more than one expression on a single line, as long as you separate the expressions with semicolons: a &lt;- b &lt;- c &lt;- 5 a; b; c; 2+2; sum(1:5) ## [1] 5 ## [1] 5 ## [1] 5 ## [1] 4 ## [1] 15 2.8.4 Variable Names and Reserved Words Using the assignment operator we have created quite a few variables by now, and we appear to have named them whatever we want. In fact there are very few limitation on the name of a variable. According to R’s own documentation:5 “A syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number.” This leaves a lot of room for creativity. All of the following names are possible for variables: yellowBrickRoad yellow_brick_road yellow.brick.road yell23 y2e3L45Lo3....rOAD .yellow The following, though, are not valid: .2yellow (cannot start with dot and then number) _yellow (cannot start with _) 5scones (cannot start with a number) Most programmers try to devise names for variables that are descriptive in the sense that they suggest to a reader of the code the role that is played within it by the variable. In addition they try to stick to a consistent system for variable names that divide naturally into meaningful words. One popular convention is known as CamelCase. In this convention each new word-like part of the variable names begins with a capital letter. (The initial letter, though, is often not capitalized.) Examples would be: emeraldCity isEven Another popular convention—sometimes called “snake-case”—is to use lowercase and to separate words with underscores: emerald_city is_even An older convention—one that was popular among some of the original developers of R—was to separate words with dots: emerald.city is.even This last convention is no longer recommended, as in programming languages other than R the dot is associated syntactically with the calling of a “method” on an “object.”6 There is one further restriction on variable-names that we have not yet mentioned: you are not allowed to use any of R’s reserved words. These are: if, else, while, repeat, function, for, in, next, break,TRUE, FALSE, NULL, inf, NaN, NA, NA_integer, NA_real, NA_complex, NA_character You need not memorize the above list: You’ll gradually learn most of it, and words you don’t learn are words that you are unlikely to ever choose as a variable-name on your own. Besides, reserved words show in in blue in the R Studio editor, and if you manage to use one anyway then R will stop you outright with a clear error message: break &lt;- 5 ## Error in break &lt;- 5 : invalid (NULL) left side of assignment Notice also that although TRUE and FALSE are reserved words, their accepted abbreviations T and F are not. This can lead to problems in code, if someone chooses to bind T or F to some value. For example, suppose that have two lines of code like this: T &lt;- 0 F &lt;- 1 Later on, suppose you create what you think is a logical vector: myVector &lt;- c(T, F, F, T) But it’s not logical: typeof(myVector) ## [1] &quot;double&quot; That’s because T ad F have been bound to numerical values. If you coerce myLogical to a logical vector, you get the exact opposite of what you would have expected: as.logical(myVector) ## [1] FALSE TRUE TRUE FALSE The moral of the story is: To be safe, never use T for TRUE or F for FALSE. One final remark: variables together with reserved words constitute the part of the R language called identifiers. 2.8.5 Practice Exercises Suppose that you begin a new R session and that you run to following code: person &lt;- c(&quot;Abe&quot;, &quot;Bettina&quot;, &quot;Candace&quot;, &quot;Devadatta&quot;, &quot;Esmeralda&quot;) numberKids &lt;- c(2, 1, 0, 2, 3) yearsEducation &lt;- c(12, 16, 13, 14, 18) hasPets &lt;- c(FALSE, FALSE, TRUE, TRUE, FALSE, TRUE) What sort of error (syntax, runtime or semantic) is produced by the this next piece of code, which is intended to produce the names of the people with more than 15 years of education? Why? person(yearsEducation &gt; 15] What sort of error (syntax, runtime or semantic) is produced by the this next piece of code, which is intended to produce the names of the people who don’t have pets? Why? person(!haspets] What sort of error (syntax, runtime or semantic) is produced by the this next piece of code, which is intended to find out how many people have pets? Why? length(hasPets) Is ThreeLittlePigs a valid name for a variable? If not, why not? Is 3LittlePigs a valid name for a variable? If not, why not? Is LittlePigs3 a valid name for a variable? If not, why not? Is Little-Pigs-3 a valid name for a variable? If not, why not? Is Little_Pigs_3 a valid name for a variable? If not, why not? Is three.little.pigs a valid name for a variable? If not, why not? 2.8.6 Solutions to the Practice Exercises This will result in a syntax error. You need brackets to select and you’ve got a parenthesis n the left. The correct syntax would be: person[yearsEducation &gt; 15] This will result in a runtime error. The variable haspets is not defined, so R will issue a “can’t find” erro when the code is executed. Probably you meant: person[!hasPets] This will result in a semantic error. You’ll get 5 (the number of elements in the vector hasPets) What you wnat can be accomplished by either one of the following: sum(!hasPets) # nice and snappy! length(hasPets[!hasPets]) # kinda awkward Yes. No! Variables can’t start with a number. Yes. No! Hyphens aren’t allowed in variables. Yes. Yes. R is a bit more forgiving if you type sum(1:5 directly into the console and press Enter. Instead of throwing an error, R shows a + prompt, hoping for further input that would correctly complete the command. If you are ever in the situation where you do not know how to complete the command, you may simply press the Escape key (upper left-hand corner of your keyboard): R will then abort the command and return to a regular prompt.↩ See help(make.names).↩ We will look briefly at R’s object-oriented capabilities in Chapter 15.↩ "],
["glossary.html", "Glossary", " Glossary Vector Type Any one of the six basic forms the elements in an atomic vector can take. The four types we will encounter the most are: double, integer, character and logical. Coercion The process of changing a vector from one type to another. Sometimes the process takes place automatically, as a convenience to the programmer. Sub-setting The operation of selecting one or more elements from a vector. Recycling An automatic process by which R, when given two vectors, repeats elements of the shorter vector until it is as long as the longer vector. Recycling enables the two resulting vectors to be combined element-wise in operations. Vectorization R’s ability to operate on each element of a vector, producing a new vector of the same length. Vectorized operations can be expressed concisely and performed very quickly. Reserved Words Identifiers that are set aside by R for specific programming purposes. They cannot be used as names of variables. Syntax The complete set of rules for a computer language that determine what combinations of symbols are considered to make a well-formed program in the language. Syntax Error A sequence of symbols that contains a violation of one of the rules of syntax. R is unable to interpret and attempt to execute code that contains a syntax error. Run-time Error An error that occurs when the computer language’s interpreter attempts to execute code but is unable to do so. A typical cause of a run-time error is the situation when the code calls for the evaluation of a name that has not been bound to an object. Semantic Error An error in code that is syntactically correct and that can be executed by the computer but which produces unexpected results. "],
["exercises.html", "Exercises", " Exercises Determine the type of each of the following vectors: c(3.2, 2L, 4.7, TRUE) c(as.integer(3.2), 2L, 5L, TRUE) c(as.integer(3.2), 2L, &quot;5L&quot;, TRUE) Using a combination of c(), rep() and seq() and other operations, find concise one-line programs to produce each of the following vectors: all numbers from 4 to 307 that are one more than a multiple of 3; the numbers 0.01, 0.02, 0.03, …, 0.98, 0.99. twelve 2’s, followed by twelve 4’s followed by twelve 6’s, …, followed by twelve 10’s, finishing with twelve 12’s. one 1, followed by two 2’s, followed by three 3’s, …, followed by nine 9’s, finishing with ten 10’s. Using a combination of c(), rep() and seq() and other operations, find concise one-line programs to produce each of the following vectors: the numbers 15, 20, 25, …, 145, 150. the numbers 1.1, 1.2, 1.3, …, 9.8, 9.9, 10.0. ten A’s followed by ten B’s, …, followed by ten Y’s and finishing with ten Z’s. (Hint: the special vector LETTERS will be useful.) one a, followed by two b’s, followed by three c’s, …, followed by twenty-five y’s, finishing with twenty-six z’s. (Hint: the special vector letters will be useful.) The following three vectors gives the names, heights and ages of five people, and also say whether or not each person likes Toto: person &lt;- c(&quot;Akash&quot;, &quot;Bee&quot;, &quot;Celia&quot;, &quot;Devadatta&quot;, &quot;Enid&quot;) age &lt;- c(23, 21, 22, 25, 63) height &lt;- c(68, 67, 71, 70, 69) likesToto &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) Use sub-setting with logical vectors to produce vectors of: the names of all people over the age of 22; the names of all people younger than 24 who are also more than 67 inches tall; the names of all people who either don’t like Toto or who are over the age of 30; the number of people who are over the age of 22. Consider the four vectors defined in the previous problem. Use sub-setting with logical vectors to produce vectors of: the names of all people who are less than 70 inches tall; the names of all people who are between 20 and 30 years of age (not including 20 or 30); the names of all people who either like Toto or who are under the age of 50; the number of people who are more than 69 inches tall. Logical vectors are not numerical vectors, so it would seem that you should not be able to sum their elements. But: sum(likesToto) results in the number 3! What is happening here is that R coerces the logical vector likesToto into a numerical vector of 1’s and 0’s—1 for TRUE, 0 for FALSE—and then sums the resulting vector. Notice that this gives us the number of people who like Toto. With this idea in mind, use sum() along with logical vectors to find: the number of people younger than 24 who are also more than 67 inches tall; the number of people who either don’t like Toto or who are over the age of 30. Read the previous problem, and then use sum() along with logical vectors to find: the number of people between 65 and 70 inches tall (including 65 and 70); the number of people who either don’t like Toto or who are under the age of 25. "],
["functions.html", "Chapter 3 Functions", " Chapter 3 Functions Figure 3.1: The General Problem, by xkcd. The xkcd cartoon alludes to a common aspiration of programmers: to solve a frequently-occurring problem in general so that we don’t have to keep on devising solutions specific for each case. In R and in most other programming languages, functions are one of the important tools for solving problems in a general manner. In this Chapter we take a close look at how functions work in R. Along the way we’ll learn about environments and scoping, receiving input from the user, and a few more built-in R-functions. "],
["motivation-for-functions.html", "3.1 Motivation for Functions", " 3.1 Motivation for Functions Suppose you have the job of printing out the word “Kansas” to the console four times, each time on a new line. The code for this is easy enough: cat(&quot;Kansas\\n&quot;) ## Kansas cat(&quot;Kansas\\n&quot;) ## Kansas cat(&quot;Kansas\\n&quot;) ## Kansas cat(&quot;Kansas\\n&quot;) ## Kansas Now suppose that you have the job of printing out any given word to the console four times. You could of course, simply copy and paste the above code to a new place in your R script and then change “Kansas” to whatever the desired word is. But that’s an awful lot of work. You could cut down on the work a bit if you use a variable: word &lt;- &quot;Kansas&quot; cat(word, &quot;\\n&quot;, sep = &quot;&quot;) cat(word, &quot;\\n&quot;, sep = &quot;&quot;) cat(word, &quot;\\n&quot;, sep = &quot;&quot;) cat(word, &quot;\\n&quot;, sep = &quot;&quot;) The advantage of this approach is that, after you copy and paste you only have to make one change, i.e.: substitute the desired word in place of “Kansas” in the assignment to the variable word. If you were writing a program that involved many four-line print-outs of various words, then you could carry on this way quite a while, producing many similar five-line snippets of printing-code throughout your program. But suppose that it occurs to you one day: maybe you don’t really need five lines of code. What if cat() supports “vector in, vector out”? If so then we could take advantage of vectorization to obviate the need to repeated calls to `cat(). We could try: fourWords &lt;- rep(&quot;Kansas&quot;, 4) cat(fourWords, &quot;\\n&quot;) ## Kansas Kansas Kansas Kansas That just repeats “Kansas” four times, with the default space between in each one—then newline is appended. So we need a newline along with each instance of Kansas. So instead we try: fourWords &lt;- rep(&quot;Kansas\\n&quot;, 4) cat(fourWords) ## Kansas ## Kansas ## Kansas ## Kansas Not quite what we wanted: cat() inserts the default space at the end of each instance of Kansas\\n, resulting in the indentation of lines, 2, 3 and 4. No problem—let’s just set the separation to the empty string &quot;&quot;: fourWords &lt;- rep(&quot;Kansas\\n&quot;, 4) cat(fourWords, sep = &quot;&quot;) ## Kansas ## Kansas ## Kansas ## Kansas Success at last! If you wanted to implement this new idea throughout your program, you would have to search through the program for the many five-line snippets you created previously, replacing each one of them with the appropriate version of your clever one-liner. Not only is this a lot of work, it’s also quite error-prone: you could miss or more of the snippets along the way, or on some occasion fail to modify the word within the one-liner to have the value you need at that point. Accordingly programmers try, as much as possible, to solve problems in a general way and to implement that general solution in one place in their program. Then they call upon that solution in the many different locations where the solution might be required. Functions are one way in which programmers accomplish this. The following is a function that will print any given word four times, once on each line: catFourTimes &lt;- function(word) { wordWithNewline &lt;- paste(word, &quot;\\n&quot;, sep = &quot;&quot;) cat(rep(wordWithNewline, 4), sep = &quot;&quot;) } Let’s see the function in use: catFourTimes(&quot;Kansas&quot;) ## Kansas ## Kansas ## Kansas ## Kansas It works like a charm! What’s more, once we get to thinking in terms of general solutions, we realize that we might just as well have our function print not only any given word, but print it any given number of times. So instead of catFourTimes() we might actually use the following: manyCat &lt;- function(word, n) { wordWithNewline &lt;- paste(word, &quot;\\n&quot;, sep = &quot;&quot;) lines &lt;- rep(wordWithNewline, times = n) cat(lines, sep = &quot;&quot;) } Does it work? Let’s see: manyCat(&quot;Kansas&quot;, 5) ## Kansas ## Kansas ## Kansas ## Kansas ## Kansas Yes indeed! Let’s consider the advantages of writing functions: Functions allow us to re-use code, rather than repeating the code throughout our program. The more generally the functions solves the problem, the varied are the situations in which the function may be re-used. If we have to change our our approach to the problem—because our original solution was flawed or if there is a need to add new features to our solution, or for any other reason—then we only have to implement the necessary change in the definition of our function, rather than in the many places in the program where the function is actually used. There is a well-known principle in computer programming called DRY, which is an acronym for “Don’t Repeat Yourself.” Computer code is said to be DRY when general solutions are defined in one place but are usable in many places, and when information needed in many places is defined authoritatively in one place. As a rule, DRY code is easy to develop, debug, read and maintain. The more you get into the habit of expressing solutions to problems in terms of functions, the “drier” your code will be. "],
["function-syntax.html", "3.2 Function Syntax", " 3.2 Function Syntax function is the reserved word in R that permits us to define functions. The general form of a function definition is as follows: functionName &lt;- function(parameter, parameter, ...) { Body of the Function ... } functionName is the variable that will refer to the function you define. Like any other identifier, it can contain letters, numbers, the dot and the underscore character, but is not permitted to begin with the dot followed by a number. After the function reserved word we see a pair of matching parentheses. They contain the parameters of the function, which will be passed into the function as variables referred to by the parameter names. The body of the function consists of one or more expressions that do the work of the function. Note that the body is enclosed with curly braces. This is only necessary, though, if the body consists of more than one expression. If the body had only one expression then that expression could appear without the braces, like this: add3 &lt;- function(x) x+3 add3(x = 5) ## [1] 8 add3(-7) ## [1] -4 In the add3() function above, x was a parameter. When the function is called the parameter is assigned a particular value called an argument. We see that add3() was called twice, once with an argument of 3 and again with an argument of -7. If the parameter is explicitly mentioned in the function call, then an equal-sign = separates the parameter and the argument. Note also that the parameter and = may be omitted if it is clear what parameter the argument will be matched to. In the case of add3 there is only one parameter x, so R knows that any value provided within the parentheses is to be assigned to x. R also knows to refer to the order of parameters within the function’s definition to determine which arguments go with which parameters. Thus, the following calls do the same thing: manyCat(word = &quot;Hello&quot;, n = 4) manyCat(word = &quot;Hello&quot;, 4) manyCat(&quot;Hello&quot;, n = 4) manyCat(&quot;Hello&quot;, 4) manyCat(n = 4, word = &quot;Hello&quot;) On the other hand, the following would produce an error: manyCat(4, &quot;Hello&quot;) ## NAs introduced by coercion ## Error in rep(wordWithNewline, times = n) : ## invalid &#39;times&#39; argument If you don’t label your arguments with the parameters they are to match to, then you must at least write them in the order in which the parameters appear in the definition of the function. In the definition of functions and in all calls to functions, commas must separate arguments. Thus the following would produce an error: manyCat(&quot;Hello&quot; 4) ## Error: unexpected numeric constant in &quot;manyCat(&quot;Hello&quot; 4&quot; If R cannot match all your arguments to a parameter it will throw an error; manyCat(&quot;Hello&quot;, 4, 7) ## Error in manyCat(&quot;Hello&quot;, 4, 7) : unused argument (7) You will have noticed by now that parentheses are essential when using a function. What would happen if we typed just the function’s name itself? Give it a try: manyCat ## function(word, n) { ## wordWithNewline &lt;- paste(word, &quot;\\n&quot;, sep = &quot;&quot;) ## lines &lt;- rep(wordWithNewline, times = n) ## cat(lines, sep = &quot;&quot;) ## } What’s printed to the screen is the code that defines the function. The function itself is not called. 3.2.1 Practice Exercises Consider the following function: addThree &lt;- function(n) { n +3 } It adds three to any number you give it. Try it out: addThree(n = 7) ## [1] 10 What, if anything, is wrong with the following code? addThree(7) What, if anything, is wrong with the following code? addThree(n = 7, x = 5) I’d like to add 3 to the number 15. What, if anything, is wrong with the following code? addThree[15] 3.2.2 Solutions to the Practice Exercises Nothing is wrong. You’ll get a result of 10. You don’t have to use the parameter name n when you call the function: R will figure out that you mean n to be 7. There will be an error, because when the function was defined there was no parameter x. You can only give a function arguments for parameters that were included in its definition. addThree is a function. The way you call it is to use parentheses around the arguments, like this: addThree(15). When you use brackets R will assume that you are trying to pick the third element out of a vector named addThree. When it can’t find such a vector, R will throw an error notifying you of that fact. "],
["what-a-function-returns.html", "3.3 What a Function Returns", " 3.3 What a Function Returns In this section we learn about return-values of functions. 3.3.1 The Final Expression Evaluated Let’s write a small function to raise a number to a power:7 pow &lt;- function(x,y) { x^y } Check to see that it works: pow(2,3) ## [1] 8 All seems well. If we like we can assign the result of pow() to some variable, for use later on: a &lt;- pow(2,4) cat(&quot;I have&quot;, a, &quot;cats.&quot;) ## I have 16 cats. In computer programming parlance, pow(x, y) is said to return the numerical value x^y: pow(2,3) returns 8, pow(2,4) returns 16, and so on. In R, what a function returns is: the value of the final expression that it evaluates. You can see this principle at work in the following example: f &lt;- function(x) { 2*x + 3 45 &quot;hello&quot; x^2 } f(4) ## [1] 16 We put in 4 as the argument for the parameter x, but: we did not get back 11 (\\(2 \\times 4 +3\\)), nor did we get back 45, nor did we get back the string “hello”. When f() was called, R evaluated all of the expressions in its body, but returned only the value of the final expression it evaluated: \\(4^2 = 16\\). 3.3.2 The return() Function R does have a special function to force a function to cease evaluation at a specific point. Its name, unsurprisingly, is return(). Here is an example: g &lt;- function(x) { val &lt;- 3*x +7 return(val) &quot;Hello!&quot; } g(1) ## [1] 10 We get \\(3*1+7 = 10\\), but we don’t get “Hello!”. After returning the 10, the function stopped evaluating expressions: hence it never even bothered to evaluate “Hello”, much less to display it in the console.8 It follows that it does not matter whether or not you wrap the final expression of a function in return(). The following two functions do exactly the same thing: f1 &lt;- function(x) x^2 f2 &lt;- function(x) return(x^2) Some people—especially those who are familiar with other programming languages where return statements are required—like to wrap the final expression in return(), simply as a matter of clarity. 3.3.3 Writing a “Talky” Function Suppose that you would like your function to raise a number to a power, returning the answer to the user, but you also want it to print out a message to the console. You might try writing your function like this: talkySquare &lt;- function(x) { result &lt;- x^2 result cat(&quot;The square of &quot;, x, &quot; is: &quot;, result, &quot;.\\n&quot;, sep = &quot;&quot;) } We try it out: talkySquare(4) ## The square of 4 is: 16. All seems well. But what if we want to save the result in a variable, so that we could perhaps add a number to it later? Something like this, perhaps: a &lt;- talkySquare(4) ## The square of 4 is: 16. a + 4 ## numeric(0) The results don’t really make sense. What happened, of course is that R dutifully returned the value of the final expression in the function’s body—the result of the cat() call, not the value of the variable result. If we want both the print-out and the square to be returned, the we have to write our functions like this: talkySquare &lt;- function(x) { result &lt;- x^2 cat(&quot;The square of &quot;, x, &quot; is: &quot;, result, &quot;.\\n&quot;, sep = &quot;&quot;) result } This works out as expected: a &lt;- talkySquare(4) ## The square of 4 is: 16. a + 4 ## [1] 20 Well, maybe it doesn’t work exactly as we would like. It would nice if the function would talk to us only when we ask for the results in the console, not when we are simply assigning the results to a variable for later use. In Chapter 4 we will learn how to make our talky function keep quiet when we prefer silence. 3.3.4 The print() Function Consider the following function: grumpySquare &lt;- function(x) { &quot;OK, OK, I&#39;m getting to it ... &quot; x^2 } We know by now not to expect to see the grumpy message: grumpySquare(4) ## [1] 16 If we want to see the message, we could wrap it in cat(). Another possibility is to use the print() function: grumpySquare &lt;- function(x) { print(&quot;OK, OK, I&#39;m getting to it ... &quot;) x^2 } grumpySquare(4) ## [1] &quot;OK, OK, I&#39;m getting to it ... &quot; ## [1] 16 When R executes a call to print() it is forced to print something out to the console, even if it is in the midst of evaluating expressions in a function. The print-statement is not involved in what the function returns—that’s all up to the final expression, the x^2—but it does cause a result outside of the function itself. Any external result produced by a function (other than what the function returns) is called a side-effect of the function. cat() and print() are examples of functions that, when called inside of some other function, produce side-effects. You should know that in R you have been calling the print() function quite a bit, without even knowing it. Consider the following line of code: 2+2 ## [1] 4 R evaluates the expression 2+2, arriving at the value 4. But what makes the 4 appear on our console? Behind the scenes, R actually evaluated the expression print(2+2) That’s what got the 4 into the console! The fact is that whenever you make R evaluate an expression at “top level” (i.e., when you type the epxression into the Console) then R will call print() to put the value of the expression into the Console so you can see it. At this point we don’t use print() explicitly very much—we just rely on R to call it for us when we are evaluating expressions at the console. Later on we will find that it has other uses.9 3.3.5 Practice Exercises What, if anything, does the following function return? f &lt;- function(n) { cat(&quot;We have &quot;, n, &quot; dogs.\\n&quot;, sep = &quot;&quot;) } What, if anything, does the following function return? g &lt;- function(n) { n + 3 &quot;Hello&quot; } What, if anything, does the following function return? h &lt;- function(n) { &quot;Hello&quot; n +3 } 3.3.6 Solutions to the Practice Exercises Like any function, f() returns the value of the last expression that it evaluates. This time the final (and only) expression is the call to cat(). But what does cat() return? It turns out that cat() always returns NULL. You can see this in a couple of ways. One way is to store the result of a call to f() in a variable, and then print the variable: result &lt;- f(4) ## We have 4 dogs. result ## NULL result got the value returned by the call f(4). result turned out to be 4. Hence the call f(4) must have returned NULL. Another way to see this is to rewrie the function so as to force the final expression to return its result visibly to the console. This is done by placing parentheses arund the expression, like this: f &lt;- function(n) { (cat(&quot;We have &quot;, n, &quot; dogs.\\n&quot;, sep = &quot;&quot;)) } Now let’s call the functon: f(4) ## We have 4 dogs. ## NULL Yep, there’s NULL, visible in the Console! Well, let’s give it a try an see: result &lt;- g(4) result ## [1] &quot;Hello&quot; Sure enough, g() returns the value of the last expression that it evaluates. In this case, it’s the expression &quot;Hello&quot;. Like all functions, h() returns the value of the final expression that ti evaluates. Hence it will return three more than the value it was given for n. I know, I know—R already has the exponentiation operator. We just need an example to work with, here.↩ You might wonder why anyone would write a function that contains expressions after a call to return(). We’ll learn why in Chapter 4.↩ R is one of very few major programming languages that engage in behind-the-scenes calls to a print function. In many other languages you have to call its print-function explicitly if you want the value of an expression to be displayed.↩ "],
["more-about-arguments.html", "3.4 More About Arguments", " 3.4 More About Arguments 3.4.1 Default Arguments Sometime around the year 1400CE, the South Indian mathematician Madhava discovered the following infinite-series formula for \\(\\pi\\), the ratio of the circumference to the diameter of a circle: \\[\\pi = \\frac{4}{1} - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} +\\frac{4}{9} - \\cdots\\] The numerator of each fraction is always 4. The denominators are the odd numbers 1, 3, 5, and so on. The fractions alternate between positive and negative. The idea is that the further you go out in the series, the closer the sum of the fractions will be to \\(\\pi\\). No matter how close you want to get to \\(\\pi\\), you can get that close by adding up sufficiently many of the fractions. In mathematics courses we learn to write the sum like this: \\[\\pi = \\sum_{k=1}^{k=\\infty} (-1)^{k+1}\\frac{4}{2k-1}.\\] Here’s how the mathematical notation works: The \\(\\Sigma\\) sign stands for “sum”: it means that we plan to add up a lot of terms. The expression \\((-1)^k\\frac{4}{2k-1}\\) after the sum-sign stands for all of the terms that will be added up to make the infinite series. Underneath the sum-sign, \\(k=1\\) says that in the expression after the sum sign we will start by letting \\(k\\) be 1. If we let \\(k=1\\), then the expression becomes \\[(-1)^2\\frac{4}{2 \\cdot 1 -1} = \\frac{4}{1} = 4,\\] the first term in the series. If we let \\(k=2\\), then the expression becomes \\[(-1)^3\\frac{4}{2 \\cdot 2 -1} = -\\frac{4}{3}\\] the second term in the series. If we let \\(k=3\\), then the expression becomes \\[(-1)^4\\frac{4}{2 \\cdot 3 -1} = \\frac{4}{5}\\] the third term in the series. The \\(k = \\infty\\) above the sum-sign says that we are to keep on going like this, increasing \\(k\\) by 1 every time, without stopping. In this way we get the entire infinite series. What Madhava discovered was that if you do stop after some large number of terms, then the sum of the terms you have constructed will be close to \\(\\pi\\). The more terms you add up before stopping, the closer to \\(\\pi\\) you will get. Let’s write a function to compute the sum of the first \\(n\\) terms of the series, where \\(n\\) can be any value we choose. # function to approximate pi with Madhava&#39;s series # (sum the first n terms of the series) madhavaPI &lt;- function(n) { # make a vector of all of the k&#39;s we need: k &lt;- 1:n # make a vector of the first n terms of the sum: terms &lt;- (-1)^(k+1)*4/(2*k-1) # return the sum of the terms: sum(terms) } R’s vectorization capabilities make it easy to write the code; in fact, the code is essentially a copy of the sum-formula. Note also the presence of comments in the code above. Anything that appears on a line after the pound-sign # will be ignored by R. We therefore use the #-sign to insert ordinary-language comments into our code in order to explain to others (and to ourselves when we look at the code much later) what we are doing and why we are doing it. Let’s try it out by adding the first million terms of the series: madhavaPI(1000000) ## [1] 3.141592 How close is this to \\(\\pi\\)? R has a built-in constant pi that will tell us: pi ## [1] 3.141593 Madhava’s approximation was pretty close, although we did have to add up quite a few terms! The madhavaPI() function has a parameter n that stands for the number of terms we want to add up. If we don’t provide a value for n, then there will be an error: madhavaPI() ## Error in madhavaPI() : argument &quot;n&quot; is missing, with no default There is a way, though, to allow a user to avoid providing a value for n. We simply provide a default value for it, like this: madhavaPI &lt;- function(n = 1000000) { k &lt;- 1:n terms &lt;- (-1)^(k+1)*4/(2*k-1) sum(terms) } Now we can call the function without having to specify an argument for the parameter n: madhavaPI() ## [1] 3.141592 The function used the default value of 1000000, so it summed the first million terms. On the other hand, if the user provides his or her own value for n then the function will override the default: madhavaPI(100) # only the first hundred terms, please! ## [1] 3.131593 If you are writing a function for which some of the parameters will often be assigned particular values, it would be a kindness to your users to write in these common values as defaults. 3.4.2 Argument-Matching Sometimes you will see functions in R that provide what appears to be a vector of default values. You’ll see this in the following example, which concerns a function that uses a named vector to report the favorite color of each of the major groups of inhabitants of the Land of Oz. inhabitants &lt;- c(&quot;Munchkin&quot;, &quot;Winkie&quot;, &quot;Quadling&quot;, &quot;Gillikin&quot;) favColor &lt;- c(&quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;purple&quot;) names(favColor) &lt;- inhabitants favColorReport &lt;- function(inhabitant = inhabitants) { x &lt;- match.arg(inhabitant) cat(favColor[x],&quot;\\n&quot;) } Here are a couple of sample calls: favColorReport(&quot;Winkie&quot;) ## yellow favColorReport(&quot;Quadling&quot;) ## red It might get tiresome to type out the full name of each group of inhabitants. What would happen if we got a bit lazy? favColorReport(&quot;Win&quot;) ## yellow favColorReport(&quot;Wi&quot;) ## yellow favColorReport(&quot;W&quot;) ## yellow favColorReport(&quot;Qua&quot;) ## red favColorReport(&quot;Gil&quot;) ## purple The key to this behavior is two-fold: The vector inhabitants was set as the “default value” of the parameter inhabitant. We called the match.arg() function, which found the element of inhabitants that matched what the user actually submitted for the parameter inhabitant. This element was then assigned to x, and we used x to report the desired color. Sometimes when you look at R-help you’ll see the default value for a parameter set as a vector—usually a character-vector, as in our example. Most likely what is going on is that somewhere inside the function R will attempt to match the argument you provide with one of the elements of that “default” vector. When a function is written in this way, the possible parameters can have quite long names but the user doesn’t have to type them in all the way, as long as the user types enough characters to pick out uniquely an element of the default vector. The matching is done by exact match of initial characters. For example, it won’t do for me to enter: favColorReport(&quot;w&quot;) # wants Winkies, but using lower-case w ## Error in match.arg(inhabitant) : &#39;arg&#39; should be one of ## “Munchkin”, “Winkie”, “Quadling”, “Gillikin” Note that the default vector isn’t really a default value for the parameter. Its first element does, however, serve as the default value: favColorReport() # defaults to &quot;Munchkin&quot; ## blue 3.4.3 Practice Exercises Write a function called addSix() that adds six to any number that is is given. The function should have a single parameter named x, and the default value of x should be 5. Tin Man wants to write a function called addTenAndSquare() that takes any given number, adds ten to it and then squares the result. For example, given 5 the function will return \\((5 + 10)^2 = 225\\). He decides that input value shall be called n and that the default value of n shall be 4. Here is Tin Man’s code: addTenAndSquare &lt;- function(n) { n &lt;- 4 (n + 10)^2 } Has Tin Man accomplished what he set out to do? Why or hy not? 3.4.4 Solutions to the Practice Exercises Here’s the function: addSix &lt;- function(x = 5) { x + 6 } Let’s test it: addSix() ## [1] 11 addSix(x = 10) ## [1] 16 Tin Man’s function does not work correctly. Consider the following calls: addTenAndSquare(2) # should give (2 + 10)^ 2 = 144 ## [1] 196 addTenAndSquare(5) # should give (5 + 10)^ 2 = 225 ## [1] 196 The function only returns \\((4 + 10)^2\\),no matter what it is given! The problem is that n is set to 4 within the body of the function. The correct way to define the function would be: addTenAndSquare &lt;- function(n = 4) { (n + 10)^2 } This works correctly: addTenAndSquare() ## [1] 196 addTenAndSquare(2) ## [1] 144 "],
["environments-and-scope.html", "3.5 Environments and Scope", " 3.5 Environments and Scope 3.5.1 Environments and Searching In R an environment is a particular kind of data structure that helps the computer connect names to a value. An environment can be thought of as a bag of names—names for vectors, functions, and all sorts of objects—along with a way (provided automatically by the computer) of getting from each name to the value that it represents. The process that the computer follows in order to connect a name to a value is called scoping. In R, as in many other computer languages, environments are what makes scoping possible. In other words, environments are how R figures out what the names in any piece of code mean. R has a considerable number of environments—and environments can be created and destroyed throughout the course of an R session—but at any moment only one of them is active. The active environment is the first environment that R will examine when it needs to look up a name in an expression. The most familiar environment is the Global Environment—the one that is active when you are using R from the console. The names in the Global Environment, along with descriptions of the objects to which they refer, are shown in the Environment panel in the R Studio IDE. Alternatively, you see the names in the active environment by using the ls() function: ls() Even better is ls.str(), which will give the name of each object along with a summary of what sort of object it is. ls.str() You can remove all of the names from your Global Environment by pressing the Broom icon in the IDE, or by using the rm()function: rm(list = ls()) As we mentioned previously, the Global Environment is only one of many environments that exist in R. The search() function will show you a number of other environments: search() ## [1] &quot;.GlobalEnv&quot; &quot;package:ggplot2&quot; &quot;package:mosaicData&quot; &quot;tools:rstudio&quot; ## [5] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [9] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; search() returns a character vector of names of environments. The first element is the Global Environment itself. The second element is an environment that is associated with last package that R loaded, the third is an environment associated with the next-to-last package, and so on. Each item on the list is considered to be the parent of the environment that came before it. Thus, the Global Environment has a parent environment, a grandparent environment, and so on. The complete sequence of environments is called the search path. Just as the Global Environment has names for objects, so also the packages have names available for use. When you write code that contains a name, R will search for that name: first in your Global Environment, then in its parent environment—the environment of the last package loaded—and so on until it reaches the final package on the list: package base. If it can’t find the name anywhere, then it will throw an error, telling you that the object “cannot be found.” Let’s try this with a few examples. First, define a (hopefully) new variable: quadlingColor &lt;- &quot;red&quot; Then use it in some code: cat(quadlingColor, &quot;, white and blue\\n&quot;, sep =&quot;&quot;) ## red, white and blue R was able to complete your request because: it found the name `quadlingColor on its search path; it found the name cat on its search path (and found that it referred to the cat() function) You can tell where R found these things: find(&quot;quadlingColor&quot;) ## [1] &quot;.GlobalEnv&quot; find(&quot;cat&quot;) ## [1] &quot;package:base&quot; R found quadlingColor in the first place it looked, whereas it had to go all the way up to package base to find an object with the name cat that looked like it was the name of a function. What happens if the same name gets used in two different environments? Let’s investigate. First get a print of cat(): cat ## function (..., file = &quot;&quot;, sep = &quot; &quot;, fill = FALSE, labels = NULL, ## append = FALSE) ## { ## if (is.character(file)) ## if (file == &quot;&quot;) ## file &lt;- stdout() ## else if (substring(file, 1L, 1L) == &quot;|&quot;) { ## file &lt;- pipe(substring(file, 2L), &quot;w&quot;) ## on.exit(close(file)) ## } ## else { ## file &lt;- file(file, ifelse(append, &quot;a&quot;, &quot;w&quot;)) ## on.exit(close(file)) ## } ## .Internal(cat(list(...), file, sep, fill, labels, append)) ## } ## &lt;bytecode: 0x7febe7cc2488&gt; ## &lt;environment: namespace:base&gt; I got the definition of the cat() function, all the way up in package base. Now try: rep(cat, times = 3) ## Error in rep(cat, times = 3) : ## attempt to replicate an object of type &#39;closure&#39; I got an error! That’s because the only reference R could find for cat was to the function cat() in package base, and since a function isn’t a vector you can’t repeat it.10 Next, define a variable named cat: cat &lt;- &quot;Pippin&quot; At this point, we the identifier cat appears in at least two environments: in the Global Environment, where is refers to the string “Pippin”; in the environment associated with package base, where is refers to the cat()-function. We can verify the above assertions with find(): find(&quot;cat&quot;) ## [1] &quot;.GlobalEnv&quot; &quot;package:base&quot; Now try: rep(cat, times = 3) ## [1] &quot;Pippin&quot; &quot;Pippin&quot; &quot;Pippin&quot; This time it worked! The reason is that R found a character-vector named cat in the Global Environment. Now try: cat(cat, &quot;is a cat\\n&quot;) ## Pippin is a cat Wait a minute: why did this work? Doesn’t the Global Environment come before package base in the search path? Yes it does, but since the first occurrence of cat was followed by an open parenthesis R know to expect that it referred to a function. Hence it kept looking along the search path for a function with the name cat, eventually finding our familiar cat() function in base. Well then, consider happens if we do this: cat &lt;- function(...) { &quot;Meow!&quot; } We have defined a function cat() that returns “Meow!” no matter what it is given as input.11 Now try again: cat(cat, &quot;is a cat\\n&quot;) ## [1] &quot;Meow!&quot; Since the cat() we defined is a function in the Global Environment—which comes before base in the search path—R uses our cat() instead of the base’s cat(). R programmers say that the base version of cat has been masked. If I want to keep my cat() and still use the base version ofcat() as well, I can do that. In order to be sure of getting a particular package’s version of a function, put the name of the package and then two semicolons before the function-name, like this: base::cat(&quot;This is the good ol&#39; cat() we have been missing!&quot;) ## This is the good ol&#39; cat() we have been missing! But we don’t like our cat() so very much: let’s remove it: rm(cat) The vector cat is removed as well by the previous command. 3.5.2 A Note on Parameters vs. Arguments It’s important to keep in mind the distinction between a parameter of a function on the one hand and, on the other hand the argument that gets supplied to that parameter. When you are just starting out in R programming, this distinction can be difficult to remember, especially when the parameter and the argument have the same name. Now that we understand environments, though, we can get a grip on this tricky situation. Let’s proceed by way of an example. First of all, clear out your Global Environment: rm(list = ls()) Next make a simple function that adds three to any given number. Our function will take one parameter n (the number to which 3 is to be added), and the default value of n shall be 4. addThree &lt;- function(n = 4) { n + 3 } Next, bind the name n to the value 2: n &lt;- 2 You should now have two items in your Global Environment. Confirm this: ls.str() ## addThree : function (n = 4) ## n : num 2 Now call the function as follows: addThree(n = 5) ## [1] 8 Let’s recall how this works: R sees that you want to assign the value 5 to the parameter n. R executes the code in the body of the function. All is well. Now call the function as follows: addThree() ## [1] 7 Let’s recall how this works: R sees that you did not assign anything to the parameter n. “That’s OK”, says R. “I’ll use the default value of 4 for n.” R executes the code in the body of the function. All is well. Next, call the function as follows: addThree(n = n) ## [1] 5 Let’s think about how this works: R sees that you want to assign something to the parameter n. Apparently it is the value of a name n in some environment. “Fine”, says R. “I’ll look up the value of this n thingie, if ever I have to use it in a computation.” R executes the one line of code in the body of the function. “Well, I’ll be darned,” says R, “I do need the value of this n thingie after all. I’ll look it up.” R looks for n, finding it in the Global Environment. Apparently it’s bound to 2. R computes \\(2+3\\) and returns \\(5\\). All is well. Now call the function as follows: addThree(n) ## [1] 5 Again let’s consider how this works: R sees the n. Since the function has only one parameter, R figures that you mean to assign the value of n (in some environment) to its parameter n. Everything now proceeds just as before, with 5 being the number returned. Now let’s remove n from the Global Environment: rm(n) Now call the function again, in the following way: addThree(n = n) Error in addThree(n = n) : object &#39;n&#39; not found Can you see why we got an error? This time when R goes looking for n, it can’t find it: n is no longer in the Global Environment, nor is it anywhere else along the search path. Accordingly R throws the error. The call addThree(n) will elicit the same error message, for the same reason. The moral of the story is that parameters really, really are NOT the same thing as arguments, even when a parameter and an argument happen to be called by the same name. 3.5.3 Function Environments Let’s summarize what we have learned so far: An environment is a collection of names associated with objects. The Global Environment is the environment that is active when we are working from the console. When R needs to look up a name, it consults a search path. When we are in the Global Environment the search path starts there, and continues to: the last package loaded (the parent environment), the package before that (the “grandparent environment”), and so on … … up to package base. the first object of the right type having the given name that is found along the search path is the object to which R will associate the name. Just as the Global Environment is a child of the last package loaded, so the Global Environment can have children of its own. In fact a child-environment is created whenever we define a function in the Global Environment and then run it. Consider the following code: a &lt;- 10 b &lt;- 4 f &lt;- function(x, y) { a &lt;- 5 print(ls()) cat(&quot;a is &quot;, a, &quot;\\n&quot;, &quot;b is &quot;, b, &quot;\\n&quot;, &quot;x is &quot;, x, &quot;\\n&quot;, &quot;y is &quot;, y, &quot;\\n&quot;, sep = &quot;&quot;) } Note that a and b are now in the Global Environment, where the value of a is 10 and the value of b is 5. We have defined the function f(); pretty soon we will call it. The moment we do so, we will no longer be working directly from the console: instead R will hand control over to the function that it can execute the code in its body. This means that the Global Environment will no longer be the active environment. Instead the active environment will be one that is created at the moment when f is called. Accordingly, it is called the run-time environment (also known as the evaluation environment) of f. Let’s go ahead and call f(): f(x = 2, y = 3) ## [1] &quot;a&quot; &quot;x&quot; &quot;y&quot; ## a is 5 ## b is 4 ## x is 2 ## y is 3 In the body of the function ls() prints out all of the names in the active environment—which at the moment is the run-time environment of f(). This environment contains a with a value of 5—the a with a value of 10 is masked from it—along with the x and y that were passed into the function as arguments. The a variable having the value 5 that was created within the body of the function is said to be local to the function. Thus we can say that the run-time environment of a function consists of the variables that are local to the function and the arguments that were passed into it. Observe that b is not a name in the function’s run-time environment: instead it is in the Global Environment. Nevertheless R can “find” b from within the function because the R considers the Global Environment—the environment in which f() was defined—to be the parent of the run-time environment12, and so the Global Environment is the second place R will look when searching for an object named b. Computer scientists say that b is within the scope of the function. What happens to the run-time environment when f() finishes executing code? R simply destroys it. It’s as if the a, x and y came to life “inside of” f() but died as soon as f() stopped working. The next time f() is called, a new run-time environment will be created to enable the code in the body of f() to do its work. One consequence of the ephemeral nature of run-time environments is that they are not accessible from parent environments. Thus if the active environment is the Global Environment and you run across a reference to a, you will never “find” the a “inside of” f() or “inside of” any other function, for that matter. R looks only in the active environment and in ancestor-environments, never in child-environments, and besides the run-time environment no longer exists after a function has been called. Let’s make sure of this with an example. a &lt;- 5 f &lt;- function() { a &lt;- 10 print(ls.str()) # print out the active environment } f() ## a : num 10 Did calling f() change the value of a in the Global Environment? Let’s see: a ## [1] 5 Nope, a is still 10. This is a very good thing. It would be very confusing if assignment to a variable within a function were to “change the values” of variables—happening to have the same name—that were declared outside of the function’s environment. 3.5.4 Practice Exercises Starting from a new R session and an empty Global Environment, I run the following code: m &lt;- 5 f &lt;- function(n) { m &lt;- 10 a &lt;- m + 5 n^2 } What two items are now in my Global Environment? I then run the following code: g &lt;- f(10) What items are now in my Global Environment? What is the value of g? What is the value of m? When f() was called, a runtime environment was created for it. By the time it got down to the line n^2, what items were in that environment, and what were their values? 3.5.5 Solutions to the Practice Exercises There are now two items in the Global Environment: m: its value is 5 f, the fuunction I defined. Now there are three items in the Global Environment: m: its value is still 5. (The m in the runtime environment is not in the “scope” of the Global Environment.) f, the fuunction I defined is still there. I also have g: its value is \\(10^2 = 100\\). The items in the runtime environment were: the parameter n, with a value of 10; m, with a value of 10; a, with a value of 15. In R, almost all functions are called “closures.”↩ The ellipses, which we will discuss further in Chapter 9, allow the function to be passed any arguments at all—or even none.↩ For any function that is created in R, the enclosing environment of the function is set to be the environment that was active when the function was defined. This feature is known as lexical scoping. Many other languages use dynamic scoping, meaning that the enclosing environment is the environment that is active when the function is called. At this stage in your work with R, when you almost always create functions while working the Global Environment, it can be a bit difficult to become aware of situations when the distinction between lexical and dynamic scoping makes a practical difference. However, the difference is there and it constantly affects your work with R, especially when you use a function from an R package (see Section 3.6 for more on packages). Since the environment associated with a package is the enclosing environment for any R-function defined in that package, functions from packages behave in a standard, expected way, no matter what environment—Global or otherwise—they are called in. For a practical application of lexical scoping that is not related to packages, consult Chapter 6 of (Grolemund (2014)).↩ "],
["note-on-packages.html", "3.6 A Note on Packages", " 3.6 A Note on Packages We have seen that packages make up most of the search path when the active directory is the Global Environment. We have also mentioned a couple of packages explicitly—mosaicData and ggplot2 back in Section 1.2.5 for example. But what exactly is a package? A package is a bundle of R-code (usually functions) and data that is organized according to well-defined conventions and documented so that users can learn how to use the code and data. When someone bundles code into a package it becomes easy to share it with others and and to re-use it for one task after another. 3.6.1 Installed Packages When you click on the Packages tab in the lower right-hand pane in R Studio, you can see a list of all the packages that are installed on the machine. You can get the same information by running the command: installed.packages()[, c(&quot;Package&quot;, &quot;Version&quot;)] In fact R is really nothing but a collection of packages. Many of the R-functions you have been learning about come from the package base. This is one of a number of packages that are automatically attached to the search path when an R session begins. Other packages have to be attached by you if you want immediate access to all of the functions and data that they contain. In order to attach a package, you can click the little box next to its name in the Package tab in R-Studio, or you can attach it from the console with the command: library(&lt;name of package here&gt;) When you don’t want a package any more, you can detach it from the search path by un-clicking the little box, or by running this command: detach(&quot;package:&lt;name of package here&gt;&quot;, unload=TRUE) The package will still be installed, ready to be attached whenever you like. 3.6.2 Learning About a Package You can learn about a Package by clicking on its name, or by using the command: help(&lt;name of package&gt;) From the display that shows in the Help pane you can navigate to learn about each of the functions and data sets that come with the package. 3.6.3 Installing Packages You can also install additional packages on the computer. This can be done by clicking the Install button in R Studio and typing in the package name, or with the command: install.packages(&quot;&lt;name of package here&gt;&quot;) The package will be downloaded from the Comprehensive R Archive Network (CRAN) and installed in in your Home directory. As long as we are working on the R Studio server, it’s a good idea to refrain from installing packages yourself, unless they are packages that we don’t use in class and that you simply want to explore on your own. That’s because when you install your own packages on the Server they go into a special directory in your Home folder and become part of your “User Library”. Packages that are installed by a system administrator for general use are in the “System Library.” If a package is in your User Library and in the System Library, when you ask to attach it you will get the version that it is your User Library. Now packages are updated from time to time, so it may happen that the version you have in your User Library will be different from the one in the System Library. If that is the case then your package might not work the same way for you as it does for the instructor and for other students: that can be confusing. Eventually, though, you will install R and R Studio on your own computer, and then you will have to install many packages on your own. Not all packages come from CRAN: many useful packages exist on other repositories, including the very popular code repository known as GitHub. Special functions exist to install R-packages from GitHub. For example, you may eventually wish to install the package tigerData, which resides in a GitHub repository belonging to your instructor. In order to install it, you would use the install_github() function from the devtools package (Pruim, Kaplan, and Horton 2018), like this: devtools::install_github(repo = &quot;homerhanumat/tigerData&quot;) There are a couple of things worth noting about the command above: The argument to repo has two parts: the word before the “/” is the username of the individual who owns the repository; the word after the “/” is the name of the repository itself. For R-packages on GitHub, the name of the repository is the same as the name of the package. The double-colon :: is used to access a function from a package, without having to attach the entire package. Thus devtools::install_github() refers to the function install_github() in package devtools. Similarly, if you want to access, say, just the Births78 data set from the mosaicData package then you could refer to it as mosaicData::Births78. References "],
["more-to-learn.html", "3.7 More to Learn", " 3.7 More to Learn By now we have have: learned about vectors, an important data structure in R; met quite a few R functions that help us manipulate vectors and print things to the console; learned how to write functions so that we can re-use solutions to problems. But still it seems that—unless we can find a clever way to exploit vectorization—R isn’t doing anything very impressive, really. In order to unlock the true powers of R (or any programming language, for that matter) we have to acquire more control over what expressions R will evaluate, how many times it will evaluate them, and under what conditions it will do so. This is the domain of flow control, the subject of our next chapter. "],
["glossary-1.html", "Glossary", " Glossary Don’t Repeat Yourself (DRY) A principle of computer programming that holds that general solutions should be set forth in one place and usable in many places, and that information needed in many places should be defined authoritatively in one place. Parameters of a Function The parameters of a function (also called the formal arguments of the function) are the names that will be used in the body of the function to refer to the actual arguments supplied to the function when it is called. Argument An argument for a function is a value that is assigned to one of the parameters of the function. (Sometimes arguments are called an actual arguments in order to distinguish then from parameters that are often called formal arguments.) “It’s useful to distinguish between the formal arguments and the actual arguments of a function. The formal arguments are a property of the function, whereas the actual or calling arguments can vary each time you call the function.” —H. Wickham, Advanced R Programming Body of a Function The body of a function is the code that is executed when the function is called. In R, when the body consists of more than one expression then it appears inside of curly braces. Side-Effect Any result produced outside of the run-time environment of a function, other than the value that the function returns. Default Value A value for a parameter of a function that is provided when the function is defined. This value will become the value assigned to the parameter when the function is called, unless the user explicitly assigns some other value as the argument. Environment An object stored in the computer’s memory that keeps track of name-value pairs. Active Environment The environment that R will consult first in order to find the value of any name in an expression. Global Environment The environment that is active when one is using R from the console. Parent Environment The second environment (after the active environment) that R will search when it needs to look up a name. Run-time Environment (also called the “Evaluation Environment”) A special environment that is created when a fuction is called and ceases to exist when the function finishes executing. It contains the values that are local to the function and the arguments of the function as well. Scoping The process by which the computer looks up the object associated with a name in an expression. Search Path The sequence of environments that the computer will consult in order to find an object associated with a name in an expression. The sequence begins with the active environment, followed by its parent environment, followed by the parent of the parent environment, and so on. Package A bundle of R-code and data that is organized according to well-defined conventions and documented so that users can learn how to use the code and data. "],
["exercises-1.html", "Exercises", " Exercises Write a function called pattern() that when given a character will print out the character in a pattern like this: * ** *** ** * That is: a row of one, then a row of two, then a row of three, then a row of two, and finally a row of one. The function should take one parameter called char. The default value of this parameter should be *. Typical examples of use should be as follows: pattern() ## * ## ** ## *** ## ** ## * pattern(char = &quot;x&quot;) ## x ## xx ## xxx ## xx ## x Write a function called charSquare() that when given two characters will use them to make a square like this: **** a a a a **** That is: a row of four of one of the characters, then two rows that consist of the other character followed by two spaces followed by that other character, and finally a row of four of the first character. The function should take two parameters called end and middle. The default value of end should should be * and the default value of middle should be x. Typical examples of use should be as follows: charSquare() ## **** ## x x ## x x ## **** charSquare(end = &quot;z&quot;, middle = &quot;%&quot;) ## zzzz ## % % ## % % ## zzzz Write a function called reverse() that, given any vector, returns a vector with the elements in reverse order. It should take one parameter called vec. The default value of vec should be the vector c(&quot;Bob&quot;, &quot;Marley&quot;). Typical examples of use should be: reverse() ## [1] &quot;Marley&quot; &quot;Bob&quot; reverse(c(3,2,7,6)) ## [1] 6 7 2 3 Hint: Recall how you can use sub-setting to reverse: firstFiveLetters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) firstFiveLetters[5:1] ## [1] &quot;e&quot; &quot;d&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot; You just need to figure out how to reverse vectors of arbitrary length. Note: It so happens that R already provides a function rev() that reverses the elements of a given vector, but your assignment is to write your own function that reverses vectors. In particular, you may not use rev() in the body of your reverse() function! A vector is said to be a palindrome if reversing its elements yields the same vector. Thus, c(3,1,3) is a palindrome, but c(3,1,4) is not a palindrome. Write a function called isPalindrome() that, when given any vector, will return TRUE if the vector is a palindrome and FALSE if it is not a palindrome. The function should take a single parameter called vec, with no default value. Typical examples of use should be: isPalindrome(vec = c(&quot;Bob&quot;, &quot;Marley&quot;, &quot;Bob&quot;)) ## [1] TRUE isPalindrome(c(3,2,7,4,3)) ## [1] FALSE Hint: You already have the function reverse() from the previous Exercise. Use this function, along with the Boolean operator == and the all() function. The eighteenth-century mathematician Leonhard Euler discovered that: \\[\\frac{\\pi^2}{6} = \\sum_{k=1}^{k=\\infty} \\frac{1}{k^2}.\\] It follows that \\[\\pi = \\sqrt{\\left(\\sum_{k=1}^{k=\\infty} \\frac{6}{k^2}\\right)}.\\] Use this fact to write a function called eulerPI() that will approximate \\(\\pi\\). The function should take a single parameter n, which is the number of terms in the infinite series that are to be summed to make the approximation. The default value of n should be 10,000. Consider the infinite series: \\[\\sum_{k=1}^{k=\\infty} \\frac{1}{k(k+1)}.\\] Write a function called partialSum() that will compute the sum of the first \\(n\\) terms of this series. The function should take a single parameter n, which is the number of terms in the series that are to be summed to make the approximation. The default value of n should be 10,000. Use the function to compute the sum of the first 10,000 terms and the sum of the first 100,000 terms. What number do you thnk the series converges to? "],
["flow.html", "Chapter 4 Flow-Control", " Chapter 4 Flow-Control Figure 4.1: Foxtrot, October 3, 2003. Used with permission. In the above scene from the comic-strip Foxtrot, young Jason has attempted to short-cut his “write-on-the-blackboard” punishment via some code in the C-language that would print out his assigned sentence 500 times. This is an example of flow control. Flow control encompasses the tools in a programming language that allow the computer to make decisions and to repeat tasks. In this Chapter we will learn how flow control is implemented in R. "],
["prompting-the-user.html", "4.1 Prompting the User", " 4.1 Prompting the User One way to control the flow of a program is to arrange for it to pause and await information from the user who runs it. Up to this point any information that we have wanted to process has had to be entered into the code itself. For example, if we want to print out a name to the console, we have to provide that name in the code, like this: person &lt;- &quot;Dorothy&quot; cat(&quot;Hello, &quot;, person, &quot;!\\n&quot;, sep = &quot;&quot;) ## Hello, Dorothy! We can get any printout we like as long as we assign the desired string to person—but we have to do that in the code itself. But what if we don’t know the name of the person whom we want to greet? How can we be assured of printing out the correct name? The readline() function will be helpful, here. It reads input directly from the console and produces a character vector (of length one) that we may use as we like. Thus person &lt;- readline(prompt = &quot;What is your name? &quot;) # Type your name before running the next line! cat(&quot;Hello, &quot;, person, &quot;!\\n&quot;, sep = &quot;&quot;) ## What is your name? Cowardly Lion ## Hello, Cowardly Lion! Note that the input obtained from readline() is always a character vector of length one—a single string—so if you plan to use it as a number then you need to convert it to a number. The as.numeric() function will do this for you: number &lt;- readline(&quot;Give me a number, and I&#39;ll add 10 to it: &quot;) # Give R your number before you run the next line! cat(&quot;The sum is: &quot;, as.numeric(number) + 10) ## Give me a number, and I&#39;ll add 10 to it: 15 ## The sum is: 25 4.1.1 Practice Exercises Try out the following code: pet &lt;- readline(&quot;Enter the name of your pet: &quot;) type &lt;- readline(&quot;What kind of animal is it? (Dog, cat, etc.): &quot;) cat(pet, &quot; is a &quot;, type, &quot;.\\n&quot;, sep = &quot;&quot;) Important: Run the lines one at a time, not all three at once. R will stop after the first line, waiting for your answer. If you try to run line 2 along with the pet line, then line 2 will become your attempted input for pet, resulting in an error. 4.1.2 Solutions to the Practice Exercises Here’s one possible outcome in the Console: &gt; pet &lt;- readline(&quot;Enter the name of your pet: &quot;) Enter the name of your pet: Bo &gt; type &lt;- readline(&quot;What kind of animal is it? (Dog, cat, etc.): &quot;) What kind of animal is it? (Dog, cat, etc.): dog &gt; cat(pet, &quot; is a &quot;, type, &quot;.\\n&quot;, sep = &quot;&quot;) Bo is a dog. "],
["making-decisions-conditionals.html", "4.2 Making Decisions: Conditionals", " 4.2 Making Decisions: Conditionals Another type of flow control involves determining which parts of the program to execute, depending upon certain conditions. 4.2.1 If Statements Let’s design a simple guessing-game for the user: The computer will pick randomly a whole number between 1 and 4. The user will then be asked to guess the number. If the user is correct, then the computer will congratulate the user. number &lt;- sample(1:4, size = 1) guess &lt;- as.numeric(readline(&quot;Guess the number (1-4): &quot;)) if ( guess == number ) { cat(&quot;Congratulations! You are correct.&quot;) } The sample() function randomly picks a value from the vector that is is given. The size parameter specifies how many numbers to pick. (This time we only want one number.) Flow control enters the picture with the reserved word if. Immediately after if is a Boolean expression enclosed in parentheses. This expression is often called the condition. If the condition evaluates to TRUE, then the body of the if statement—the code enclosed in the brackets—will be executed. On the other hand if the condition evaluates to FALSE, then R skips past the bracketed code.13 The general form of an if expression is as follows: if ( condition ) { ## code to run when the condition evaluates to TRUE } The code above congratulates the a lucky guesser, but it has nothing at all to say to someone who did not guess correctly. The way to provide an alternative is through the addition of the else reserved-word: number &lt;- sample(1:4, size = 1) guess &lt;- as.numeric(readline(&quot;Guess the number (1-4): &quot;)) if ( guess == number ) { cat(&quot;Congratulations! You are correct.&quot;) } else { cat(&quot;Sorry, the correct number was &quot;, number, &quot;.\\n&quot;, sep = &quot;&quot;) cat(&quot;Better luck next time!&quot;) } The general form of an if-else expression is as follows: if ( condition ) { # code to run if the condition evaluates to TRUE } else { # code to run if condition evaluates to FALSE } An if-elsecan be followed by any number of if-else’s, setting up a chain of alternative responses: number &lt;- sample(1:4, size = 1) guess &lt;- as.numeric(readline(&quot;Guess the number (1-4): &quot;)) if ( guess == number ) { cat(&quot;Congratulations! You are correct.&quot;) } else if ( abs(guess - number) == 1 ){ cat(&quot;You were close!\\n&quot;) cat(&quot;The correct number was &quot;, number, &quot;.\\n&quot;, sep = &quot;&quot;) } else { cat(&quot;You were way off.\\n&quot;) cat(&quot;The correct number was &quot;, number, &quot;.\\n&quot;, sep = &quot;&quot;) } In general, a chain looks like this: if ( condition1) { # code to run if condition1 evaluates to TRUE } else if ( condition2 ) { # code to run if condition2 evaluates to TRUE } else if ( condition3 ) { # code to run if condition2 evaluates to TRUE } else if ...... # and so on until } else if ( conditionN ) { # code to run if conditionN evaluates to TRUE } 4.2.2 Application: Validating Arguments Recall the function manyCat(): manyCat &lt;- function(word, n) { wordWithNewline &lt;- paste(word, &quot;\\n&quot;, sep = &quot;&quot;) lines &lt;- rep(wordWithNewline, times = n) cat(lines, sep = &quot;&quot;) } What would happen if a user were to call it with an unusable argument for the parameter n, a negative number, for instance? manyCat(word = &quot;Hello&quot;, n = -3) ## Error in rep(wordWithNewline, times = n): invalid &#39;times&#39; argument For us, it’s clear enough what is wrong. After all, we wrote the function in the previous chapter, and we know that the rep() function in its body requires that the times parameter be set to some positive integer. On the other hand, to someone who is unfamiliar with the body of manyCat() and who has no access to help on how manyCat() is to be used it may not be so obvious what has gone wrong and why. In the case of complex functions, we cannot expect ordinary users to search through the function’s definition to learn how to fix an error that arises from improper input. Accordingly, it can be good practice to validate user-input. Conditionals allow us to do this. Here, a possible approach is to attempt to coerce the user’s input for n into an integer, using the as.integer() function: as.integer(3.6) # will round to nearest integer ## [1] 3 as.integer(&quot;4&quot;) # will convert string to number 4 ## [1] 4 as.integer(&quot;4.3&quot;) # will convert AND round ## [1] 4 as.integer(&quot;two&quot;) # cannot convert to integer ## Warning: NAs introduced by coercion ## [1] NA In the last example, the result is NA, and a cryptic warning was issued. In order to keep the warning from the user, we should wrap any call to as.integer() in the suppressWarnings() function. Let’s try out a piece of code that checks for validity: n &lt;- &quot;two&quot; # this will not convert to a number at all converted &lt;- suppressWarnings(as.integer(n)) !is.na(converted) &amp;&amp; converted &gt;= 1 ## [1] FALSE Think about what happened: First we attempted to converted the &quot;two&quot; to an integer. Since the result of as.integer(&quot;two&quot;) is NA, the expression is.na(converted) evaluates to TRUE Hence !is.na(converted) evaluates to FALSE. Hence !is.na(converted) &amp;&amp; converted &gt; 1 evaluates to FALSE. Let’s try it on another “wrong” value: n &lt;- -2 # number, but it&#39;s negative converted &lt;- suppressWarnings(as.integer(n)) !is.na(converted) &amp;&amp; converted &gt;= 1 ## [1] FALSE This time converted gets an assigned value, namely -2, but since it’s not at least 1 the expression !is.na(converted) &amp;&amp; converted &gt;= 1 evaluates to FALSE. Now let’s try it on a “good” value: n &lt;- 3 converted &lt;- suppressWarnings(as.integer(n)) !is.na(converted) &amp;&amp; converted &gt;= 1 ## [1] TRUE Our code appears to be working well. Now that we’ve figured out a way to determine whether any given input is a usable number, let’s employ a conditional to implement validation in manyCat(): manyCat &lt;- function(word, n) { n &lt;- suppressWarnings(as.integer(n)) isValid &lt;- !is.na(n) &amp;&amp; n &gt;= 1 if (!isValid) { message &lt;- &quot;Sorry, n must be a whole number at least 1.\\n&quot; return(cat(message)) } wordWithNewline &lt;- paste(word, &quot;\\n&quot;, sep = &quot;&quot;) lines &lt;- rep(wordWithNewline, times = n) cat(lines, sep = &quot;&quot;) } The idea is to force an early return—along with a helpful message to the Console—if the user’s argument for n is no good. Let’s watch it in action: manyCat(word = &quot;Hello&quot;, n = &quot;two&quot;) # problem! ## Sorry, n must be a whole number at least 1. manyCat(word = &quot;Hello&quot;, n = 3) # OK ## Hello ## Hello ## Hello 4.2.3 Application: Invisible Returns Let’s think again about the \\(\\pi\\)-computing function from Section 3.4.1: madhavaPI &lt;- function(n = 1000000) { k &lt;- 1:n terms &lt;- (-1)^(k+1)*4/(2*k-1) sum(terms) } We could use if to write in a “talky” option: madhavaPI &lt;- function(n = 1000000, verbose = FALSE) { k &lt;- 1:n terms &lt;- (-1)^(k+1)*4/(2*k-1) approx &lt;- sum(terms) if ( verbose) { cat(&quot;Madhava&#39;s approximation is: &quot;, approx, &quot;.\\n&quot;, sep = &quot;&quot;) cat(&quot;This is based on &quot;, n, &quot; terms.\\n&quot;, sep = &quot;&quot;) } approx } Try it out: madhavaPI(n = 1000, verbose = TRUE) ## Madhava&#39;s approximation is: 3.140593. ## This is based on 1000 terms. ## [1] 3.140593 It’s a bit awkward that the approximation gets printed out at the end: after the message on the console, the user doesn’t need to see it. But if we were to remove the final approx expression, then the function would not return an approximation that could be used for further computations. The solution to this dilemma is R’s invisible() function. madhavaPI &lt;- function(n = 1000000, verbose = FALSE) { k &lt;- 1:n terms &lt;- (-1)^(k+1)*4/(2*k-1) approx &lt;- sum(terms) if ( verbose) { cat(&quot;Madhava&#39;s approximation is: &quot;, approx, &quot;.\\n&quot;, sep = &quot;&quot;) cat(&quot;This is based on &quot;, n, &quot; terms.\\n&quot;, sep = &quot;&quot;) } invisible(approx) } If you wrap an expression in invisible(), then it won’t be printed out to the console: madhavaPI(n = 1000, verbose = TRUE) ## Madhava&#39;s approximation is: 3.140593. ## This is based on 1000 terms. Nevertheless it is still returned, as we can see from the following code, in which the approximation is computed without any output to the console and stored in the variable p for use later on in a cat() statement. p &lt;- madhavaPI() # verbose is FALSE by default cat(&quot;Pi plus 10 is about &quot;, p + 10, &quot;.&quot;, sep = &quot;&quot;) ## Pi plus 10 is about 13.14159. 4.2.4 Ifelse The ifelse() function is a special form of the if-else construct that is used to make assignments, and is especially handy in the context of vectorization. Suppose that you have a lot of heights: height &lt;- c(69, 67, 70, 72, 65, 63, 75, 70) You would like to classify each person as either “tall” or “short”, depending on whether they are respectively more or less than 71 inches in height. ifelse() makes quick work of it: heightClass &lt;- ifelse(test = height &gt; 70, yes = &quot;tall&quot;, no = &quot;short&quot;) heightClass ## [1] &quot;short&quot; &quot;short&quot; &quot;short&quot; &quot;tall&quot; &quot;short&quot; &quot;short&quot; &quot;tall&quot; &quot;short&quot; Note that ifelse() takes three parameters: test: the condition you want to evaluate; yes: the value that gets assigned when test is true; no: the value assigned when test is false; Most programmers don’t name the parameters. This is fine—just remember to keep the test-yes-no order: ifelse(height &gt; 70, &quot;tall&quot;, &quot;short&quot;) ## [1] &quot;short&quot; &quot;short&quot; &quot;short&quot; &quot;tall&quot; &quot;short&quot; &quot;short&quot; &quot;tall&quot; &quot;short&quot; Here’s another example of the power of ifelese(). If a triangle has three sides of length \\(x\\), \\(y\\) and \\(z\\), then the sum of any two sides must be greater than the remaining side: \\[\\begin{aligned} x + y &amp;&gt; z, \\\\ x + z &amp;&gt; y, \\\\ y + z &amp;&gt; x. \\end{aligned}\\] This fact is known as the Triangle Inequality. It works the other way around, too: if three positive numbers are such that the sum of any two exceeds the third, then three line segments having those numbers as lengths could be arranged into a triangle. We can write a function that, when given three lengths, determines whether or not they can make a triangle: isTriangle &lt;- function(x, y, z) { (x + y &gt; z) &amp; (x +z &gt; y) &amp; (y + z &gt; x) } isTriangle() simply evaluates a Boolean expression involving x, y and z. It will return TRUE when the three quantities satisfy the Triangle Inequality; otherwise, it returns FALSE. Let’s try it out: isTriangle(x = 3, y = 4, z = 5) ## [1] TRUE Recall that Boolean expressions can involve vectors of any length. So suppose that we are would like to know which of the following six triples of numbers could be the side-lengths of a triangle: \\[(2,4,5),(4.7,1,3.8),(5.2,8,12),\\\\ (6, 6, 13), (6, 6, 11), (9, 3.5, 6.2)\\] We could enter the triples one at a time into isTriangle(). On the other hand we could arrange the sides into three vectors of length six each: a &lt;- c(2, 4.7, 5.2, 6, 6, 9) b &lt;- c(4, 1, 2.8, 6, 6, 3.5) c &lt;- c(5, 3.8, 12, 13, 11, 6.2) Then we can decide about all six triples at once: isTriangle(x = a, y = b, z = c) ## [1] TRUE TRUE FALSE FALSE TRUE TRUE We could also use ifelse() to create a new character-vector that expresses our results verbally: triangle &lt;- ifelse(isTriangle(a, b, c), &quot;triangle&quot;, &quot;not&quot;) triangle ## [1] &quot;triangle&quot; &quot;triangle&quot; &quot;not&quot; &quot;not&quot; &quot;triangle&quot; &quot;triangle&quot; 4.2.5 Switch If you have to make a decision involving two or more alternatives you can use a chain of if ... else constructions. When the alternatives involve no more than the assignment of a value to a variable, you might also consider using the switch() function. For example, suppose that you have days of the week expressed as numbers. Maybe it’s like this: 1 stands for Sunday 2 for Monday 3 for Wednesday and so on. If you would like to convert a day-number to the right day name, then you could write a function like this: dayWord &lt;- function(dayNumber) { switch(dayNumber, &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;) } dayWord(3) ## [1] &quot;Tuesday&quot; In switch() above, the first argument after dayNumber is what goes with 1, the second argument is what goes with 2, and so on. When the item you want to convert is a string rather than a number, then the switch() function works a little bit differently. Suppose, for instance, that you want to abbreviate the names of the weekdays. You might write an abbreviation-function as follows: abbrDay &lt;- function(day) { switch(day, Monday = &quot;Mon&quot;, Tuesday = &quot;Tue&quot;, Wednesday = &quot;Wed&quot;, Thursday = &quot;Th&quot;, Friday = &quot;Fri&quot;, Saturday = &quot;Sat&quot;) } abbrDay(&quot;Wednesday&quot;) ## [1] &quot;Wed&quot; In the above call to switch(), the weekday names you want to abbreviate appear as the names of named character-vectors, each of length one. The value of each vector is what the its name will be converted to. When you are converting strings you have the option to provide a default conversion for values that don’t fit into the pattern you have in mind. All you have to do is to provide the default value as an additional argument. (It should NOT have a name.) Thus: abbrDay &lt;- function(day) { switch(day, Monday = &quot;Mon&quot;, Tuesday = &quot;Tue&quot;, Wednesday = &quot;Wed&quot;, Thursday = &quot;Th&quot;, Friday = &quot;Fri&quot;, Saturday = &quot;Sat&quot;, &quot;not a weekday!&quot;) } abbrDay(&quot;Wednesday&quot;) ## [1] &quot;Wed&quot; abbrDay(&quot;Neptune&quot;) ## [1] &quot;not a weekday!&quot; 4.2.6 Practice Exercises Consider the following function: computeSquare &lt;- function(x) { x^2 } Write a “talky” version of the above function that returns the square invisibly.. It should be called computeSquare2() and should take two parameters: x: the number to be squared verbose: whether or not to cat() out a report to the Console. Typical examples of use would be: computeSquare2(4) ## The square of 4 is 16. mySquare &lt;- computeSquare2(6, verbose = FALSE) mySquare ## [1] 36 Write a function called findKarl() that takes a character vector and returns a character vector that reports whether or not each element of the given vector was equal to the string &quot;Karl&quot;. It should work like this: vec1 &lt;- c(&quot;three&quot;, &quot;blowfish&quot;, &quot;Karl&quot;, &quot;Grindel&quot;) findKarl(vec1) ## [1] &quot;Sorry, not our guy.&quot; &quot;Sorry, not our guy.&quot; &quot;Yep, that&#39;s Karl!&quot; &quot;Sorry, not our guy.&quot; Here’s a function that is supposed to return &quot;small!&quot; when given a number less than 100, and return &quot;big!&quot; when the number if at least 100: sizeComment &lt;- function(x) { if ( x &lt; 100 ) { &quot;small!&quot; } &quot;big!&quot; } But it doesn’t work: sizeComment(200) # this will be OK ## [1] &quot;big!&quot; sizeComment(50) # this won&#39;t be OK ## [1] &quot;big!&quot; Fix the code. Add some validation to the isTriangle() function so that it stops the user if one or more of the parameters x, y and z cannot be interpreted as a positive real number. 4.2.7 Solutions to Practice Exercises Here’s the desired function: computeSquare2 &lt;- function(x, verbose = TRUE) { if ( verbose ) { cat(&quot;The square of &quot;, x, &quot; is &quot;, x^2, &quot;.\\n&quot;, sep = &quot;&quot;) } invisible(x^2) } Here’s one way to write it: findKarl &lt;- function(x) { ifelse(x == &quot;Karl&quot;, &quot;Yep, that&#39;s Karl!&quot;, &quot;Sorry, not our guy.&quot;) } A function always returns the value of the last expression that it evaluates. As it stands, the function will always end at the line &quot;big!&quot;, so &quot;big&quot; will always be returned. One way to get the desired behavior is to force the function to stop executing once it prints out &quot;small!&quot;. You can do this with the return() function: sizeComment &lt;- function(x) { if ( x &lt; 100 ) { return(&quot;small!&quot;) } &quot;big!&quot; } Another way is to use the if ... else construction: sizeComment &lt;- function(x) { if ( x &lt; 100 ) { &quot;small!&quot; } else { &quot;big!&quot; } } Here is one approach: isTriangle &lt;- function(x, y, z) { x &lt;- suppressWarnings(as.numeric(x)) x &lt;- suppressWarnings(as.numeric(x)) x &lt;- suppressWarnings(as.numeric(x)) xValid &lt;- all(!is.na(x) &amp; x &gt; 0) yValid &lt;- all(!is.na(y) &amp; y &gt; 0) zValid &lt;- all(!is.na(z) &amp; z &gt; 0) if (!(xValid &amp; yValid &amp; zValid)) { return(cat(&quot;Sorry, all inputs must be positive real numbers.\\n&quot;)) } (x + y &gt; z) &amp; (x +z &gt; y) &amp; (y + z &gt; x) } Try it out: isTriangle(x = c(2,4,7), y = c(3, -4, 5), # oops, a negative number z = c(6, 8, 10)) ## Sorry, all inputs must be positive real numbers. isTriangle(x = c(2,4,7), y = c(3, 4, 5), # fixed it z = c(6, 8, 10)) ## [1] FALSE FALSE TRUE Actually you don’t need the brackets if you plan to put only one expression in them. Many people keep the brackets, though, for the sake of clarity.↩ "],
["repeating-things-looping.html", "4.3 Repeating Things: Looping", " 4.3 Repeating Things: Looping We have looked a bit into the aspect of flow control that pertains to making decisions. Let us now turn to the R-constructs that make the computer repeat actions. 4.3.1 For Loops The reserved word for is used to make R repeat an action a specified number of times. We begin with an very simple example: for ( i in 1:4 ) { cat(&quot;Hello, Dorothy!\\n&quot;) } ## Hello, Dorothy! ## Hello, Dorothy! ## Hello, Dorothy! ## Hello, Dorothy! Here’s how the loop works. Recall that the vector 1:4 is simply the sequence of integers from 1 to 4: 1:4 ## [1] 1 2 3 4 When R sees the code (i in 1:4) it knows that it will have to go four times through the body of the loop. cat(&quot;Hello, Dorothy!\\n&quot;) (The body of a loop is what’s contained in the brackets after for(i in 1:4)). At the start of the loop, the index variable i is set to 1. After the body is executed the first time, R sets i to 2, then executes the body again. Then R sets i to 3 and executes the body yet again. Then R sets i to 4, and executes the body for the final time. The result is four lines printed out to the console. The more you need to repeat a particular pattern, the more it makes sense to write your code with a loop. The general form of a loop is: for ( var in seq ) { # code involving var } var is the index variable, and it can be any permitted name for a variable, and seq can be any vector. As R traverses the loop, the value of the index variable var becomes each element of the vector seq in turn. With every change in the value of var, the code in the brackets is executed. To iterate is to do a thing again and again. The vector seq is sometimes called an iterable, since it is “iterated over.” It contains the values that the index variable will assume, one by one, as the loop is repeated. It’s important to realize that the index variable can have any valid name, and the sequence can be any type of vector at all—not just a sequence of consecutive whole numbers beginning with 1. This level of generality permits a for-loop to automate a wide variety of tasks, and for its code to be written in a way that evokes the operations being performed. For example, here is a loop to print out some greetings; people &lt;- c(&quot;Dorothy&quot;, &quot;Tin Man&quot;, &quot;Scarecrow&quot;, &quot;Lion&quot;) for ( person in people ) { cat(&quot;Hello, &quot;, person, &quot;!\\n&quot;, sep = &quot;&quot;) } ## Hello, Dorothy! ## Hello, Tin Man! ## Hello, Scarecrow! ## Hello, Lion! Or perhaps you want to abbreviate a vector-ful of weekday-names: weekdays &lt;- c(&quot;Saturday&quot;, &quot;Monday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;) for ( day in weekdays ) { print(abbrDay(day)) } ## [1] &quot;Sat&quot; ## [1] &quot;Mon&quot; ## [1] &quot;Fri&quot; ## [1] &quot;Sat&quot; Quite often you will want to store the results of your trips through the loop. Let’s do this for our abbreviated weekdays: weekdays &lt;- c(&quot;Saturday&quot;, &quot;Monday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;) abbrDays &lt;- character(length(weekdays)) We used the character() function to create the character vector abbrDays. We specified that the number of elements in abbrDays shall be the same as the number of elements in weekdays. Right now abbrDays isn’t very interesting, as all of its elements are empty strings: abbrDays ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; We will now write a for-loop to fill it up with abbreviations: for ( i in 1:length(weekdays) ) { abbrDays[i] &lt;- abbrDay(weekdays[i]) } Now each of the four elements of abbrDays contains the abbreviation for the corresponding element of weekdays: abbrDays ## [1] &quot;Sat&quot; &quot;Mon&quot; &quot;Fri&quot; &quot;Sat&quot; You will often have reason to set up an empty vector of a definite length and use a loop to store information in it. The general format looks like this: results &lt;- numeric(someLength) # empty numerical vector for ( i in 1:someLength ) { # computations involving i, and then: results[i] &lt;- some_result_depending_on_i } # then do something with results, such as: print(results) 4.3.2 For-Loop Caution You might need to exercise some caution in your choice name for the index variable. If you are already using it as the name for a variable in the same environment, then you will overwrite that variable, as demonstrated by the following code: day &lt;- &quot;Thursday&quot; cat(&quot;Today is &quot;, day, &quot;.\\n&quot;, sep = &quot;&quot;) ## Today is Thursday. weekdays &lt;- c(&quot;Saturday&quot;, &quot;Monday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;) abbrDays &lt;- character(length(weekdays)) for ( day in weekdays ) { print(day) } ## [1] &quot;Saturday&quot; ## [1] &quot;Monday&quot; ## [1] &quot;Friday&quot; ## [1] &quot;Saturday&quot; cat(&quot;Today is &quot;, day, &quot;.\\n&quot;, sep = &quot;&quot;) ## Today is Saturday. Of course, that won’t happen if the for-loop is inside of a function and your variable is outside of it. day &lt;- &quot;Thursday&quot; cat(&quot;Today is &quot;, day, &quot;.\\n&quot;, sep = &quot;&quot;) ## Today is Thursday. weekdays &lt;- c(&quot;Saturday&quot;, &quot;Monday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;) listDays &lt;- function(days) { for ( day in days ) { print(day) } } listDays(weekdays) ## [1] &quot;Saturday&quot; ## [1] &quot;Monday&quot; ## [1] &quot;Friday&quot; ## [1] &quot;Saturday&quot; cat(&quot;Today is still &quot;, day, &quot;.\\n&quot;, sep = &quot;&quot;) ## Today is still Thursday. 4.3.3 Breaking Out of a Loop Sometimes you finish the task at hand before you are done with the loop. If this is a possibility for you then you may arrange to break out of the loop with the break reserved-word. Suppose for example that you want a function that searches through a vector for a given element, updating the user along the way as to the progress of the search. You can try something like this: # function to find index of element in vector. # returns -1 if elem is not in vector verboseSearch &lt;- function(elem, vec) { # The following logical keeps track of whether # we have found the element. # We have not yet begun the search so start it # at FALSE. found &lt;- FALSE # validate input: if ( length(vec) == 0 ) { cat(&quot;The vector empty. No way does it contain &quot;, elem, &quot;.&quot;, sep = &quot;&quot;) return(-1) } # check the elements of vector: for ( i in 1: length(vec) ) { if ( vec[i] == elem ) { # record that we found the element: found &lt;- TRUE break } else { # report no match at this index: cat(&quot;Checked index &quot;, i, &quot; in the vector. No match there ...\\n&quot;, sep = &quot;&quot;) } } if ( found ) { # report success: cat(&quot;Found &quot;, elem, &quot; at index &quot;, i, &quot;.\\n&quot;, sep = &quot;&quot;) return(i) } else { # report failure: cat(elem, &quot; is not in the vector.\\n&quot;, sep = &quot;&quot;) return(-1) } } Let’s see our function in action: people &lt;- c(&quot;Dorothy&quot;, &quot;Tin Man&quot;, &quot;Scarecrow&quot;, &quot;Lion&quot;) scarecrowPlace &lt;- verboseSearch(&quot;Scarecrow&quot;, people) ## Checked index 1 in the vector. No match there ... ## Checked index 2 in the vector. No match there ... ## Found Scarecrow at index 3. In the code for verboseSearch() you will notice that there is an initial check on the length of the vector. This is actually important. If a user were to enter an empty vector, then its length would be 0. Then in the loop the sequence would be 1:0, which is the vector with elements 1 and 0. But look at what happens when you ask for any element of a zero-length vector: emptyVec &lt;- character(0) emptyVec[1] # You get NA ## [1] NA Then check out what happens if you compare an NA to a string: NA == &quot;Scarecrow&quot; ## [1] NA Now look at what happens in an if statement where the condition is NA: if ( NA ) { cat(&quot;We are in the bracket!\\n&quot;) } ## Error in if (NA) { : missing value where TRUE/FALSE needed Checking that the input vector has positive length is an another example of validating input. Remember: when you write functions for other people to use it can be helpful to have the function validate its input instead of allowing R to throw obscure error messages at the user. 4.3.4 Solving the Empty-Vector Problem in for-Loops with seq_along() In the previous section we considered a possible problem with for-loops of the following form: for ( i in 1:length(vec) ) { ## do something ... } In the above loop vec could be thought of as a “loop-defining” vector: its length determines the sequence of values 1, 2, 3 … for the index i. This sequence of values is supposed to end at the length of vec. The problem is that if vec happens to be an empty vector then we probably don’t want to enter the loop at all. However, the length of an empty vector is 0, and so the vector 1:length(vec) actually works out to be a vector with two elements: c(1,0) Hence R will go through the loop twice: once when i is 1, and again when i is 0. Depending on what the loop does, very unexpected results could be produced. In the previous section we dealt with the problem by writing an if-statement that provides the proper response when vec is empty. In many circumstances however, all we need to do is to make sure that the loop is skipped when the vector is empty. A handy way to ensure skipping is to use the function seq_along() . Given any non-empty vector, seq_along() produces a sequence-vector that begins with 1 and ends with the length of the vector, thus: vec &lt;- c(&quot;a&quot;, &quot;d&quot;, &quot;f&quot;) seq_along(vec) ## [1] 1 2 3 On the other hand, if the vector is empty, then seq_long() returns an empty numeric vector: vec &lt;- character() seq_along(vec) ## integer(0) Now consider the loop inside the following function: loopy &lt;- function(vec) { for ( i in seq_along(vec) ) { cat(&quot;This time i is &quot;, i, &quot;.\\n&quot;, sep = &quot;&quot;) } } Given a non-empty vector, it goes through the loop a number of times equal to the length of the vector: loopy(c(&quot;a&quot;, &quot;d&quot;, &quot;f&quot;)) ## This time i is 1. ## This time i is 2. ## This time i is 3. On the other hand, when given an empty vector the function does not enter the loop at all: loopy(character()) # no output to console! When you are writing a program that is complex enough that you don’t know whether the loop-defining vector might be empty, it is good practice to use seq_along() as a safeguard. 4.3.5 Skipping Ahead in a Loop Depending on what happens within a loop, you might sometimes wish to skip the remaining code within the loop and proceed to the next iteration. R provides the reserved-word next for this purpose. Here is a simple example: vec &lt;- c(&quot;a&quot;,&quot;e&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;e&quot;, &quot;z&quot;) # shout ahoy when you see the specified element verboseAhoy &lt;- function(elem, vec) { if (length(vec) &gt; 0) { for ( i in 1: length(vec) ) { if ( vec[i] != elem) next cat(&quot;Ahoy! &quot;, elem, &quot; at index &quot;, i, &quot;!\\n&quot;, sep = &quot;&quot;) } } } verboseAhoy(&quot;e&quot;, vec) ## Ahoy! e at index 2! ## Ahoy! e at index 3! ## Ahoy! e at index 7! When the vec[i] !== elem condition is true, R immediately skips the rest of the loop, increments the value of the index variable i, and runs through the loop again. You can always accomplish the skipping without using next explicitly, but it’s nice to have on hand. 4.3.6 Repeat For-loops are pretty wonderful, but they are best used in circumstances when you know how many times you will need to loop. When you need to repeat a block of code until a certain condition occurs, then the repeat reserved-word might be a good choice. For example, suppose you want to play the number-guessing game with the user, but let her keep guessing until either she gives up or gets the correct answer. Here’s an implementation using repeat: n &lt;- 20 number &lt;- sample(1:n, size = 1) cat(&quot;I&#39;m thinking of a whole number from 1 to &quot;, n, &quot;.\\n&quot;, sep = &quot;&quot;) repeat { guess &lt;- readline(&quot;What&#39;s your guess? (Enter q to quit.) &quot;) if ( guess == &quot;q&quot; ) { cat(&quot;Bye!\\n&quot;) break } else if ( as.numeric(guess) == number ) { cat(&quot;You are correct! Thanks for playing!&quot;) break } # If we get here, the guess was not correct: # loop will repeat! } The game works well enough, but if you give it a try, you are sure to find it a bit fatiguing. It wold be nice to give the user a hint after an incorrect guess. Let’s revise the game to tell the reader whether her guess was high or low. While we are at it, let’s cast the game into the form of a function. numberGuess &lt;- function(n) { number &lt;- sample(1:n, size = 1) cat(&quot;I&#39;m thinking of a whole number from 1 to &quot;, n, &quot;.\\n&quot;, sep = &quot;&quot;) repeat { guess &lt;- readline(&quot;What&#39;s your guess? (Enter q to quit.) &quot;) if (guess == &quot;q&quot;) { cat(&quot;Bye!\\n&quot;) break } else if (as.numeric(guess) == number) { cat(&quot;You are correct! Thanks for playing!&quot;) break } # If we get to this point the guess was not correct. # Issue hint: hint &lt;- ifelse(as.numeric(guess) &gt; number, &quot;high&quot;, &quot;low&quot;) cat(&quot;Your guess was &quot;, hint, &quot;. Keep at it!\\n&quot;, sep = &quot;&quot;) # Repeat loop } } A typical game: &gt; numberGuess(100) I&#39;m thinking of a whole number from 1 to 100. What&#39;s your guess? (Enter q to quit.) 50 Your guess was high. Keep at it! What&#39;s your guess? (Enter q to quit.) 25 Your guess was high. Keep at it! What&#39;s your guess? (Enter q to quit.) 12 Your guess was low. Keep at it! What&#39;s your guess? (Enter q to quit.) 18 Your guess was low. Keep at it! What&#39;s your guess? (Enter q to quit.) 22 Your guess was high. Keep at it! What&#39;s your guess? (Enter q to quit.) 20 You are correct! Thanks for playing! 4.3.7 While The reserved word while constructs a loop that runs as long as a specified condition is true. Unlike repeat, which launches directly into the loop, the condition for while is evaluated prior to the body of the loop. If the condition is false at the beginning, the code in the body of the loop is never executed. verboseSearch() could be re-written with while: verboseSearch &lt;- function(elem, vec) { found &lt;- FALSE if ( length(vec) == 0 ) { cat(&quot;The vector is empty. No way does it contain &quot;, elem, &quot;.\\n&quot;, sep = &quot;&quot;) return(-1) } # index of vec (start looking at 1): i &lt;- 1 while ( !found &amp; i &lt;= length(vec) ) { if ( vec[i] == elem ) { found &lt;- TRUE break } cat(&quot;No match at position &quot;, i, &quot; ...\\n&quot;) i &lt;- i + 1 } if ( found ) { # report success: cat(&quot;Found &quot;, elem, &quot; at index &quot;, i, &quot;.\\n&quot;, sep = &quot;&quot;) return(i) } else { # report failure: cat(elem, &quot; is not in the vector.\\n&quot;, sep = &quot;&quot;) return(-1) } } 4.3.8 Practice Problems You want to compute the square roots of the whole numbers from 1 to 10. You could do this quite easily as follows: sqrt(1:10) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 3.000000 3.162278 However, you want to practice using for-loops. Write a small program that uses a loop to compute the square roots of the whole numbers from 1 to 10. Think about the practice problem findKarl() from the previous section. Write a new version that uses a loop. You want to append &quot;the Dog&quot; to the end of each element of a character vector of dog-names. Sadly, you have not yet realized that the paste() function is very much up to the task: doggies &lt;- c(&quot;Bo&quot;, &quot;Gracie&quot;, &quot;Rover&quot;, &quot;Anya&quot;) paste(doggies, &quot;the Dog&quot;) ## [1] &quot;Bo the Dog&quot; &quot;Gracie the Dog&quot; &quot;Rover the Dog&quot; &quot;Anya the Dog&quot; You decide to use a for-loop. Write the code. Write a function called triangleOfStars() that produces patterns liks this: **** *** ** * It should take a single parameter n, the number of asterisks in the first “line” of the triangle. Use a for-loop in the body of the function. Write a function called trianglePattern() that produces patterns like the ones from the previous problem, but using any character that the user specifies. The function should take two parameters: char, a string giving the character to use. The default value should be &quot;*&quot;. n, the number of asterisks in the first “line” of the output. Typical examples of use should be as follows: trianglePattern(char = &quot;x&quot;, 5) ## xxxxx ## xxxx ## xxx ## xx ## x trianglePattern(n = 6) ## ****** ## ***** ## **** ## *** ## ** ## * Rewrite triangleOfStars() so that it uses a while-loop in its body. Rewrite triangleOfStars() so that it still uses a while-loop in its body, but produces output like this: * ** *** **** Write a function called cheerleader() that badgers you for each of the letters in a word until you give it all of the letters, one by one. It should work like this: schoolMascot &lt;- c(&quot;T&quot;, &quot;I&quot;, &quot;G&quot;, &quot;E&quot;, &quot;R&quot;, &quot;S&quot;) cheerleader(cheer = schoolMascot) &gt; cheerleader(cheer = schoolMascot) Gimme a T! T Gimme a I! i Gimme a I! I Gimme a G! gee Gimme a G! I said gee!! Gimme a G! G Gimme a E! E Gimme a R! Are you going to do this all day? Gimme a R! R Gimme a S! Stop it, please! Gimme a S! S &gt; Write a function called ageReporter() that reports the ages of given individuals. It should take two parameters: people: a character vector of names of the people of interest. ages: a vector containing the ages of the people of interest. The function should perform some validation: it should stop the user with a helpful message if the number of people supplied and the number of ages supplied are not the same, or if one of the supplied vectors has length zero. Typical examples of use would be as follows: folks &lt;- c(&quot;Gina&quot;, &quot;Hector&quot;) theirAges &lt;- c(25, 22) ageReporter(folks, theirAges) ## Gina is 25 year(s) old. ## Hector is 22 year(s) old. folks &lt;- c(&quot;Gina&quot;, &quot;Hector&quot;, &quot;Tom&quot;) theirAges &lt;- c(25, 22) ageReporter(folks, theirAges) ## Number of people must equal number of ages! folks &lt;- c(&quot;Gina&quot;, &quot;Hector&quot;) theirAges &lt;- numeric(0) ageReporter(folks, theirAges) ## Provide at least one age! 4.3.9 Solutions to the Practice Exercises Here’s a suitable program: roots &lt;- numeric(10) for ( i in 1:10 ) { roots[i] &lt;- sqrt(i) } roots ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 3.000000 3.162278 You could do this: findKarl &lt;- function(x) { results &lt;- character(length(x)) for ( i in 1: length(x) ) { if ( x[i] == &quot;Karl&quot; ) { results[i] &lt;- &quot;Yep, that&#39;s Karl!&quot; } else { results[i] &lt;- &quot;Sorry, not our guy.&quot; } } results } Here you go: doggies &lt;- c(&quot;Bo&quot;, &quot;Gracie&quot;, &quot;Rover&quot;, &quot;Anya&quot;) titledDoggies &lt;- character(length(doggies)) for (i in 1:length(doggies) ) { titledDoggies[i] &lt;- paste(doggies[i], &quot;the Dog&quot;) } titledDoggies ## [1] &quot;Bo the Dog&quot; &quot;Gracie the Dog&quot; &quot;Rover the Dog&quot; &quot;Anya the Dog&quot; Here’s the code: triangleOfStars &lt;- function(n) { for ( i in n:1 ) { line &lt;- rep(&quot;*&quot;, times = i) cat(line, &quot;\\n&quot;, sep = &quot;&quot;) } } Try it out: triangleOfStars(5) ## ***** ## **** ## *** ## ** ## * Here’s the code: trianglePattern &lt;- function(char = &quot;*&quot;, n) { for (i in n:1) { line &lt;- rep(char, times = i) cat(line, &quot;\\n&quot;, sep = &quot;&quot;) } } Here’s the code: triangleOfStars &lt;- function(n) { while ( n &gt;= 1 ) { line &lt;- rep(&quot;*&quot;, times = n) cat(line, &quot;\\n&quot;, sep = &quot;&quot;) n &lt;- n - 1 } } Try it out: triangleOfStars(5) ## ***** ## **** ## *** ## ** ## * Here’s the code: triangleOfStars &lt;- function(n) { m &lt;- 1 while ( m &lt;= n ) { line &lt;- rep(&quot;*&quot;, times = m) cat(line, &quot;\\n&quot;, sep = &quot;&quot;) m &lt;- m + 1 } } Try it out: triangleOfStars(5) ## * ## ** ## *** ## **** ## ***** Here is the requested annoying function, using a repeat-loop with break inside a for-loop: cheerleader &lt;- function(cheer) { for ( letter in cheer ) { repeat { call &lt;- paste(&quot;Gimme a &quot;, letter, &quot;! &quot;, sep = &quot;&quot;) response &lt;- readline(call) if ( response == letter ) break } } } Here is one possibility: ageReporter &lt;- function(people, ages) { ## validation: p &lt;- length(people) a &lt;- length(ages) if (p == 0) { return(cat(&quot;Provide at least one person!\\n&quot;)) } if (a == 0) { return(cat(&quot;Provide at least one age!\\n&quot;)) } if (!(p == a &amp; p &gt; 0)) { return(cat(&quot;Number of people must equal number of ages!\\n&quot;)) } ## process: for (i in 1:length(people)) { cat(people[i], &quot; is &quot;, ages[i], &quot; year(s) old.\\n&quot;, sep = &quot;&quot;) } } "],
["collatz-conjecture.html", "4.4 Application: The Collatz Conjecture", " 4.4 Application: The Collatz Conjecture Take any positive integer greater than 1. Apply the following rule, which we will call the Collatz Rule: If the integer is even, divide it by 2; if the integer is odd, multiply it by 3 and add 1. Now apply the rule to the resulting number, then apply the rule again to the number you get from that, and so on. For example, start with 13. We proceed as follows: 13 is odd, so compute \\(3 \\times 13 + 1 = 40\\). 40 is even, so compute \\(40/2 = 20\\). 20 is even, so compute \\(20/2 = 10\\). 10 is even, so compute \\(10/2 = 5\\). 5 is odd, so compute \\(3 \\times 5+ 1 = 16\\) 16 is even, so compute \\(16/2 = 8\\). 8 is even, so compute \\(8/2 = 4\\). 4 is even, so compute \\(4/2 = 2\\). 2 is even, so compute \\(2/2 = 1\\). 1 is odd, so compute \\(3 \\times 1 + 1 = 4\\). 4 is even, so compute \\(4/2 = 2\\). 2 is even, so compute \\(2/2 = 1\\). If we keep going, then we will cycle forever: \\[4, 2, 1, 4, 2, 1, \\ldots\\] In mathematics the Collatz Conjecture is the conjecture that for any initial positive number, every Collatz Sequence (the sequence formed by repeated application of the Collatz Rule) eventually contains a 1, after which it must cycle forever. No matter how large a number we begin with, we have always found that it returns to 1, but mathematicians do not know if this will be so for any initial number. A sequence of Collatz numbers can bounce around quite remarkably before descending to 1. Our goal in this section is to write a function called collatz() that will compute the Collatz sequence for any given initial number and draw a graph of the sequence as well. First, let’s make a function just for the Collatz Rule itself: collatzRule &lt;- function(m) { if ( m %% 2 == 0) { return(m/2) } else { return(3*m + 1) } } (Recall that m %% 2 is the remainder of m after it is divided by 2. If this is 0, then m is even.) Next let’s try to get a function going that will print out Collatz numbers: collatz &lt;- function(n) { # n is the initial number while ( n &gt; 1 ) { cat(n, &quot; &quot;, sep = &quot;&quot;) # get the next number and call it n: n &lt;- collatzRule(n) } } Let’s try it out: collatz(13) ## 13 40 20 10 5 16 8 4 2 So far, so good, but if we are going to graph the numbers, then we should store them in a vector. The problem is that we don’t know how long the vector needs to be. One possible solution is to add to the vector as we go, like this: collatz &lt;- function(n) { numbers &lt;- numeric() while ( n &gt; 1 ) { # stick n onto the end of numbers: numbers &lt;- c(numbers, n) n &lt;- collatzRule(n) } print(numbers) } Try it out: collatz(13) ## [1] 13 40 20 10 5 16 8 4 2 This looks good. There are two problems, though, if the Collatz sequence happens to go on for a very long time. Computation Time: the user doesn’t know when the sequence will end—if ever!—so she won’t know whether a delay in production of the output is due to a long sequence or a problem with the program itself. as the sequence gets longer, the computation-time is made even longer by the way the following line of code works: numbers &lt;- c(numbers, n) R cannot actually “stick” a new element onto the end of a vector. What it actually does is to move to a new place in memory and create an entirely new vector consisting of all the elements of numbers followed by the number n. R then assigns the name numbers to this value, freeing up the old place in memory where the previous numbers vector lived, but when a vector is very long copying can take a long time. Memory Problems Once the numbers vector gets long enough it will use all of the memory in the computer that is available to R. R will crash. In order to get around this problem, we should impose a limit on the number of Collatz numbers that we will compute. We’ll set the limit at 10,000. The user can change the limit, but should exercise caution in doing so. Also, we’ll initialize our numbers vector to have a length set to this limit. We can then assign values to elements of an already existing vector: this is much faster than copying entire vectors from scratch. collatz &lt;- function(n, limit = 10000) { # collatz numbers will go in this vector numbers &lt;- numeric(limit) # keep count of how many numbers we have made: counter &lt;- 0 while ( n &gt; 1 &amp; counter &lt; limit) { # need to make a new number counter &lt;- counter + 1 # put the current number into the vector numbers[counter] &lt;- n # make next Collatz number n &lt;- collatzRule(n) } # find how many Collatz numbers we made: howMany &lt;- min(counter, limit) # print them out: print(numbers[1:howMany]) } Again let’s try it: collatz(257) ## [1] 257 772 386 193 580 290 145 436 218 109 328 164 82 41 124 62 31 94 ## [19] 47 142 71 214 107 322 161 484 242 121 364 182 91 274 137 412 206 103 ## [37] 310 155 466 233 700 350 175 526 263 790 395 1186 593 1780 890 445 1336 668 ## [55] 334 167 502 251 754 377 1132 566 283 850 425 1276 638 319 958 479 1438 719 ## [73] 2158 1079 3238 1619 4858 2429 7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 ## [91] 2308 1154 577 1732 866 433 1300 650 325 976 488 244 122 61 184 92 46 23 ## [109] 70 35 106 53 160 80 40 20 10 5 16 8 4 2 Things are working pretty well, but since the sequence of numbers might get pretty long, perhaps we should only print out the length of the sequence, and leave it to the reader to say whether the sequence itself should be shown. collatz &lt;- function(n, limit = 10000) { numbers &lt;- numeric(limit) counter &lt;- 0 while ( n &gt; 1 &amp; counter &lt; limit) { counter &lt;- counter + 1 numbers[counter] &lt;- n n &lt;- collatzRule(n) } howMany &lt;- min(counter, limit) cat(&quot;The Collatz sequence has &quot;, howMany, &quot; elements.\\n&quot;, sep = &quot;&quot;) show &lt;- readline(&quot;Do you want to see it (y/n)? &quot;) if ( show == &quot;y&quot; ) { print(numbers[1:howMany]) } } Next let’s think about the plot. We’ll use the plotting system in the ggplot2 package (Wickham et al. 2020). library(ggplot2) Later on we will make a serious study of plotting with ggplot2, but for now let’s just get the basic idea of plotting a set of points. First, let’s get a small set of points to plot: xvals &lt;- c(1, 2, 3, 4, 5) yvals &lt;- c(3, 7, 2, 4, 3) xvals contains the x-coordinates of our points, and yvals contains the corresponding y-coordinates. We set up a plot as follows: ggplot(mapping = aes(x = xvals, y = yvals)) The ggplot() function sets up a basic two-dimensional grid. The mapping parameter explains how data will be “mapped” to particular positions on the plot. In this case it has been set to: aes(x = xvals, y = yvals) aes is short for “aesthetics”, which has to do with how somethings looks. The expression means that xvals will be located on the x-axis and yvals will be located on the y-axis of the plot. Now let’s see what we get if we actually run the call to the ggplot() function (see Figure 4.2): ggplot(mapping = aes(x = xvals, y = yvals)) Figure 4.2: A ggplot2 plot without geoms. The plot is blank! Why is this? Well, although ggplot() has been told what values are to be represented on the plot and where they might go, it has not yet been told how they should be shaped: it has not been told their geometry, you might say. We can add a geometry to the plot to get a picture (see Figure 4.3: ggplot(mapping = aes(x = xvals, y = yvals)) + geom_point() Figure 4.3: A ggplot2 plot with the point geom. The geometry determines a lot about the look of the plot. In order to have the points connected by lines we could add geom_line() (see Figure 4.4: ggplot(mapping = aes(x = xvals, y = yvals)) + geom_point() + geom_line() Figure 4.4: A ggplot2 plot with point and line geoms. We’ll choose a scatterplot with connecting lines for our graph of the sequence. With a little more work we can get nice labels for the x and y-axes, and a title for the graph. Our collatz() function now looks like: collatz &lt;- function(n, limit = 10000) { # record initial number because we will change n initial &lt;- n numbers &lt;- numeric(limit) counter &lt;- 0 while ( n &gt; 1 &amp; counter &lt; limit) { counter &lt;- counter + 1 numbers[counter] &lt;- n n &lt;- collatzRule(n) } howMany &lt;- min(counter, limit) steps &lt;- 1:howMany cat(&quot;The Collatz sequence has &quot;, howMany, &quot; elements.\\n&quot;, sep = &quot;&quot;) show &lt;- readline(&quot;Do you want to see it (y/n)? &quot;) if ( show == &quot;y&quot; ) { print(numbers[steps]) } # use initial value to make plot title: plotTitle &lt;- paste0(&quot;Collatz Sequence for n = &quot;, initial) # make the plot ggplot(mapping = aes(x = steps, y = numbers[steps])) + geom_point() + geom_line() + labs( x = &quot;Step&quot;, y = &quot;Collatz Value at Step&quot;, title = plotTitle) } Try this version a few times, like so: collatz(257) It’s quite remarkable how much the sequence can rise and fall before hitting 1. A further issue worth considering is that our collatz() function depends on the previously-defined function collatzRule(). In order for it to work correctly, R would need to be able to find the name collatzRule somewhere on the search path. If the user hasn’t already defined the collatzRule() function, then a call to `collatz() will fail. One solution is simply to remind users of the need to define both collatzRule() and collatz() prior to running collatz(). Another solution—perhaps the kinder one—is to define the collatzRule() function in the body of collatz(). Let’s adopt this approach. The final version of the collatz() function (with some validation thrown in for good measure) appears below. collatz &lt;- function(n, limit = 10000) { # add some validation: n &lt;- suppressWarnings(as.integer(n)) isValid &lt;- !is.na(n) &amp;&amp; n &gt; 1 if (!isValid ) { return(cat(&quot;Need an integer bigger than 1. Try again.&quot;)) } # define collatzRule: collatzRule &lt;- function(m) { if ( m %% 2 == 0) { return(m/2) } else { return(3*m + 1) } } # On with the show! # Record initial number because we will change it: initial &lt;- n numbers &lt;- numeric(limit) counter &lt;- 0 while ( n &gt; 1 &amp; counter &lt; limit) { counter &lt;- counter + 1 numbers[counter] &lt;- n n &lt;- collatzRule(n) } howMany &lt;- min(counter, limit) cat(&quot;The Collatz sequence has &quot;, howMany, &quot; elements.\\n&quot;, sep = &quot;&quot;) show &lt;- readline(&quot;Do you want to see it (y/n)? &quot;) if ( show == &quot;y&quot; ) { print(numbers[1:howMany]) } plotTitle &lt;- paste0(&quot;Collatz Sequence for n = &quot;, initial) steps &lt;- 1:howMany ggplot(mapping = aes(x = steps, y = numbers[1:howMany])) + geom_point() + geom_line() + labs( x = &quot;Step&quot;, y = &quot;Collatz Value at Step&quot;, title = plotTitle) } References "],
["glossary-2.html", "Glossary", " Glossary Flow Control The collection of devices within a programming language that allow the computer to make decisions and to repeat tasks. Condition A Boolean expression that commences an if or while statement. If the condition evaluates to TRUE, then the code in the body of the statement will be executed. Otherwise the code will be ignored. Index Variable The variable in a for loop that takes on each of the values of the iterable in succession. Iterable The vector that provides the sequence of values for the index variable in a for loop. Validation The process of checking user input and rejecting it—usually with helpful suggestions—if it is not of the correct form. "],
["exercises-2.html", "Exercises", " Exercises The absolute value of a number \\(x\\) is defined to be the number \\(x\\) itself if \\(x \\ge 0\\), whereas it is the opposite of \\(x\\) if \\(x &lt; 0\\). Thus: the absolute value of 3 is 3; the absolute value of -3 is -(-3), which is 3; the absolute value of -5.7 is -(-5.7), which is 5.7 the absolute value of 0 is 0. The absolute value is important enough that R provides the abs() function to compute it. Thus: abs(-3.7) ## [1] 3.7 Write a function called absolute() that computes the absolute value of any given number x. Your code should make no reference to R’s abs(). Small Bonus: Write the function so that it follows the vector-in, vector-out principle, that is: when it is given a vector of numbers it returns the vector of their absolute values, like this: vec &lt;- c(-3, 5, -2.7) absolute(vec) ## [1] 3.0 5.0 2.7 Write a function called pattern() that, when given any character \\(x\\) and any positive number \\(n\\), will print the following pattern to the console: a line with just one \\(x\\), another line with two \\(x\\)’s, another line with three \\(x\\)’s, and so on until … a line with \\(n\\) \\(x\\)’s, and then another line with \\(n-1\\) \\(x\\)’s, and so on until … a line with just one \\(x\\). The function should take two arguments: char: the character to repeat. The default value should be &quot;*&quot;. n: the number of characters in the longest, middle line. The default value should be 3. Typical examples of use should be as follows: pattern() ## * ## ** ## *** ## ** ## * pattern(char = &quot;y&quot;, n = 5) ## y ## yy ## yyy ## yyyy ## yyyyy ## yyyy ## yyy ## yy ## y Hint: You already know how to cat out a line consisting of any given number of a given character: char &lt;- &quot;*&quot; ## the desried character i &lt;- 4 ## the desired number of times cat(rep(char, times = i), &quot;\\n&quot;, sep = &quot;&quot;) ## **** You need to make a vector that contains the desired “number of times”, for each line. Consider this method: n &lt;- 5 ## say we want 1-2-3-4-5-4-3-2-1 lineNumbers &lt;- c(1:(n-1), n, (n-1):1) lineNumbers ## [1] 1 2 3 4 5 4 3 2 1 Then you could write a for-loop that iterates over lineNumbers. Write a function called checkerBoard() that prints outs out checkerboard patterns like this: ## ----------- ## |*|*|*|*|*| ## ----------- ## |*|*|*|*|*| ## ----------- ## |*|*|*|*|*| ## ----------- ## |*|*|*|*|*| ## ----------- ## |*|*|*|*|*| ## ----------- The function should take two parameters: char, the character that fills the “squares” of the board. The default value should be &quot;*&quot;. side, the number of rows and columns of the board. There should be no default value. Note that the horizontal boundaries are formed by the hyphen - and the vetical boundaries are formed by the pipe character | that appears on your keyboard above the backslash \\ character. Typical examples of use should be as follows: checkerBoard(char = &quot;x&quot;, side = 3) ## ------- ## |x|x|x| ## ------- ## |x|x|x| ## ------- ## |x|x|x| ## ------- Hint: Note that the number of hyphens in a boundary is always one more than twice the value of side. for example, suppose that side is 5. Then to get a row of the required hyphens, all you need is: boundary &lt;- c(rep(&quot;-&quot;, times = 2 * side + 1), &quot;\\n&quot;) cat(boundary, sep = &quot;&quot;) ## ----------- For a single row containing the character itself, you might try: between &lt;- c(&quot;|&quot;, rep(c(char, &quot;|&quot;), times = side), &quot;\\n&quot;) cat(between, sep = &quot;&quot;) ## |x|x|x|x|x| In the example above, the value of char was &quot;x&quot;. Write a function called beerTune() that prints out the complete lyrics to the song Ninety-Nine Bottles of Beer on the Wall. You’ll recall that the song goes like this: 99 bottles of beer on the wall, 99 bottles of beer! Take one down and pass it around: 98 bottles of beer on the wall. 98 bottles of beer on the wall, 98 bottles of beer! Take one down and pass it around: 97 bottles of beer on the wall. … 1 bottle of beer on the wall. 1 bottle of beer! Take it down and pass it around: No more bottles of beer on the wall. Make sure to get the lyrics exactly right. For example, it’s “1 bottle”, not “1 bottles”. Write a function called farmSong() that allows you to vary the lyrics the song about Old MacDonald’s Farm. The function should take two parameters: animal: a character vector of names of the animals on the farm; sound: a character vector, of the same length as the vector animal, giving the sound made by each creature in animal. Neither parameter should have a default value. The function should validate its input, stopping with a helpful message if animal and sound don’t have the same length. Typical examples of use should be as follows: farmSong(animal = c(&quot;cow&quot;, &quot;pig&quot;), sound = c(&quot;moo&quot;, &quot;oink&quot;)) ## Old MacDonald had a farm, ee-i-ee-i-oo! ## And on this farm he had a cow, ee-iee-i-oo! ## With a moo-moo here and a moo-moo there ## Here a moo, there a moo everywhere a moo-moo, ## Old MacDonald had a farm, ee-i-ee-i-oo! ## ## Old MacDonald had a farm, ee-i-ee-i-oo! ## And on this farm he had a pig, ee-iee-i-oo! ## With a oink-oink here and a oink-oink there ## Here a oink, there a oink everywhere a oink-oink, ## Old MacDonald had a farm, ee-i-ee-i-oo! farmSong(animal = c(&quot;cow&quot;, &quot;pig&quot;, &quot;horse&quot;), sound = c(&quot;moo&quot;, &quot;oink&quot;)) ## I need the same number of sounds as there are animals! Note: As the above examples show, you don’t have to worry about getting “a” vs. “an” correct. Recall the function madhavaPI() from Section 3.4.1. Use this function to write a function called madhavaSums() that will do the following: given a number \\(n\\), the function returns a vector consisting of the first \\(n\\) approximations to \\(\\pi\\), using the initial terms of the Madhava series. The function should take a single argument n, whose default value is 10. It should validate the input: if the number entered is not at least 1, then the function should explain to the user that the he/she must enter a positive number, and then stop. Here is an example of how the function should work: madhavaSums(n = -3) ## You need to enter a positive integer. Try again! Here is another example: madhavaSums() # using the default value ## [1] 4.000000 2.666667 3.466667 2.895238 3.339683 2.976046 3.283738 3.017072 3.252366 3.041840 And another: madhavaSums(n = 20) ## [1] 4.000000 2.666667 3.466667 2.895238 3.339683 2.976046 3.283738 3.017072 3.252366 3.041840 ## [11] 3.232316 3.058403 3.218403 3.070255 3.208186 3.079153 3.200366 3.086080 3.194188 3.091624 (*) The Subtraction Game. In this game there are two players, A and B, and a pile of \\(n\\) pebbles. The players take turns removing pebbles from the pile. On each turn, a player can take either one or two pebbles. The players who takes the last pebble wins the game. It turns out that one of the players has a winning strategy. If the initial number of pebbles is a multiple of 3, then player who goes second has a winning strategy, whereas if the initial number of pebbles is not a multiple of 3 then the player who goes second has the winning strategy. The idea for the winning strategy comes from the following observations: If there are 3 pebbles left and it’s the other player’s turn, then you will win. Why? Because after the other player removes pebbles there will be either 1 or 2 pebbles left. In either case you will be able to take the last pebble. If there are 6 pebbles left and it’s the other player’s turn, then you will win. Why? Because after the other player removes pebbles there will be either 4 or 5 pebbles left. In either case on your turn you will be able to reduce the number of pebbles to 3. The game is now in the state of the previous bullet item, where we know that you will win. If there are 9 pebbles left and it’s the other player’s turn, then you will win. Why? Because after the other player removes pebbles there will be either 7 or 8 pebbles left. In either case on your turn you will be able to reduce the number of pebbles to 6. The game is now in the state of the previous bullet item, where we know that you will win. And so on, for 12 left, 15 left, 18 left, etc. As long as the number of pebbles left is a multiple of 3 and it’s the other player’s turn, you will win! In this problem your task is to write a function called subtraction() that will play the Subtraction Game with a user. The function should take two parameters: n: the number of pebbles to begin with. The default value should be 12. userFirst: a logical parameter that indicates whether the user or the computer plays first. The default value should be TRUE, meaning that the user goes first. Each time the computer plays it should announce how many pebbles it removed, and how many are left. When there are no pebbles left the computer should say who won and then quit the function. The function should play optimally for the computer: if at the outset the computer has a winning strategy, then the computer should follow it and win. if at the outset the user has a winning strategy then the computer watch for opportunities to win if the user departs from her winning strategy. "],
["turtle.html", "Chapter 5 Turtle Graphics", " Chapter 5 Turtle Graphics Figure 5.1: Turtles, by xkcd. In this chapter we will practice our knowledge of R—and of basic programming concepts—in the context of a special R-package for graphics: package TurtleGraphics (Cena et al. 2018). Many of the examples from this Chapter are drawn from the Vignette for the package.14 References "],
["basic-movements.html", "5.1 Basic Movements", " 5.1 Basic Movements First, we begin by loading the package: library(TurtleGraphics) In order to create a Turtle Graphics scenario, call the function turtle_init(). You get the plot shown in Figure 5.2. turtle_init() Figure 5.2: Initialized Turtle By default the turtle is positioned in the middle of a square of dimensions 100 units by 100 units. (These dimensions can be changed, as we will see later on.) You can get the turtle’s position at any time: turtle_getpos() ## x y ## 50 50 The turtle also begins facing North. This is considered to be angle 0, as you can tell by asking for the current angle of the turtle: turtle_getangle() ## angle ## 0 Now let’s make the turtle move. If you are following along on your own computer, it’s best to run the lines of code one at a time, so you can see the effect of each command. (If you run multiples lines, you’ll only see the graph produced by the final line.) turtle_forward(dist = 30) turtle_backward(dist = 10) Figure 5.3: First Movements The result appears in Figure 5.3. Next we’ll add a little triangle: turtle_right(90) turtle_forward(10) turtle_left(angle = 135) turtle_forward(14.14) turtle_left(angle = 90) turtle_forward(14.14) turtle_left(angle = 135) turtle_forward(10) Figure 5.4: Adding a Triangle You can see the triangle in Figure 5.4. The turtle is set in the “down” position, so that it leaves a trace out the path that it follows. You can avoid the trace by pulling the turtle “up” with turtle_up(). Whenever you want to restore the tracing, call turtle_down(). See Figure 5.5 for the results of the following code. turtle_up() # stop tracing turtle_right(angle = 90) turtle_forward(dist = 10) turtle_right(angle = 90) turtle_forward(dist = 17) turtle_down() # start tracing again turtle_left(angle = 180) turtle_forward(dist = 34) Figure 5.5: We moved the turtle around in the up position, then put the turtle down and traced out a line segment. You can change the color of the lines your turtle draws: turtle_col(col = &quot;green&quot;) In R here are many, many colors to choose from, and 657 of them even have names. To view them, use:= the colors() function: colors() You can also hide your turtle, and show it again any time you like. See Figure 5.6 for the results of the following code. turtle_hide() turtle_left(angle = 150) turtle_forward(dist = 20) turtle_left(angle = 60) turtle_forward(dist = 20) turtle_show() Figure 5.6: The graph after hiding, moving and showing. Finally, you can choose the type of line your turtle draws, and the width of the line. See Figure 5.7 for the results of the following code. turtle_left(angle = 150) turtle_lty(lty = 4) turtle_forward(dist = 17) turtle_lwd(lwd = 3) turtle_forward(dist = 15) Figure 5.7: Choosing line-type and line-width. Note: you can learn more about lty and lwd with help(par). "],
["making-many-movements-an-introduction-to-looping.html", "5.2 Making Many Movements: An Introduction to Looping", " 5.2 Making Many Movements: An Introduction to Looping Eventually we want to make some complex figures that require many movements on the part of the turtle. In order to make these go faster, we can turn off some of the turtle graphing by wrapping the desired movements in turtle_do(). See Figure 5.8 for the results of the following code. turtle_init() turtle_do({ turtle_move(10) turtle_turn(45) turtle_move(15) }) Figure 5.8: After final movement. (turtle_turn() turns to the left by default.) Of course, for such a small number of movements using turtle_do() does not matter much, but we will practice using it for a bit. How might we make a square? The following code offers one way to do it. See Figure 5.9 for the results. turtle_init() turtle_do({ turtle_move(20) turtle_right(90) turtle_move(20) turtle_right(90) turtle_move(20) turtle_right(90) turtle_move(20) turtle_right(90) }) Figure 5.9: Making a square. This is a bit repetitious. Surely we can take advantage of the fact that there is a clear pattern to the turtle’s movements. A for-loop seems called for, as in the following code to build the square: turtle_init() turtle_do({ for(i in 1:4) { turtle_forward(dist = 20) turtle_right(angle = 90) } }) As we learned in Chapter 4, the more you need to repeat a particular pattern, the more it makes sense to write your code with a loop. Suppose, for example, that you decide to make regular octagons. A regular octagon has eight sides, and you turn 45 degrees after drawing each side. You can do this easily by modifying the square-code as follows (see Figure 5.10 for the results): turtle_init() turtle_do({ for(i in 1:8) { turtle_forward(dist = 20) turtle_right(angle = 45) } }) Figure 5.10: Making an octagon. You can even make many small turns, so that the resulting figure starts to look like a circle (see Figure 5.11 for the results): turtle_init() turtle_setpos(x = 30, y = 50) turtle_do({ for(i in 1:180) { turtle_forward(dist = 1) turtle_right(angle = 2) } }) Figure 5.11: Making a circle. Notice that in the above code the turtle was initially set a bit to the left of center, so that the resulting circle would be situated close to middle of the region. If you allow the index variable to be involved in the computations in the body of the loop then you can start making more complex figures. For example, here is the code for a spiral (see Figure 5.12 for the results): turtle_init(width = 150, height = 150, mode = &quot;clip&quot;) turtle_do({ turtle_right(90) for (i in 1:720) { turtle_left(1) turtle_forward(i/720) } }) Figure 5.12: Using a loop to make a spiral. The turtle turns one degree every time R goes through the loop, but the amount it travels forward (\\(i/720\\)) increases as the index variable i increases. Another thing to notice is that we set the width and height of the region ourselves, so that the spiral would fit into it. We also set mode to clip rather then leaving it at its default value of error. With mode = &quot;clip&quot;, R won’t throw an error message at you when the turtle moves outside of its region. Clip-mode is very handy when you are developing a graph and don’t know in advance precisely where the turtle will go. 5.2.1 Practice Exercises Write a program to make a four-sided star with rays of length 20 each, like this: Write a program to make an eight-sided star with rays of length 30 each, like this: 5.2.2 Solutions to the Practice Exercises In order to make a single ray you walk 20 units forward from a central point, then walk 20 units back to the center. In order to prepare to make the next ray, you turn after you get back to the center. Since you plan on four rays, you must turn \\(360/4 = 90\\) degrees each time. It makes sense to trace each ray once inside a for-loop. Using turtle_do() will make the loop run much faster. Here’s the code: turtle_init(mode = &quot;clip&quot;) turtle_do({ for ( i in 1:4 ) { turtle_forward(20) turtle_backward(20) turtle_left(90) } }) This time in order to make a single ray you walk 30 units forward from a central point, then walk 30 units back to the center. Since you now plan on eight rays, you must turn \\(360/8 = 45\\) degrees each time. Again it makes sense to trace each ray once inside a for-loop. Here’s the code: turtle_init(mode = &quot;clip&quot;) turtle_do({ for ( i in 1:8 ) { turtle_forward(30) turtle_backward(30) turtle_left(45) } }) "],
["writing-turtle-functions.html", "5.3 Writing Turtle Functions", " 5.3 Writing Turtle Functions Once you have designed some shapes that you think you might want to draw again, you should write them up as functions. Here for example, is the code for a function that makes squares: turtle_square &lt;- function(side) { turtle_do({ for (i in 1:4) { turtle_forward(side) turtle_right(90) } }) } Note that the user can vary the length of a side. You would use it like this: turtle_init(mode = &quot;clip&quot;) turtle_square(side = 30) 5.3.1 Practice Exercises Write a function called star8() that makes an eight-sided star with rays of length 20 each. The user should be able to specify the thickness of the rays (think turtle_lwd()). The body of the function should begin with turtle_init() so that the star is always drawn inside a new field. The function should take a single parameter called width, the desired thickness of the rays. Typical examples of use should be as follows: star8(width = 2) star8(width = 10) Modify your star8() function to make a new function called superstar8() that takes an additional parameter called color that allows the user to specify the color of the rays. The default value of color should be &quot;burlywood&quot;. Typical examples of use should be as follows: superstar8(width = 5) superstar8(width = 15, color = &quot;lavenderblush4&quot;) 5.3.2 Solutions to the Practice Exercises From the Practice Exercises of the previous section we are already familiar with making 8-ray stars; we just need to encapsulate the process into a function. Here’s the code: star8 &lt;- function(width) { turtle_init(mode = &quot;clip&quot;) turtle_lwd(lwd = width) turtle_do({ for ( i in 1:8 ) { turtle_forward(20) turtle_backward(20) turtle_turn(45) } }) } Try this: superstar8 &lt;- function(width, color = &quot;burlywood&quot;) { turtle_init(mode = &quot;clip&quot;) turtle_lwd(lwd = width) turtle_col(col = color) turtle_do({ for ( i in 1:8 ) { turtle_forward(20) turtle_backward(20) turtle_turn(45) } }) } "],
["random-moves.html", "5.4 Random Moves", " 5.4 Random Moves So far our turtle has moved in very regular and disciplined ways. It’s time to break the pattern, a bit. R has a quite a few functions to generate numbers that look “random”; we will use some of these functions to make the turtle move about randomly. 5.4.1 Sampling from a Vector You have already met the sample() function (see Section 4.2.1). Let’s take a closer look at it. sample() makes a random choice from a given vector. From the R-help we read that the general form of a call to sample is as follows: sample(x, size, replace = FALSE, prob = NULL) In the above call: x is the vector from which we wish to sample (R refers to it as the “population”); size is the number of random samples we want; replace says whether or not to replace each member of the population after we have sampled it. prob specifies the desired probability for each member of the population to be chosen. A few examples will help us understand how the arguments work: vec &lt;- 1:10 # we&#39;ll sample from this vector sample(vec, 1) ## [1] 7 We got only one number because we set size to 1. Every element in vec had an equal chance of being the element selected. This time we got 7, but if you were to run the function again for yourself your results would probably be different. Let’s sample 10 numbers from vec: sample(vec, 10) ## [1] 1 9 10 5 4 3 2 7 8 6 Because replace was left at its default value of FALSE, R did not replace numbers after pulling them from the vec. After each sample, the remaining numbers all had the same chance to be picked next. Setting size to the length of x and keeping replace = FALSE therefore has the effect of randomly shuffling the elements of x. Of course when replace = FALSE any attempt to sample more than the number of elements of vec will result in an error: sample(vec, 11) Error in sample.int(length(x), size, replace, prob) : cannot take a sample larger than the population when &#39;replace = FALSE&#39; When we set replace = TRUE then each selected element is returned to the population. At any stage, the chance for a given member of the population to be the one selected next is the same—no matter how many times that member has already been selected. Thus, when replace = TRUE you are liable to see repeats: sample(vec, 20, replace = TRUE) ## [1] 5 3 5 5 8 8 9 10 5 9 4 5 6 4 10 7 1 8 3 5 When the prob parameter is left at its NULL value, R gives each member of the population the same chance to be the member that is selected. It is possible to adjust the probabilities of selection by setting prob to a vector of probabilities (one for each corresponding member of x). Thus, suppose we want to select 20 numbers from vec, according to the following the probabilities: 5% chance of selection, for each number from 1 to 8; 30% chance for 9 to be selected; 30% chance for 10 to be selected. Then we can call sample() like this: sample(vec, 20, replace = TRUE, prob = c(rep(0.05, 8), 0.30, 0.30)) ## [1] 9 1 9 10 9 6 8 9 4 7 10 10 9 2 6 9 5 9 10 10 Notice the majority of 9’s and 10’s: this was fairly likely to occur since each selection had a 60% chance of turning out to be 9 or 10. 5.4.2 Application: a Bouncing Turtle Let’s apply sample() to design a scenario in which the turtle moves a fixed amount at each step, but the direction—north, east, south, or west—is completely random. When the turtle reaches the boundary of its domain, however, we would like it to “bounce back”: i.e., take a step in the direction opposite to the step that brought it to the boundary. We will also query the user prior to each step, asking if he/she wants to see another move. This not only allows the user to decide when to end the scenario; it also permits the user to see where the turtle is after each step. One possible implementation is as follows: turtle_bounce &lt;- function(side = 60, step= 10) { if ( (side/2) %% step != 0 ) { stop(&quot;Side-length divided by two must be a multiple of step.&quot;) } bounds &lt;- c(0, side) turtle_init(side, side, mode = &quot;clip&quot;) origin &lt;- turtle_getpos() cp &lt;- turtle_getpos() repeat { move &lt;- readline(prompt = &quot;Go Again? (enter q to quit): &quot;) if ( move == &quot;q&quot;) break x &lt;- cp[&quot;x&quot;] y &lt;- cp[&quot;y&quot;] if (x %in% bounds | y %in% bounds) { angle &lt;- 180 } else { angle &lt;- sample(c(0,90,180,270), 1) } turtle_right(angle) turtle_forward(step) cp &lt;- round(turtle_getpos(), 0) print(cp) } cat(&quot;All done!&quot;) } Play the game a few times, to get a feel for how it works: turtle_bounce(60, 15) Let’s examine the code a bit more closely. The definition indicates that there are two parameters: side and step. The side parameter gives the dimensions of the Turtle’s field. Thus if side were set to 60—which is the default—then the field would be a 60-by-60 square, with the origin \\((0,0)\\) in at lower-left corner and the point \\((60, 60)\\) at the upper-right corner. When the turtle is initialized it will appear in the middle of the square, at the point \\((30, 30)\\). step specifies how many units the turtle will move at each step. In this analysis we will assume that step is set to 15. Inside the function, we begin with a bit of input-validation: if ( (side/2) %% step != 0 ) { stop(&quot;Side-length divided by two must be a multiple of step.&quot;) } Remember that the turtle will start at \\((\\texttt{side}/2, \\texttt{side}/2)\\) and will move step each time. If \\(\\texttt{side}/2\\) is not evenly divisible by step then the turtle would be able to go from inside its field to outside in a single step. We don’t want that to happen so we stop the user if the remainder after dividing \\(\\texttt{side}/2\\) by side is anything other than zero. If the input is OK, then we set up a vector bounds that records the smallest and largest possible values for the \\(x\\) and \\(y\\) coordinates of the turtle: bounds &lt;- c(0, side) Next, we initialize the turtle in the middle of the field and record its initial position in the vector cp: turtle_init(side, side, mode = &quot;clip&quot;) origin &lt;- turtle_getpos() cp &lt;- turtle_getpos() (You can think of cp as short for: “current position”.) Next, we enter a repeat-loop. Inside the loop we begin with: move &lt;- readline(prompt = &quot;Go Again? (enter q to quit): &quot;) if ( move == &quot;q&quot;) break x &lt;- cp[&quot;x&quot;] y &lt;- cp[&quot;y&quot;] We first asked the user if she wanted to quit. If she enters “q” then we’ll break out of the loop and end the scenario. If she enters anything else (including just pressing Enter) then we record the \\(x\\) and \\(y\\) coordinates of the turtle’s current position in the vectors x and y respectively. Our next task is to determine how the turtle should move: if (x %in% bounds | y %in% bounds) { angle &lt;- 180 } else { angle &lt;- sample(c(0,90,180,270), 1) } If the turtle is at a boundary (either x equal to 0 or 60 or y equal to 0 or 60) then we need to “bounce back”. This corresponds to making the turtle turn right by 180 degrees and then step. On the other hand if the turtle is not at a boundary then the direction of the turtle should be random, so we should have it turn right by either 0, 90, 180 or 270 degrees, with each possibility being equally likely. This is accomplished with the above call to the sample() function. Having determined the amount by which to turn prior to the next step, we then have the turtle turn that amount and take the step: turtle_right(angle) turtle_forward(step) Finally, we set cp to the new position of the turtle, and print that position out to the console for the user to see: cp &lt;- round(turtle_getpos(), 0) print(cp) Note that we rounded off the position to the nearest while number. This was done because the authors of the TurtleGraphics package use floating point arithmetic for their numerical operations, so sometimes the computed positions differ from whole numbers by a very tiny amount. We then repeat the loop. 5.4.3 Uniform Random Numbers sample() picks an element from a finite population. Sometimes, though, we want R to give the impression that it has picked a real number at random out of a range of real numbers. This can be accomplished with the runif() function. A call to runif() looks like this: runif(n, min = 0, max = 1) The idea is that R will produce n real numbers that have the appearance of having been drawn randomly from the interval of real numbers whose lower and upper bounds are specified respectively by min and max. Thus, to get 10 “random” numbers that all lie between 0 and 1, you can leave min and max at their defaults and ask for: runif(10) ## [1] 0.646902839 0.394225758 0.618501814 0.476891136 0.136097186 0.067384386 0.129152617 ## [8] 0.393117930 0.002582699 0.620205954 5.4.4 Pseudo-Randomness and Setting a Seed It’s important to point out that R doesn’t generate truly random numbers.15 After all, R simply runs a computer which operates according to a set of completely-specified steps. Thus the random data generated by R and by other computer languages is often called pseudorandom. Although the functions for random-number generation have been carefully designed so as to follow many of the statistical laws we associate with randomness in nature, all of the pseudo-random output is determined by an initial value and a deterministic number-generating algorithm. We actually have the ability to set the pseudorandom data ourselves. This is called setting the random seed. From any specified seed, the result of calls to R’s random-data functions will be completely determined (although—just as in the case of “real” randomness—the output will still probably “look” random). The set.seed() function will fix the random output. Try running the following two lines of code more than once: set.seed(2025) runif(10) ## [1] 0.7326202 0.4757614 0.5142159 0.4984323 0.7802845 0.5042522 0.8984003 0.1278527 0.6446721 ## [10] 0.5695311 You will get the same output every time. If you change the argument of set.seed() to some other integer the output will probably change—but it will stay the same when you run the code again from that that new seed. 5.4.5 Application: a Drunken Turtle We will now modify the previous scenario so that the turtle’s motion will be almost completely random. Even though it will take the same-size step every time, the angle at which it steps will be completely random: any real number of degrees from 0 to 360. We will also show the user the position of the turtle at each step, and use the “distance formula” from high-school geometry to compute and display the current distance of the turtle from the place where it started. turtle_drunk &lt;- function(side, step) { turtle_init(side, side, mode = &quot;clip&quot;) # save (side/2, side/2), the turtle&#39;s initial position: initial &lt;- turtle_getpos() repeat { move &lt;- readline(prompt = &quot;Go Again? (enter q to quit): &quot;) if ( move == &quot;q&quot;) break # pick a random angle to turn by: angle &lt;- runif(1, min = 0, max = 360) turtle_left(angle) turtle_forward(step) # get new position, make it the current position: cp &lt;- turtle_getpos() # print to console: print(cp) # determine distnce from initial position (round to 3 decimals): distance &lt;- round(sqrt((cp[1] - initial[1])^2 + (cp[2] - initial[2])^2),3) # prepare message to console,and print it: message &lt;- paste0(&quot;Distance from starting point is: &quot;, distance) cat(message) } cat(&quot;All done!&quot;) } Try the game once or twice: turtle_drunk(100, 5) It is natural to wonder how likely the turtle is to wander back close to where it started, and to wonder how often that will happen. We will address questions like these in Chapter 6. 5.4.6 Practice Exercises Many of these exercises don’t deal directly with turtles, but instead drill you on the sample() and runif()` functions. Write a call to the sample() function so that it will pick a whole number at random from 1 to 10. Each number should have the same chance to be selected. You have a large bag of M&amp;Ms. You reach in an grab a few. You have an equal to chance to grab any number of M&amp;Ms from 1 to 10. (You can’t grab more than 10, and you can’t grab none.) Write a one-line command that expresses how many you grab. Write a call to the sample() function that will pick five numbers at random from the whole numbers from 1 to 10. On each pick, each of the ten numbers should have a 1-in-10 chance to be selected. Write a call to the sample() function that will pick five numbers at random from the whole numbers from 1 to 10. It should not be possible to get the same number twice. Write a call to the sample() function that scrambles the whole numbers from 1 to 10 in a random order. Write a call to the sample() functions that randomly re-orders the lowercase letters of the English alphabet. The function color() produces a character vector of the named colors that R is prepared to draw. Run it at the Console: colors() How many named colors are there? Let’s let R find out for us: length(colors()) ## [1] 657 Write a call to the sample() function that will pick a single named color at random. Write a call to runif() that will produce a single random real number between 0 and 1. Write a call to runif() that will produce 20 random real numbers between 0 and 1. Write a call to runif() that will produce 30 random real numbers, each of them between 10 and 15. You enter a forest where there are many sticks on the ground. Each of them is equally likely to be anywhere between 0 and 10 feet long. You pick up five sticks at random. Write a one-line R-command that produces the length of shortest stick that you pick up. Write a function called randomColor8() that produces an 8-ray star. Here are the specs: The user should be able to determine the type of the line (think turtle_lty()). Each ray should have a 30% chance of being red and a 70% chance of being blue. In addition, the length of each ray should be a random real number between 10 and 40. The function should take a single parameter called type that the user can set to determine the line-type for the rays; its default-value should be 1. The width of each ray should be 5. Typical examples of use should be as follows: randomColor8() randomColor8(type = 3) 5.4.7 Solutions to the Practice Exercises sample(1:10, size = 1) The previous function call will do: sample(1:10, size = 1). sample(1:10, size = 5, replace = TRUE) sample(1:10, size = 5, replace = FALSE) sample(1:10, size = 10, replace = FALSE) sample(letters, size = length(letters), replace = FALSE) sample(colors(), size = 1) runif() runif(20) runif(30, min = 10, max = 15) min(runif(5, min = 0, max = 10)) Try this: randomColor8 &lt;- function(type = 1) { allowedColors &lt;- c(&quot;red&quot;, &quot;blue&quot;) turtle_init(mode = &quot;clip&quot;) turtle_lty(lty = type) turtle_lwd(lwd = 5) turtle_do({ for ( i in 1:8 ) { turtle_col(col = sample(allowedColors, size = 1, prob = c(0.3, 0.7))) rayLength &lt;- runif(1, min = 10, max = 40) turtle_forward(rayLength) turtle_backward(rayLength) turtle_left(45) } }) } Indeed, philosophers of mathematics debate what randomness “really” is.↩ "],
["more-complex-turtle-graphs.html", "5.5 More Complex Turtle Graphs", " 5.5 More Complex Turtle Graphs Simple instructions, when combined with looping, can produce quite complex patterns. Consider the following process (with results shown in Figure 5.13): turtle_init(1000, 1000, mode = &quot;clip&quot;) turtle_do({ turtle_setpos(600,400) turtle_right(90) for (i in 1:2000) { turtle_right(i) turtle_forward(sqrt(i)) } }) Figure 5.13: Galactic Zany! You might enjoy figuring out why this pattern occurs. As you ponder this, it might help to construct a set of “ragged” spirals with somewhat larger steps, and pause at each step. Code like the following might be useful:16 turtle_init(1000, 1000, mode = &quot;clip&quot;) turtle_do({ i &lt;- 1 turtle_right(90) repeat { bidding &lt;- readline(&quot;Proceed? (Enter q to quit) &quot;) if ( bidding == &quot;q&quot;) break turtle_right(i) turtle_forward(2*sqrt(i)) cat(paste0(&quot;Turned &quot;, i, &quot; degrees,\\n&quot;)) cat(paste0(&quot;stepped forward &quot;, round(2*sqrt(i), 3), &quot; units.\\n&quot;)) cat(&quot;Turtle&#39;s current angle is: &quot;, turtle_getangle(), &quot; degrees.\\n&quot;) i &lt;- i + 20 } cat(&quot;All done!&quot;) }) Also don’t forget that every 360 degrees is a full turn around the circle, so when the turtle’s angle is, say 720 degrees, it’s the same as an angle of 360 degrees which is the same as an angle of 0 degrees. All three angles amount to the same direction.↩ "],
["artistic-turtles.html", "5.6 Artistic Turtles", " 5.6 Artistic Turtles In the Practice Exercises (see Section 5.4.6) you met the colors() function. Let’s have the Turtle put it to good use. First of all, we might ask the Turtle to show us a sample of a given color: turtle_show_color &lt;- function(color) { cat(&quot;I&#39;m drawing a &quot;, color, &quot; square!&quot;, sep = &quot;&quot;) turtle_init() turtle_col(color) turtle_lwd(50) turtle_do({ turtle_setpos(x = 30, y = 30) turtle_square(40) }) } Note the very thick lines specified above: turtle_lwd(50). Our turtle will draw a square with very thick sides that have the desired color. Let’s ask for burlywood. The resulting color-swatch is shown in Figure 5.14. turtle_show_color(&quot;burlywood&quot;) Figure 5.14: I’m drawing a burlywood square! Feel free to ask for a random color. The result of the call below is shown in Figure 5.15. turtle_show_color(sample(colors(), size = 1)) Figure 5.15: I’m drawing a palegreen2 square! The function below is the Turtle’s attempt to dash off a quick imitation of the work of Jackson Pollack, the great American abstract expressionist: turtle_quick_pollack &lt;- function(strokes) { turtle_init(mode = &quot;clip&quot;) turtle_lwd(50) colorsUsed &lt;- character(strokes) turtle_do({ for ( i in 1:strokes ) { randomColor &lt;- sample(colors(), size = 1) turtle_col(randomColor) colorsUsed[i] &lt;- randomColor randomAngle &lt;- runif(1, min = 0, max = 360) turtle_left(randomAngle) turtle_forward(10) } }) cat(&quot;Behold my masterpiece! It was painted with:\\n&quot;) print(colorsUsed) } Note that the colors used are output to the console. Let’s have it make a picture with 50 strokes made by random-colored brushes. The resulting painting appears as Figure 5.16 turtle_quick_pollack(50) Figure 5.16: Behold my masterpiece! ## Behold my masterpiece! It was painted with: ## [1] &quot;lightskyblue3&quot; &quot;gray12&quot; &quot;grey62&quot; &quot;cyan&quot; &quot;gray77&quot; ## [6] &quot;lightpink3&quot; &quot;sandybrown&quot; &quot;gray57&quot; &quot;darkolivegreen2&quot; &quot;snow3&quot; ## [11] &quot;grey43&quot; &quot;sandybrown&quot; &quot;grey79&quot; &quot;orangered1&quot; &quot;blanchedalmond&quot; ## [16] &quot;gray95&quot; &quot;mediumpurple2&quot; &quot;darkgoldenrod4&quot; &quot;purple&quot; &quot;dodgerblue2&quot; ## [21] &quot;grey93&quot; &quot;violetred&quot; &quot;steelblue2&quot; &quot;grey71&quot; &quot;gold4&quot; ## [26] &quot;grey64&quot; &quot;goldenrod2&quot; &quot;brown3&quot; &quot;orangered2&quot; &quot;gray&quot; ## [31] &quot;gray52&quot; &quot;darkgoldenrod3&quot; &quot;grey70&quot; &quot;lightslategrey&quot; &quot;aquamarine4&quot; ## [36] &quot;grey71&quot; &quot;grey5&quot; &quot;darkslategray&quot; &quot;gray19&quot; &quot;ivory1&quot; ## [41] &quot;deeppink&quot; &quot;mediumorchid&quot; &quot;palevioletred1&quot; &quot;wheat2&quot; &quot;tan&quot; ## [46] &quot;springgreen&quot; &quot;thistle&quot; &quot;chartreuse3&quot; &quot;grey9&quot; &quot;royalblue4&quot; "],
["glossary-3.html", "Glossary", " Glossary Pseudo-random Numbers A sequence of numbers generated by a computer procedure designed to make the sequence appear to follow statistical laws associated with random processes in nature. "],
["exercises-3.html", "Exercises", " Exercises Write a function called turtle_gon() that draws a regular polygon. The user should be able to specify the side-length and the number of sides. Start with turtle_init() and use your function to draw a regular dodecagon (twelve sides) with each side having a side length of 15 units. Your figure should not stray outside of the turtle’s field, so you may have to adjust the position of your turtle a bit prior to calling your function. Write a function called turtle_star() that can make stars like the ones in Figure 5.17. Here are the required parameters: n: the number of rays in a star (default should be 6); length: the length of the rays (default should be 20); color: the color of the rays (default should be &quot;red&quot;); type: the line-type of the rays (default should be 1); width: the line-width of the rays (default should be 1). Figure 5.17: Sample Stars Starting with turtle_init(), use your function to create a star with 10 rays, each of length 20 units. The lines should be red and dashed. I’ll leave the thickness up to you. Make a new star function turtle_rstar() in which the lengths of the rays are not determined by the user but instead vary randomly from 5 to 25 units, as in Figure 5.18: Figure 5.18: A star with rays of random lengths. There is no longer a legnth parameter, but the names and default-values for the other parameters should be the same as in the previous exercise. Starting from turtle_init(50,50) make a random star with 20 rays and a line-thickness of 3. Other parameters should be left at their default-values. Hint: You’ll probably use a loop to draw each ray of the star. As you go through the loop, get a random ray-length using the runif() function: randomLength &lt;- runif(1, min = 5, max = 25) Then have the turtle make the ray by moving forward and backward by that amount. Make a new star function turtle_rstarColors() that behaves like turtle_rstar() except that instead of being determined by the user the ray-color varies randomly from one ray to another, as in Figure 5.19: Figure 5.19: A star with rays of random lengths and random colors. Each ray should have a color drawn randomly from the vector of all colors given by colors(). Starting from turtle_init(50,50) make a random star with 20 rays and a line-thickness of 6. Other parameters should be left at their default-values. Hint: You’ll probably use a loop to draw each ray of the star. As you go through the loop, get a new random color like this: randomColor &lt;- sample(colors(), size = 1) Then set the turtle’s color accordingly: turtle_col(col = randomColor) (*) Our turtle_quick_pollack() function has successive strokes attached to each other. However, Jackson Pollack famous “drip” style involved placing brush-strokes at seemingly random locations on the canvas—successive strokes weren’t placed together. Modify our Pollack-painter function so that each new stroke appears as a random location inside the canvas. If you really get into it, research colors in R and try to come up with your own scheme for randomizing colors. "],
["simulation.html", "Chapter 6 Simulation", " Chapter 6 Simulation Figure 6.1: A monkey typing randomly manages to type out a line of Shakespeare. What is the chance that the monkey would produce this particular line? Source: http://www.gloryofkings.com/?p=189. "],
["probability-and-random-variables.html", "6.1 Probability and Random Variables", " 6.1 Probability and Random Variables Your favorite college basketball team is in the NCAA Tournament. What is the chance that it will make the Final Four? An insurance company provides flood insurance to homeowners. How much can the company expect to pay out in insurance claims in the coming year? What is the chance of a large asteroid striking our planet in the next ten years? in the next ten million years? All of the above questions involve random processes—some of them rather complex. It is the aim of this Chapter to apply our knowledge of vectors, functions and flow control to give approximate answers to questions involving chance processes like these. Sometimes we will be interested in finding the probability that an event of interest occurs: for example, the event that your team makes the final Four, or the event that the Earth is struck by a large asteroid sometime in the next ten years. One popular definition of probability goes as follows: If \\(E\\) is an event, then the probability that \\(E\\) occurs is the long-term proportion of times that the event occurs, if we could repeat the random process many, many times. To be more precise, imagine that you can repeat the random process \\(n\\) times. (Imagine that your team gets into the NCAA Tournament \\(n\\) times, for example.) Each time, the event of interest will either occur or not occur. Count the number of times that the event occurs. Then divide by \\(n\\). You now have the proportion of times that it occurred. Now imagine that \\(n\\) gets larger and larger. Our intuition says that the proportion of times that the event occurs will stabilize at some number between 0 and 1. This number is the probability that the event occurs. occurs. We will also concern ourselves with random variables. A random variable is simply a number whose value is determined by the outcome of a chance process. The amount that the insurance company will pay out in the next year is an example of a random variable: its value depends on a complex chance process—how many homeowners experience a flood, how damaging each flood is, etc. When it comes to random variables, we are often interested in what it might turn out to be on average. That is, suppose we could repeat the random process many, many times—say \\(n\\) times, where \\(n\\) is some large number. (Suppose that we could observe the insurance company for many, many years, with each year being the same in terms of how many people are insured, how much their houses are worth, what the climate is like, and so on.) Each time the process is repeated, we get a value for the random variable. We end up with \\(n\\) values. Now add up these values and divide by \\(n\\). We have computed their average—the mean, as it is properly called. Now imagine that \\(n\\) could be larger and larger, without bound. The expected value of the random variable is the number that this average converges to. In other words, the expected value of a random variable is what we expect to get on average, in the long run, if we could repeat the random process that produces the value many, many times. "],
["monte-carlo-simulation.html", "6.2 Monte Carlo Simulation", " 6.2 Monte Carlo Simulation Our definitions of probability and expected value both involved a limiting notion, namely: what would happen if you could somehow repeat the random process more and more times, without a bound on the number of repetitions. Accordingly, even if we find that we are unable to compute a probability or an expected value exactly with mathematics, we can still attempt to estimate it by making the computer repeat the random experiment many times, keeping track of the result of the experiment each time. This technique is known as Monte Carlo simulation, after the famous Monte Carlo casino in the Principality of Monaco. In this section we will employ Monte Carlo simulation to estimate probability and expected value in a couple of simple examples. 6.2.1 Estimating a Probability Consider a box that holds ten tickets. Three of them are labeled with the letter “a”; the rest are labeled “b”: tickets &lt;- c(rep(&quot;a&quot;, 3), rep(&quot;b&quot;, 7)) tickets ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; We plan to draw one of these tickets at random from the box, with each ticket having the same chance to be the ticket selected. Three of the ten tickets are a’s, so our intuition says that the probability of selecting an “a” ticket is 3 out of 10, or 0.3. Let’s use Monte Carlo simulation to estimate the probability, and see if we get something close to 0.3. In order to set up the simulation, we need a device for repeating the random process as many times as we would like. At each repetition, the outcome of the chance process should not depend on previous outcomes. We can accomplish this by using R s sample() function on the tickets variable. For example, if we would like to repeat the process of selecting a ticket twenty times, we could write the following code: sims &lt;- sample(tickets, size = 20, replace = TRUE) sims ## [1] &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; Notice that we set replace to TRUE. This was important, since it guarantees that at each selection there are three “a”’s and seven “b”’s in the box, keeping the chance of getting an “a”-ticket the same each time. We can summarize the results in a table using R’s table() function: table(sims) ## sims ## a b ## 9 11 Of course we don’t care so much about the number of times we got an “a”-ticket. Instead we care about the proportion of times we did so. In order to convert the numbers in a table to proportions we can make the table an argument for the function prop.table(): prop.table(table(sims)) ## sims ## a b ## 0.45 0.55 Based on twenty repetitions of the random process, our estimate of the chance an “a”-ticket is 0.25. That’s not so close to the true chance of \\(1/3\\). In order to obtain a more accurate estimate, we should increase the number of repetitions of the random process. Let’s try again, with ten thousand repetitions: sims &lt;- sample(tickets, size = 10000, replace = TRUE) prop.table(table(sims)) ## sims ## a b ## 0.2952 0.7048 Our estimate is now a lot closer to the actual value of the probability. 6.2.2 Estimating an Expected Value Imagine that you are about to play the following game: you will flip a fair coin twice. If you get Tails both times, you lose a dollar. If you get exactly one Head, nothing happens. If you get Heads both times, you win two dollars. Let \\(W\\) be the number of dollars you will win. \\(W\\) is a clearly a random variable: it’s a number whose value—either -1, 0 or 2—depends on the outcome of the random process of flipping the fair coin twice. What is the expected value of \\(W\\)? If we think about the probabilities involved then we can come up with a candidate for the expected value. When you flip a fair coin twice, there are four equally likely outcomes: Tails and then Tails (\\(W = -1\\)) Tails and then Heads (\\(W = 0\\)) Heads and then Tails (\\(W = 0\\)) Heads and then Heads (\\(W = 2\\)) Hence you have: The chance that \\(W=-1\\) is 0.25. The chance that \\(W=0\\) is 0.50. The chance that \\(W=2\\) is 0.25. Hence the expected value should be the weighted average: \\[0.25 \\times -1 + 0.50 \\times 0 + 0.25 \\times 2.\\] This works out to 0.25, or 25 cents. We would like to see if Monte Carlo simulation can render an estimate that is close to this value. For a simple game like ours where there are only a few possible outcomes for the random variable, it is still a good idea to use sample() to simulate the random process of playing the game. We only need to provide a vector of possible values for \\(W\\) to sample from, and a vector of probabilities for obtaining each of those possible values. The following code illustrates how we might simulate playing the game ten times: w &lt;- c(-1, 0, 2) pw &lt;- c(0.25, 0.50, 0.25) winnings &lt;- sample(w, size = 10, replace = TRUE, prob = pw) winnings ## [1] -1 2 0 2 0 0 0 0 -1 2 The Monte Carlo estimate of the expected value of \\(W\\) is just the average of the winnings in our simulations: mean(winnings) ## [1] 0.4 Of course, with such a small number of repetitions of the game we cannot expect the Monte Carlo estimate to be very accurate. Let’s try again, but with ten thousand repetitions: winnings &lt;- sample(w, size = 10000, replace = TRUE, prob = pw) mean(winnings) ## [1] 0.2435 Yes, that’s much closer to our mathematically-computed value! By the way, R can easily compute the weighted average itself: sum(w*pw) ## [1] 0.25 6.2.3 The Law of Large Numbers In our Monte Carlo simulations so far, we have seen that the more times we repeat the underlying random process, the closer our estimate is likely to be to the actual value, no matter whether we were estimating the probability of an event or an expected value for a random variable. This is no accident: in fact, it is a consequence of a theorem in the subject of probability that is known as the Law of Large Numbers. We do not possess the mathematical machinery necessary to state the Law precisely—much less prove it—but we can take the rough statement given here as an assurance that the more repetitions we include in our simulation, the more accurate the resulting estimate is liable to be. 6.2.4 Practice Exercises Consider the following game: you roll a fair die. If you get one or two spots, then you lose a dollar. If you get three, four, or five spots then nothing happens. If you get six spots then you win three dollars. You would like to know how much money you can expect to win per play of the game, on average. Write a function called diceGameSim() that will help you answer the question. The function should take the following parameter: reps: the number of times to repeat the simulation. The default value should be 10000. The function should return an estimate of the expected value of the game. You command a Klingon vessel, and you are shooting photon torpedoes at the Starship USS Enterprise. Every torpedo you fire has a strength \\(s\\) that is a random real number between 0 and 12. If the strength of the torpedo is less than or equal to 5, then the Enterprise’s shields will ward off any damage. However, if the strength \\(s\\) exceeds 5, then the damage inflicted on the Enterprise will be \\(12-s\\) units. What is the expected amount of damage done to the Enterprise, per shot? Write a function called photonTorpedoSim() that estimates the expected damage. The function should take the following parameter: reps: the number of times to repeat the process of firing at the Enterprise. The default value should be 10000. The function should return the estimated expected value. 6.2.5 Solutions to the Practice Exercises Here’s the code: diceGameSim &lt;- function(reps) { w &lt;- c(-1, 0, 3) pw &lt;- c(2/6, 3/6, 1/6) winnings &lt;- sample(w, size = reps, replace = TRUE, prob = pw) mean(winnings) } Let’s try it out: set.seed(3838) diceGameSim(reps = 100000) ## [1] 0.16548 Our estimate, based on one hundred thousand repetitions of the game, is that you can expect to win about 16.55 cents per game. (In fact the exact expected value is \\(1/6\\) of a dollar.) Here’s the code, if you use the pmax() function: photonTorpedoSim &lt;- function(reps) { strengths &lt;- runif(reps, min = 0, max = 12) damage &lt;- pmax(0, strengths - 5) mean(damage) } Let’s try it out: set.seed(3838) photonTorpedoSim(reps = 100000) ## [1] 2.043227 You can expect to do about 2.04 points worth of damage per shot. (In fact the exact expected value is \\(49/24 \\approx 2.04167\\).) Here’s the code if you used a loop instead: photonTorpedoSim &lt;- function(reps) { damage &lt;- numeric(reps) for (i in 1:reps) { strength &lt;- runif(1, min = 0, max = 12) if (strength &gt; 5) { damage[i] &lt;- strength - 5 } else { damage[i] &lt;- 0 } } mean(damage) } "],
["triangle-chance.html", "6.3 Example: Chance of a Triangle", " 6.3 Example: Chance of a Triangle In the examples considered so far, intuition or a simple calculation suggests what the exact value of the probability or expected value should be. The true power of the Monte Carlo simulation method shines forth in situations where it is difficult or impossible to compute a value mathematically. Let’s revisit an example from Section 4.2.4, where we considered whether or not three segments could be put together to form a triangle. We developed the following function to determine, from the lengths of each segment, whether or not a triangle is possible: isTriangle &lt;- function(x, y, z) { (x + y &gt; z) &amp; (x +z &gt; y) &amp; (y + z &gt; x) } Recall also that this function applied to vectors of any length, so we can use it to decide about many triples of segments at once. Let’s now inject some chance variation into the situation. Suppose that you have a stick that is one unit in length: one foot, one meter, one yard—whatever. You plan to break the stick at two randomly selected points. Breaking the stick will yield three pieces. You wonder: what is the chance that these three pieces can form a triangle? In an advanced probability course you can show that the probability of a triangle is exactly \\(1/4\\). Here we would like to estimate the probability with Monte Carlo simulation. In order to carry out the simulation, we will need to develop code that produces a pair of break-points, any number of times that we like—let’s think about ten times, to start. This is not so difficult if we use the runif() function: x &lt;- runif(10) # the first breaks y &lt;- runif(10) # the second breaks Next we must compute—for each pair of breaks—the lengths of the three segments that are produced. If we knew that the x break was always less than the y break, this would be easy: the leftmost piece would be x units long; the middle piece would be y minus x units long; the rightmost piece would be 1 minus y units long. The problem is that a given element of the vector y can easily be less than than corresponding element of the vector x. When that happens, the pieces won’t be as described in the bullet-ed items above. We can solve this problem with the pmin() and pmax() functions that were introduced in Section 2.7.1.5: a &lt;- pmin(x, y) b &lt;- pmax(x, y) side1 &lt;- a # leftmost side2 &lt;- b - a # middle side3 &lt;- 1 - b # rigttmost It is useful to write a helper-function that starts from the breaks, computes the sides, and then decides whether they form a triangle: makesTriangle &lt;- function(x, y) { a &lt;- pmin(x, y) b &lt;- pmax(x, y) side1 &lt;- a side2 &lt;- b - a side3 &lt;- 1 - b isTriangle(x = side1, y = side2, z = side3) } Let’s try it our for our repetitions Table 6.1 shows the results. Based on our ten repetitions, we would estimate the probability of a triangle as \\(4/10\\). Table 6.1: Results of ten repetitions of breaking a unit length at two random points to form three segments. x y side1 side2 side3 triangle 0.6469028 0.7644140 0.6469028 0.1175112 0.2355860 FALSE 0.3942258 0.7438358 0.3942258 0.3496100 0.2561642 TRUE 0.6185018 0.8261657 0.6185018 0.2076639 0.1738343 FALSE 0.4768911 0.4227291 0.4227291 0.0541621 0.5231089 FALSE 0.1360972 0.4092877 0.1360972 0.2731905 0.5907123 FALSE 0.0673844 0.5396926 0.0673844 0.4723082 0.4603074 TRUE 0.1291526 0.9607224 0.1291526 0.8315698 0.0392776 FALSE 0.3931179 0.6535573 0.3931179 0.2604394 0.3464427 TRUE 0.0025827 0.5467153 0.0025827 0.5441326 0.4532847 FALSE 0.6202060 0.2660636 0.2660636 0.3541424 0.3797940 TRUE Interestingly, R can compute the proportion of times that a triangle was formed, directly from the logical vector triangle. Look at the following code: sum(triangle) ## [1] 4 mean(triangle) ## [1] 0.4 When we ask R to add the elements of a logical vector, it coerces the Boolean values to numbers: TRUE becomes 1 and FALSE becomes 0. Summing the numbers is then equivalent to counting how many times TRUE appeared in triangle. Taking the mean is equivalent to computing the proportion of TRUEs in triangle. We would like, of course, to simulate breaking the unit length many times, and we would like to be able to choose easily—without a lot of fuss in coding—the number of repetitions. It makes sense, therefore, to write a simulation function that will do our work for us: triangleSim &lt;- function(reps = 10000 ) { cut1 &lt;- runif(reps) cut2 &lt;- runif(reps) triangle &lt;- makesTriangle(cut1, cut2) cat(&quot;The proportion of triangles was &quot;, mean(triangle), &quot;.\\n&quot;, sep = &quot;&quot;) } Now that we think about it, it might also be nice to have the option to view a table of the results, along with the estimate of the probability: triangleSim &lt;- function(reps = 10000, table = FALSE ) { cut1 &lt;- runif(reps) cut2 &lt;- runif(reps) triangle &lt;- makesTriangle(cut1, cut2) if ( table ) { cat(&quot;Here is a table of the results:\\n&quot;) print(table(triangle)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of triangles was &quot;, mean(triangle), &quot;.\\n&quot;, sep = &quot;&quot;) } Let’s give our function a try, using the default of ten thousand repetitions and asking for a table of results: triangleSim(table = TRUE) ## Here is a table of the results: ## triangle ## FALSE TRUE ## 7466 2534 ## ## The proportion of triangles was 0.2534. As we would expect, our estimate of the probability of a triangle is pretty close to \\(1/4\\), the value that is known to experts in probability. 6.3.1 Setting a Seed There are further possibilities for refining the simulation function. We know that it can be a good idea to set a seed for R’s random-number generator. When you do this you still get random-looking results, but they will be the same results no matter how often you call the simulation function. In that way others who have access to your function can “reproduce” the results you got, thus assuring themselves that you weren’t making anything up. Let’s add a seed parameter to our simulation function: triangleSim &lt;- function(reps = 10000, table = FALSE, seed ) { set.seed(seed) cut1 &lt;- runif(reps) cut2 &lt;- runif(reps) triangle &lt;- makesTriangle(cut1, cut2) if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(triangle)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of triangles was &quot;, mean(triangle), &quot;.\\n&quot;, sep = &quot;&quot;) } This is all very well, but if for some reason you desire to have the function produce different results with every call, you have to come up with the seed yourself. It would be nice to have the option to call your function without having to provide a seed. This is not difficult to accomplish. We’ll set the default value for seed to be NULL. Then when the function begins we’ll check the value of seed. If it is not NULL, then the user has provided a seed, and we’ll use that. Otherwise, we’ll let R grab pseudo-random numbers however it likes. triangleSim &lt;- function(reps = 10000, table = FALSE, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } cut1 &lt;- runif(reps) cut2 &lt;- runif(reps) triangle &lt;- makesTriangle(cut1, cut2) if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(triangle)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of triangles was &quot;, mean(triangle), &quot;.\\n&quot;, sep = &quot;&quot;) } 6.3.2 Program Development Think about how we developed the triangleSim() function. We began by writing simple code that got us a simulation for a few repetitions. When we were sure how to make a simulation work, we encapsulated our code into a function that we could call to perform the simulation for us. We though about features that we would like the function to have—user chooses number of repetitions, user chooses whether to see a table, etc.—and implemented these features one by one. This made the function more general, i.e., useful in a wider range of settings. The above method of program development is called encapsulation and generalization. For small projects of the sort that we have on hand, it’s a good way to go about writing a computer program. 6.3.3 Number of Repetitions The Law of Large Numbers says that the more times you repeat the simulation, the better our estimate of the desired probability—or expected value—is liable to be. Let’s use the Stick-Splitting Problem to investigate the effect of the choice of repetitions on the accuracy of our estimate of the probability of getting a triangle. We will need to run the triangleSim() function several times, with a different choice for reps each time, keeping track of the estimates we obtain. In the process we won’t need tables or other output to the console. Let’s rewrite triangleSim() for maximum flexibility, making console output optional and using the invisible return discussed in Section 4.2.3.17 triangleSim &lt;- function(reps = 10000, table = FALSE, seed = NULL, verbose = TRUE) { if ( !is.null(seed) ) { set.seed(seed) } cut1 &lt;- runif(reps) cut2 &lt;- runif(reps) triangle &lt;- makesTriangle(cut1, cut2) if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(triangle)) cat(&quot;\\n&quot;) } if ( verbose ) { cat(&quot;The proportion of triangles was &quot;, mean(triangle), &quot;.\\n&quot;, sep = &quot;&quot;) } invisible(mean(triangle)) } Next, we make a vector of repetitions, and a vector to hold our estimates: reps &lt;- c(100, 1000, 10000, 100000, 1000000) estimates &lt;- numeric(length(reps)) Next we loop through reps, performing a complete simulation for each repetition-number and storing our results: for ( i in 1:length(reps)) { estimates[i] &lt;- triangleSim(reps = reps[i], seed = 3030, verbose = FALSE) } Let’s have a look at our estimates: names(estimates) &lt;- reps estimates ## 100 1000 10000 1e+05 1e+06 ## 0.200000 0.245000 0.254700 0.251570 0.249779 The estimates are indeed getting closer to the theoretical value of \\(1/4\\).18 6.3.4 Practice Exercises Rewrite the diceGameSim() function from the previous section so that, just as we did with the triangleSim() function in this section: it allows the user to set a seed; it returns the estimated expected value invisibly, and has a verbose option to cat the estimate out to the Console. Rewrite the photonTorpedoSim() function from the previous section so that, just as we did with the triangleSim() function in this section: it allows the user to set a seed; it returns the estimated expected value invisibly, and has a verbose option to cat the estimate out to the Console. Extend the photonTorpedoSim() just a bit more, by adding two new parameters: shield: the level at which the Enterpise’s shields are set. (If the strength of the torpedo is less than shield, then there is zero damage.) The default value of shield should be 5. upper: the upper bound on the strenght of a torpedo-shot. (That is, a tropedo shot will be a random real number from 0 to upper.) The default value of upper should be 10. The program should stop with a helpful message if the user sets upper or shield to a negative number.` Abe and Bo engage in a duel. They take turns shooting at each other until one person manages to hit the other, thus winning the dual. Abe has a 40 percent chance of hitting with each shot he takes, whereas Bo has a 60 percent chance of hitting on each of his shots. Since Abe is the weaker shooter, Bo generously permits Abe to go first. We would like to estimate Abe’s chance of winning the duel. Write a function called dual() to estimate this probability. The function should have two parameters: reps: the number of times to simulate a dual. The default should be 10,000. seed: a seed that the user can set. The default value should be NULL. 6.3.5 Solutions to Practice Exercises Here’s the code: diceGameSim &lt;- function(reps, seed = NULL, verbose = TRUE) { if (!is.null(seed) ) { set.seed(seed) } w &lt;- c(-1, 0, 3) pw &lt;- c(2/6, 3/6, 1/6) winnings &lt;- sample(w, size = reps, replace = TRUE, prob = pw) if ( verbose ) { cat(&quot;The expected amount to win is about &quot;, mean(winnings), &quot;.\\n&quot;, sep = &quot;&quot;) } invisible(mean(winnings)) } Let’s try it out: diceGameSim(reps = 100000, seed = 5252) ## The expected amount to win is about 0.17503. Here’s the code, if you use the pmax() function: photonTorpedoSim &lt;- function(reps, seed = NULL, verbose = TRUE) { if (!is.null(seed) ) { set.seed(seed) } strengths &lt;- runif(reps, min = 0, max = 12) damage &lt;- pmax(0, strengths - 5) if ( verbose ) { cat(&quot;The expected damage is about &quot;, mean(damage), &quot; units.\\n&quot;, sep = &quot;&quot;) } invisible(mean(damage)) } Let’s try it out: photonTorpedoSim(reps = 100000, seed = 4040) ## The expected damage is about 2.034732 units. Here’s the code: photonTorpedoSim &lt;- function(reps, seed = NULL, verbose = TRUE, shield = 5, upper = 10) { if (!is.null(seed) ) { set.seed(seed) } if ( upper &lt; 0 ) { return(cat(&quot;Upper bound on torpedo strength cannot be a negative number!&quot;)) } if ( shield &lt; 0 ) { return(cat(&quot;Shield strength cannot be set to a negative number!&quot;)) } strengths &lt;- runif(reps, min = 0, max = upper) damage &lt;- pmax(0, strengths - shield) if ( verbose ) { cat(&quot;The expected damage is about &quot;, mean(damage), &quot; units.\\n&quot;, sep = &quot;&quot;) } invisible(mean(damage)) } Let’s try it out: photonTorpedoSim(reps = 100000, seed = 4040, upper = 15, shield = 12) ## The expected damage is about 0.2991273 units. Here’s the function: dual &lt;- function(reps = 10000, seed = NULL) { if (!is.null(seed)) { set.seed(seed) } # set up logical vector to store results of each simulation: abeWins &lt;- logical(reps) for (i in 1:reps) { dualing &lt;- TRUE shotNumber &lt;- 1 while (dualing) { # if i is an odd number, then Abe is shooting: abeToShoot &lt;- shotNumber %% 2 == 1 # probability of hitting depends on who is shooting: hitProb &lt;- ifelse(abeToShoot, 0.4, 0.6) # shooter takes a shot: resultOfShot &lt;- sample(c(&quot;hit&quot;, &quot;miss&quot;), size = 1, prob = c(hitProb, 1 - hitProb)) if (resultOfShot == &quot;hit&quot;) { abeWins[i] &lt;- ifelse(abeToShoot, TRUE, FALSE) dualing &lt;- FALSE } shotNumber &lt;- shotNumber + 1 } } # count up how many times abe won, divide by number of plays, # and return: sum(abeWins)/reps } Let’s try it out: dual(reps = 100000, seed = 3939) ## [1] 0.52441 Looks like Abe has a slight advantage! The addition of the invisible return may be thought of as yet another step in the encapsulation-and-generalization process of program development!↩ Statistical theory tells us that when we use Monte Carlo simulation to estimate a probability or an expected value, then the likely size of the error in the approximation is inversely proportional to the square root of the number of repetitions we use. From this it follows that to cut the likely size of the error in half you should increase the number of repetitions by a factor of 4. If you want the likely size to be one-third as big, increase repetitions by a factor of 9, and so on.↩ "],
["simulation-connect.html", "6.4 Example: Will They Connect?", " 6.4 Example: Will They Connect? Anna and Raj make a date for coffee tomorrow at the local Coffee Shop. After making the date, both of them forget the exact time they agreed to meet: they can only remember that it was to be sometime between 10 and 11am. Each person, independently of the other, randomly picks a time between 10 and 11 to arrive. If Anna arrives and Raj is not there, she will wait up to ten minutes for him, but will leave if he does not show within that time period. Raj is similarly disposed: he will wait ten minutes—but no more—for Anna. What is the chance that they meet? The key to designing a simulation procedure is to realize that Anna and Raj will connect if and only if the difference between their arrival times is less than 10 minutes. It doesn’t matter who arrived first, so long as the difference is less than 10. This means that we want to check on the absolute value of Anna’s arrival time minus Raj’s arrival time. The following code implements this idea: meetupSim &lt;- function(reps = 10000, table = FALSE, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } anna &lt;- runif(reps, 0, 60) raj &lt;- runif(reps, 0, 60) connect &lt;- (abs(anna - raj) &lt; 10) if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(connect)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of times they met was &quot;, mean(connect), &quot;.\\n&quot;, sep = &quot;&quot;) } Let’s try it out: meetupSim(reps = 100000, table = TRUE, seed = 3939) ## Here is a table of the results: ## ## connect ## FALSE TRUE ## 69781 30219 ## ## The proportion of times they met was 0.30219. 6.4.1 Vectorization vs. Looping Whenever you perform a simulation you have the option to use a for-loop, running through the loop once for each repetition of the random process in question. For example, you could rewrite the meetup-simulation as follows: meetupSim2 &lt;- function(reps = 10000, table = FALSE, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } #create an empty vector to hold the results: connect &lt;- numeric(reps) # loop through: for ( i in 1:reps ) { # get one arrival time for anna: anna &lt;- runif(1, 0, 60) # and one for raj: raj &lt;- runif(1, 0, 60) #compute result and record in conncect: connect[i] &lt;- (abs(anna - raj) &lt; 10) } #the rest is the same as in meetupSim: if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(connect)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of times they met was &quot;, mean(connect), &quot;.\\n&quot;, sep = &quot;&quot;) } Be aware, though, that when you use a loop in place of vectorization your routine is liable to run more slowly. We can measure the difference with the R-function system.time(). As an illustration, let’s compare the running times for the vectorized and the looping versions of the meetup simulation. First we get the time for the thousand repetitions of the meetup, using the original vectorized function: system.time(meetupSim(reps = 10000, seed = 4040)) ## The proportion of times they met was 0.3079. ## user system elapsed ## 0.002 0.001 0.003 Our concern is with the total elapsed time: a mere three-thousandths of a second! Next we get the time for the same number of repetitions, using the looping implementation: system.time(meetupSim2(reps = 10000, seed = 4040)) ## The proportion of times they met was 0.2993. ## user system elapsed ## 0.056 0.007 0.065 Here the elapsed time is 0.065 seconds. This still seems pretty fast, but it’s more than 20 times as long as for the vectorized simulation. For more complex simulations such a dramatic slowdown could pose serious practical problems. When performance is an issue, prefer vectorization to looping as much as possible. "],
["appeals-court-paradox.html", "6.5 Example: the Appeals Court Paradox", " 6.5 Example: the Appeals Court Paradox The following example is discussed in (J.Nahin 2008). An appeals court generally consists of an odd number of justices, so the court will not be hampered with tie-votes and will thus always be able to render a decision for any case brought before it. Let’s imagine an appeals court that has five members. Let us further imagine that for each case before the court, each of the justices, independently of the others, makes a decision for either one or the other of the two opposing parties. Assume also for the sake of simplicity that there is always one side that is “in the right”. It follows that each judge is making a decision that is either correct or incorrect. The judges then report their decisions to one another, and the decision of the court is determined by majority vote. To be precise: whichever side gets three or more votes is the side that wins. Although all of the members of the court are pretty sharp, they differ somewhat in their legal abilities: In any case that comes before her, Judge A has a 95% chance to decide correctly. Judge B has a 94% chance to judge correctly. Judges C and D each have a 90% chance to judge correctly. Judge E is the weak link on the court, with a mere 80% chance to judge correctly. We are interested in estimating the probability that the majority opinion of the court will be correct. Before we write a simulation in full, we should consider how we are going to simulate something that has a specified percentage chance of happening. For example, how would we simulate decisions made by Judge A? One approach is to use runif() with a cutoff: number &lt;- runif(1) # random number between 0 and 1 number &lt; 0.95 ## [1] FALSE In repeated trials, a random real number between 0 and 1 will turn out to be less than 0.95 about 95% of the time. Another—and more convenient—way is to use the function rbinom(). This function simulates the results of flipping a coin a number of times and counting how many heads one gets. The general form of a call to rbinom()is as follows: rbinom(n, size, prob) In this call: size is how many times you plan to flip the coin; prob is the chance on any flip that the coin will turn up heads; n is how many times you plan to repeat the process of flipping the coin size times (counting up the number of heads each time). In order to simulate flipping a fair coin 100 times, you could ask for: rbinom(n = 1, size = 100, prob = 0.5) ## [1] 52 It seems that we got 52 heads! If you want to go through the above process twenty times instead of just doing it once, you could ask for: rbinom(n = 20, size = 100, prob = 0.5) ## [1] 52 49 45 57 53 60 46 53 50 54 59 47 42 45 41 56 47 57 56 49 Nothing in rbinom() says that it addresses only coin-flipping. In general it serves as a model for any situation in which: there is a fixed number of trials (e.g., flip of a coin, taking a free-throw shot, deciding about a court case); each trial has two possible outcomes, often termed Success or Failure (e.g., coins lands heads or tails, you make the shot or you don’t, you decide the case correctly or you don’t); the chance of the Success outcome is the same, on any trial (e.g., the coin always has the same chance of coming up heads, for any case Judge A has a 95% chance of being right); the outcome of any trial is independent of the outcome of all other trials (e.g., making the first free throw does not increase or decrease one’s chances of making the next free throw, etc.) you are counting up the number of successes in your trials. In such a situation the count of the number of successes is called a binomial random variable.19 The size parameter in rbinom() gives the fixed number of trials. The prob parameter specifies the chance of success on each trial. In this example we would like to simulate each judge deciding about each case. Suppose for example, that there are twenty cases. We would like to know, for each judge and each case, whether or not the judge was correct Suppose we were to watch Judge A making 20 decisions, recording each time whether she was correct or not. In order to simulate the results with R, we could ask for: rbinom(n = 20, size = 1, prob = 0.95) ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 In the above results, each 1 stands for a correct decision and the 0 stands for an incorrect decision. Note that the following call would be incorrect: rbinom(n = 1, size = 20, prob = 0.95) This would give us a count of the number of times Judge A was correct, but it would not tell us which of the cases she judged correctly and which she judged incorrectly. Assuming that the court hears 20 cases, we would like to simulate the decision of each judge in each case. We could store the results in variables, as follows: a &lt;- rbinom(n = 20, size = 1, prob = 0.95) # Judge A b &lt;- rbinom(n = 20, size = 1, prob = 0.94) # Judge B c &lt;- rbinom(n = 20, size = 1, prob = 0.90) # Judge C d &lt;- rbinom(n = 20, size = 1, prob = 0.90) # Judge D e &lt;- rbinom(n = 20, size = 1, prob = 0.80) # Judge E Now we come to the key idea in coding our simulation: in order to determine the total number of correct votes in each case, all we need to do is add the five vectors we created above: correctVotes &lt;- a + b + c + d + e The court will decide correctly when the number of votes for the correct option is at least 3. The following logical vector records this: courtCorrect &lt;- (correctVotes &gt;= 3) Table 6.2 shows some possible results: Table 6.2: Results of 20 simulated appeals court decisions. A B C D E Number Correct Court Correct 1 1 1 0 0 3 TRUE 1 1 1 0 1 4 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 1 5 TRUE 1 1 1 0 1 4 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 0 4 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 1 5 TRUE 1 1 1 0 1 4 TRUE 1 1 0 1 0 3 TRUE 1 1 1 1 1 5 TRUE 1 1 1 0 1 4 TRUE 0 1 1 1 1 4 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 1 5 TRUE 1 1 1 1 0 4 TRUE 1 1 0 1 1 4 TRUE Note that all of the court’s decisions were correct, even though in a couple of cases the correct decisions were barely in the majority. We now have the basic idea of the simulation. In order to estimate the probability of a correct decision, we simply need to recast our idea in the form of a function that permits us to simulate a very large number of imaginary court cases and that will report the results to us. Here is the code for such a function. courtSim &lt;- function(reps = 10000, seed = NULL, table = FALSE, probs = c(0.95, 0.94, 0.90, 0.90, 0.80)) { if ( !is.null(seed) ) { set.seed(seed) } # get the probabilities aProb &lt;- probs[1] bProb &lt;- probs[2] cProb &lt;- probs[3] dProb &lt;- probs[4] eProb &lt;- probs[5] # simulate decisions of each judge: a &lt;- rbinom(n = reps, size = 1, prob = aProb) b &lt;- rbinom(n = reps, size = 1, prob = bProb) c &lt;- rbinom(n = reps, size = 1, prob = cProb) d &lt;- rbinom(n = reps, size = 1, prob = dProb) e &lt;- rbinom(n = reps, size = 1, prob = eProb) # count the number of correct votes in each case: correctVotes &lt;- a + b + c + d + e # determine whether court decided correctly, in each case: courtCorrect &lt;- (correctVotes &gt;= 3) # record results if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(courtCorrect)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of times the court was correct was &quot;, mean(courtCorrect), &quot;.\\n&quot;, sep = &quot;&quot;) } Let’s now estimate the probability of the court rendering a correct verdict, using one hundred thousand simulated cases: courtSim(reps = 100000, seed = 3838, table = TRUE) ## Here is a table of the results: ## ## courtCorrect ## FALSE TRUE ## 787 99213 ## ## The proportion of times the court was correct was 0.99213. The court seems to be doing quite well! But of course this is not very surprising: after all, most of the judges make the correct decision almost all the time. It is interesting, though, that the chance of the full court rendering a correct verdict is higher than the chance of any individual judge to be correct. There appears to be a benefit to the voting procedure. But things get even more interesting if we imagine that the judges recognize, after some time, that Judge E simply isn’t as sharp as Judge A, and that they pressure him into voting whichever way Judge A votes. “Surely”, they reason, “since Judge A is so good this new policy will increase our chance to hand down a correct verdict!” We will simulate to see if the judges’ reasoning is correct. All we need to do is to count Judge A’s vote twice in the sum, and not count Judge E’s vote at all: correctVotes &lt;- 2*a + b + c + d Here is the new simulation-function: courtSim2 &lt;- function(reps = 10000, seed = NULL, table = FALSE, probs = c(0.95, 0.94, 0.90, 0.90, 0.80)) { if ( !is.null(seed) ) { set.seed(seed) } # get the probabilities aProb &lt;- probs[1] bProb &lt;- probs[2] cProb &lt;- probs[3] dProb &lt;- probs[4] eProb &lt;- probs[5] # simulate decisions (this time, no need for Judge E) : a &lt;- rbinom(n = reps, size = 1, prob = aProb) b &lt;- rbinom(n = reps, size = 1, prob = bProb) c &lt;- rbinom(n = reps, size = 1, prob = cProb) d &lt;- rbinom(n = reps, size = 1, prob = dProb) # count rhe number of correct votes in each case: correctVotes &lt;- 2*a + b + c + d # determine whether court decided correctly, in each case: courtCorrect &lt;- (correctVotes &gt;= 3) # record results if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(courtCorrect)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of times the court was correct was &quot;, mean(courtCorrect), &quot;.\\n&quot;, sep = &quot;&quot;) } Let’s try it out: courtSim2(reps = 100000, seed = 3838, table = TRUE) ## Here is a table of the results: ## ## courtCorrect ## FALSE TRUE ## 1221 98779 ## ## The proportion of times the court was correct was 0.98779. Hey! That’s a lower chance of success than before! The difference is small but significant: compelling the weakest judge to vote with the strongest judge actually decreased the court’s chance of rendering a correct verdict overall. This circumstance is sometimes called the Appeals Court Paradox, but it occurs in many other practical situations. More often than you might think, the benefit of independent voting can outweigh the advantage associated with relying solely on a small number of “experts.” 6.5.1 Practice Exercises Use rbinom() to simulate taking twenty free throws, where you have a 70% chance to make each shot. Your simulation should produce a vector of 20 ones and zeros, where 1 stands for making the shot and 0 stands for missing it. Use rbinom() to simulate taking twenty free throws, where you have a 70% chance to make each shot, and counting up how many shots you make. Your simulation should produce a vector of length one that represents the number of shots you made. Every morning for 100 mornings in a row you take twenty free throws. You have a 70% chance to make each shot, and you always count up how many shots you make. Use rbinom() to simulate the counts. Your simulation should produce a vector of length 100 where the first element represents the number of shots you made on day 1, the second element represents the number of shots you made on day 2, etc. You have a 70% chance to make each free throw shot you take. Your friend Lester has a 60% chance to make each shot. Both of you will take 20 shots. You are interested in knowing the probability that you will make more shots than Lester does. Write a function called freeThrowSim() that will help you estimate this probability. The function should take two parameters: seed, so that the user can set a seed; reps, the number of times to simulate a competition between you and Lester. The function should return the estimated probability. 6.5.2 Solutions to the Practice Exercises Try this: rbinom(20, size = 1, prob = 0.70) ## [1] 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 0 1 1 1 1 Try this: rbinom(1, size = 20, prob = 0.70) ## [1] 14 Try this: rbinom(100, size = 20, prob = 0.70) Here’s the function if you decide to use a loop: freeThrowSim &lt;- function(reps, seed) { youWin &lt;- logical(reps) for ( i in 1:reps ) { youMake &lt;- rbinom(1, size = 20, prob = 0.70) lesterMakes &lt;- rbinom(1, size = 20, prob = 0.60) youWin[i] &lt;- (youMake &gt; lesterMakes) } mean(youWin) } Here’s the function if you vectorize: freeThrowSim &lt;- function(reps, seed) { youMake &lt;- rbinom(reps, size = 20, prob = 0.70) lesterMakes &lt;- rbinom(reps, size = 20, prob = 0.60) youWin&lt;- (youMake &gt; lesterMakes) mean(youWin) } Let’s try it: freeThrowSim(reps = 100000, seed = 3535) ## [1] 0.69132 You have nearly a 70% chance to make more shots than Lester. References "],
["simulation-number-needed.html", "6.6 Example: How Many Numbers Needed?", " 6.6 Example: How Many Numbers Needed? Let us pause for a review. So far our examples have involved estimating a probability: the chance for a particular event to occur. We have accomplished this with Monte Carlo simulation: We repeated the chance process a very large number of times On each repetition, we recorded whether or not the event occurred. After we finished all of the repetitions, we computed the proportion of those repetitions in which the event did occur. This proportion served as our estimate of the probability for the event to occur. We know that the more repetitions we arrange for, the closer our estimate is liable to be to the actual probability for the event to occur. Let us now switch gears and take up the task of estimating the expected value of a random variable. Recall that a random variable is a number whose value is the result of some chance process. The expected value of the random variable is the average—the mean—of its values over many, many repetitions of that chance process. Let us consider the following chance process: Pick a real number \\(x_1\\) between 0 and 1 at random. Pick another real number \\(x_2\\) at random (also between 0 and 1). Add it to \\(x_1\\). If the sum \\(x_1 + x_2\\) exceeds 1, then stop. Otherwise, pick a third real number \\(x_3\\), and add it to the sum of the previous two. If the sum \\(x_1+x_2+x_3\\) exceeds 1, then stop. Otherwise, pick a fourth real number … The idea is to keep on going in this way until the sum of the numbers you have picked exceeds 1. The random variable we are interested in is the number of numbers we have to pick to make the sum of those numbers exceed 1. Let us call this random variable \\(X\\). As you can see, this number could be 2, or 3, or 4, or even more depending on how small the random numbers you pick happen to be. In order to fully grasp what is going on, it will be helpful to go through the process of computing \\(X\\). The following function will do this for us: numberNeeded &lt;- function(verbose = FALSE) { mySum &lt;- 0 count &lt;- 0 while( mySum &lt; 1 ) { number &lt;- runif(1) mySum &lt;- mySum + number count &lt;- count + 1 if ( verbose ) { cat(&quot;Just now picked &quot;, number, &quot;.\\n&quot;, sep = &quot;&quot;) cat(count, &quot; number(s) picked so far.\\n&quot;, sep = &quot;&quot;) cat(&quot;Their sum is &quot;, mySum, &quot;.\\n\\n&quot;, sep = &quot;&quot;) } } count } Call the function a few times, like this: numberNeeded(verbose = TRUE) ## Just now picked 0.2869393. ## 1 number(s) picked so far. ## Their sum is 0.2869393. ## ## Just now picked 0.7092682. ## 2 number(s) picked so far. ## Their sum is 0.9962075. ## ## Just now picked 0.7524099. ## 3 number(s) picked so far. ## Their sum is 1.748617. ## [1] 3 As you can see, it’s quite common to need 2 or 3 numbers to make the sum exceed 1, but sometimes, you need 4, 5 or even more numbers. Since we are interested in the expected value of \\(X\\), we should repeat the process a large number of times and compute the mean of the \\(X\\)-values that we find. The following code repeats the process 1000 times: needed &lt;- numeric(1000) for (i in 1:1000 ) { needed[i] &lt;- numberNeeded() } cat(&quot;The expected number needed is about &quot;, mean(needed), &quot;.\\n&quot;, sep = &quot;&quot;) ## The expected number needed is about 2.697. Of course the expected value indicates what \\(X\\) will be on average. By itself it doesn’t tell us about the variability in \\(X\\)—how much \\(X\\) tends to “hop around” from one repetition to another. In order to get a sense of the variability of \\(X\\), we can make a table of the results of our 1000 repetitions: table(needed) ## needed ## 2 3 4 5 6 7 ## 528 303 123 37 8 1 Sure enough, we usually got 2 or 3, but higher values are certainly possible. For the most part we are less interested in the number of times we got each possible value than we are in the proportion of times we got each possible value. For this all we need is prop.table(): prop.table(table(needed)) ## needed ## 2 3 4 5 6 7 ## 0.528 0.303 0.123 0.037 0.008 0.001 The proportions serve as estimates of the probability of getting each of the possible values of \\(X\\). Such a table of proportions gives us a sense of the distribution of \\(X\\)—the chances for \\(X\\) to assume each of its possible values.20 Now that we have the basic idea of how to accomplish the simulation, it remains to package up our code into a nice function that will enable a user to set the number of repetitions, set a seed, and choose reporting options. Along the way we will generalize a bit, allowing the user to set a target sum other than 1. We’ll also return our estimate of the expected number needed invisibly, so that the function can be used in the context of larger-scale investigations (see the exercises from this Chapter). numberNeededSim &lt;- function(target = 1, reps = 1000, seed = NULL, report = FALSE) { if ( !is.null(seed) ) { set.seed(seed) } # define helper function numberNeeded &lt;- function(target) { mySum &lt;- 0 count &lt;- 0 while( mySum &lt; target ) { number &lt;- runif(1) mySum &lt;- mySum + number count &lt;- count + 1 } count } #perform simulation needed &lt;- numeric(reps) for (i in 1:reps ) { needed[i] &lt;- numberNeeded(target) } # report results (if desired) if ( report ) { print(prop.table(table(needed))) cat(&quot;\\n&quot;) cat(&quot;The expected number needed is about &quot;, mean(needed), &quot;.\\n&quot;, sep = &quot;&quot;) } # return estimate of the expected number needed: invisible(mean(needed)) } Let’s test the function with ten thousand repetitions: numberNeededSim(target = 1, reps = 10000, seed = 4848, report = TRUE) ## needed ## 2 3 4 5 6 7 8 ## 0.4937 0.3350 0.1313 0.0317 0.0071 0.0010 0.0002 ## ## The expected number needed is about 2.7273. Does the estimate of the expected number of numbers look a bit familiar? Mathematicians have proven that the exact expected value—what you would get for an average if you could do more and more repetitions, without limit—is the famous number \\(e\\): \\[\\mathrm{e} \\approx 2.71828 \\ldots\\] In the exercises you will be asked to investigate the expected value when the target is a number other than 1. Of course not all of the possible values for \\(X\\) appear on the table: the only values appearing are those that happened to occur in our simulation. The values that did not occur probably have a very small (but nonzero) chance of occurring.↩ "],
["example-dental-floss.html", "6.7 Example: Dental Floss", " 6.7 Example: Dental Floss If you are like me, you don’t like to run out of an item that you commonly use, so you always try to have a spare source for the item on hand. Take dental floss, for example. It’s difficult to know when the little box is almost out of floss. Hence I try to keep two boxes on hand in my bathroom drawer: the one I’m using, and a spare. The problem is that I can never tell which one is “the one I’m using” and which one is the spare. In fact on any given day I’m equally likely to pull a length of floss out of either one of the boxes.21 Let’s make the following assumptions: A box of floss starts out with 150 feet of floss. I start with two fresh boxes. Every time I floss, each box has a 50% chance of being the box I pull from. When I pull out floss, the length I choose to pull is a random number between 1 and 2 feet. If the box has less than than the amount I choose to pull, then: If the remaining length is more than 1 foot, I pull it all out and use it. (Next time I’ll have to use the other box.) If the remaining length is less than 1 foot, I also pull it all out, but I don’t use it because it’s not long enough. (I’ll have to move on to the other box.) There are several interesting questions we could ask concerning this situation. In this example, let’s focus on finding the expected value of \\(X\\), the amount of floss left in the other box when I discover the one of the boxes is exhausted. I would also like to get some idea of the distribution of \\(X\\)—the chance for it to assume each of its possible values. Unlike the previous “Number of Numbers” example, however, \\(X\\) is what we call a continuous random variable: it can assume any of the values in a range of real numbers. After all, the amount left in the “other” box could be anything from 0 to 150 feet: it could be 3.5633 feet or 5.21887 feet, or any real number at all, so long as it’s between 0 and 150. Although any real number value—3.5633 feet, for instance—is possible, it seems that the chance of \\(X\\) being exactly 3.5633 is vanishingly small, and the same goes for any of the possible real numbers value for \\(X\\). Hence it seems that the distribution of \\(X\\) cannot be described well with a table of the values that we actually get in a simulation: indeed, we are highly unlikely to get any value more than once in the course of our simulation. One way to visualize the distribution of a continuous random variable is to make a density plot of a large, representative sample of its values. Let’s practice making a density plot for a random variable that R provides for us: a so-called normal random variable. Try this code: x &lt;- rnorm(100, mean = 70, sd = 3) We have just asked R to produce 100 numbers chosen randomly from a normal distribution. The mean parameter sets what the values should be “on average”, and the sd parameter indicates how much they should typically differ from that average value. The bigger the sd, the bigger the difference between the mean and value actually obtained is liable to be. Let’s get a look at the first ten values in the vector x: x[1:10] ## [1] 71.13092 70.90465 66.70593 66.60878 61.61040 72.16172 72.81736 69.31187 75.27739 70.35210 Sure enough, the numbers are typically around the mean of 70, give or take 3 units or so. We can use the ggplot2 package to produce a density curve from all 100 values in the vector x. (The resulting plot appears as Figure 6.2.) library(ggplot2) p &lt;- ggplot(mapping = aes(x = x)) + geom_density() + geom_rug() + labs(x = &quot;x-value&quot;) p Figure 6.2: Density plot of 100 random values from a normal distribution with mean 70 and standard deviation 3. The geom_density() part of the plotting-command produces the curve. The geom_rug() part produces tick-marks along the horizontal axis, each of which is located at a particular value in the vector x. You can see that the curve is higher where values are crowded together, and lower where the values are spread apart. The scale on the y-axis has been chosen carefully so that the area under the density curve between any two numbers \\(a\\) and \\(b\\) on the axis gives an estimate of the chance that the normal random variable would produce a value between \\(a\\) and \\(b\\). In this way the density curve gives us a visual sense of the distribution of the random variable: it seems rather likely to be between 67 and 73 (most of the area under the curve occurs there) and rather unlikely to be greater than 76, and so on. We are now ready to simulate the dental-floss scenario. Since we have worked through the encapsulation-and-generalization development process a number of times by now, we will simply show a final-form implementation of a simulation function: flossSim &lt;- function(len = 150, min = 1, max = 2, reps = 10000, graph = FALSE, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } # helper function to pick whihc box gets used: whichOne &lt;- function(x) { if (x &lt; 0.5 ) { return(&quot;a&quot;) } else return(&quot;b&quot;) } # vector to contains our results: leftover &lt;- numeric(reps) # now the simulation. Each time we loop through, we # start with two fresh boxes and use them until one of # them runs out. for (i in 1:reps ) { # set the initial lengh of the two fresh boxes: a &lt;- b &lt;- len # at the beignning, both can be used: bothOK &lt;- TRUE # start flossing while ( bothOK ) { # determine which box is picked # &lt; 0.5 is a; &gt;= 0.5 is b; boxPicked &lt;- whichOne(runif(1)) # if we choose box a, attempt to use floss from it if ( boxPicked == &quot;a&quot; ) { if ( a &lt; 1 ) { leftover[i] &lt;- b bothOK &lt;- FALSE } else { useAmount &lt;- min(runif(1, min, max), a) a &lt;- a - useAmount if (abs(a) &lt; 10^(-4)) { leftover[i] &lt;- b bothOK &lt;- FALSE } } } # use floss from b (if we choose it) if ( boxPicked == &quot;b&quot; ) { if ( b &lt; 1 ) { leftover[i] &lt;- a bothOK &lt;- FALSE } else { useAmount &lt;- min(runif(1, min, max), b) b &lt;- b - useAmount if (abs(b) &lt; 10^(-4)) { leftover[i] &lt;- a bothOK &lt;- FALSE } } } } # end while loop } # end for loop # report results: if ( graph ) { plotTitle &lt;- paste0(&quot;Dental-Floss Simulation with &quot;, reps, &quot; Repetitions&quot;) p &lt;- ggplot(mapping = aes(leftover)) + geom_density() + labs(x = &quot;Amount left in spare (ft)&quot;, title = plotTitle) # add a rug of individual points, provided there are not too many: if ( reps &lt;= 100 ) { p &lt;- p + geom_rug() } } print(p) cat(&quot;The average amount left in the spare is: &quot;, mean(leftover), &quot;.&quot;, sep = &quot;&quot;) } # end flossSim Let’s give it a try with one thousand repetitions. flossSim(reps = 1000, graph = TRUE, seed = 3535) Figure 6.3: Density plot of the results of a dental-floss simulation. ## The average amount left in the spare is: 16.55715. A density plot of the results appears as Figure 6.3. The expected value of the amount left in the remaining box is about 16.3 feet, but you can see from the plot that there is quite a bit of variability: it’s not all that unlikely to have 40 or more feet left! A scenario similar to this one is discussed in (J.Nahin 2008), see p. 52.↩ "],
["drunken-turtle-sim.html", "6.8 Example: The Drunken Turtle", " 6.8 Example: The Drunken Turtle Let us return to the scenario of the Drunken Turtle that was introduced in Section 5.4.5. At each step the turtle would turn by a random angle—any angle between 0 and 360 degrees with equal likelihood—and then move forward by a fixed number of units. We wondered whether the turtle would simply wander away from its starting point or perhaps eventually loop back close to its starting point. In this section we will construct a simulation that sheds light on our question. We will imagine that the turtle starts at the origin on the \\(xy\\)-plane and takes a large but fixed number of steps—one thousand steps, say—each of a fixed length of one unit, but each of which is preceded by a drunken turn through a random angle. We will concern ourselves with the random variable \\(X\\), defined as follows: \\(X\\) = the number of times in the turtle returns to within \\(1/2\\) of a unit of the origin, during its first 1000 steps. (Apparently we consider a “close return” to be anything within half a unit of the origin.) In particular, we would like to know the distribution of \\(X\\): what is the chance that the turtle does not make a close return during the first thousand steps? What’s the chance of making only one close return? Two close returns? And so on … . We would also like to estimate the expected value of \\(X\\): the average number of close returns in the first 1000 steps. We will next consider how to code a simulation. Obviously we will need a way to record the turtle’s position at each step. In order to accomplish this we will have to apply the unit-circle trigonometry you learned in high school. Instead of measuring angles in degrees, we will work in radians: by default R does trigonometry that way. Recall that 360 degrees is \\(2 \\pi\\) radians; hence the way to determine the angle of a turn by the drunken turtle is with the following call to runif(): runif(1, min = 0, max = 2*pi) ## [1] 4.146176 If we want a thousand drunken turn-angles, then we can get them all in a vector, as follows: runif(1000, min = 0, max = 2*pi) So much for the turning angles. But in order to decide at each step whether the turtle has made a close return, we have to know the coordinates of the turtle after each step. This is where unit-circle trigonometry comes in handy. Recall that if a right triangle has a hypotenuse of length 1 (the length of a turtle step) and if one of the angles of the triangle is \\(\\alpha\\), then the side adjacent to \\(\\alpha\\) is \\(\\cos(\\alpha)\\) and the side opposite is \\(\\sin(\\alpha)\\). The situation is illustrated in Figure 6.4. Figure 6.4: Sides of a right triangle with hypotenuse 1, in terms of the angle shown. From this principle it follows that if the turtle turns a random angle of \\(a_1\\) radians for its first step, then after it takes the one-unit step it will be at the point \\((\\cos(a_1), \\sin(a_2))\\). For the second step, the turtle begins by turning another random angle, say \\(a_2\\) radians. It then takes another one-unit step. This second step forms the hypotenuse of a second right triangle (see Figure 6.5). The horizontal and vertical sides of this right triangle must be \\(\\cos(a_2)\\) and \\(\\sin(a_2)\\) respectively. When the turtle complete the second step, it has added these values to its previous \\(x\\) and \\(y\\) coordinates, so that it is now at the point: \\[(\\cos(a_1) + \\cos(a_2), \\sin(a_1) +\\sin(a_2)).\\] We now see the idea: in order to record the position of the turtle at the end of each step, we simply need to: take the cosine of all the turning-angles; take the sine of all the turning-angles; sum the cosines to get the \\(x\\)-coordinate; sum the sines to get the \\(y\\)-coordinate. Figure 6.5: The first two steps by the Drunken Turtle. Turtle turns by \\(a_1\\) radians for Step One, then by \\(a_2\\) radians for Step Two. Let’s put this idea into practice, for just the first ten steps. First, get the turning angles, the sines and the cosines: angle &lt;- runif(10, 0 , 2*pi) xSteps &lt;- cos(angle) ySteps &lt;- sin(angle) Next, we need to add the xSteps together. If we do a sum, we would get the \\(x\\)-coordinate after the tenth step: sum(xSteps) ## [1] -1.370258 (Apparently some of the cosines were negative, meaning that some of the turning angles were between 90 and 270 degrees.) We need the \\(x\\)-coordinates after all of the previous steps, as well. This can be accomplished by R’s cumsum() function. You may think of cumsum as short for “cumulative sum”. Given a vector vec of numbers, cumsum(vec) returns a vector of the same length, where for every index i, cumsum(vec)[i] is sum(vec[1:i]). This is made clear in the following example: vec &lt;- c(3, 2, -1, 4, -2) cumsum(vec) ## [1] 3 5 4 8 6 Look at the table below. vec cumulative sum cumsum(vec) 3 3 3 2 \\(3+2\\) 5 -1 \\(3+2+-1\\) 4 4 \\(3+2+-1+4\\) 8 -2 \\(3+2+-1+4+-2\\) 6 See how it works? Returning to xSteps, we see that we can get the \\(x\\)-coordinates of the first ten steps like this: x &lt;- cumsum(xSteps) x ## [1] -0.6034165 -1.3905805 -2.1259607 -3.1154380 -2.4593130 -1.5476110 -0.8591924 -1.6420445 ## [9] -0.6421761 -1.3702583 Similarly we can get the first ten \\(y\\)-coordinates: y &lt;- cumsum(ySteps) Using the distance formula, we can compute the distance of each point from the origin as follows: dist &lt;- sqrt(x^2 + y^2) The following logical vector will then record, at each each step, whether or not the turtle has made a close return: closeReturn &lt;- (dist &lt; 0.5) The results are shown in Table 6.3. Table 6.3: Record of the turtle’s first ten steps. It has not yet made a close return. angle xSteps ySteps x y dist closeReturn 4.0646104 -0.6034165 -0.7974262 -0.6034165 -0.7974262 1.000000 FALSE 2.4769935 -0.7871641 0.6167437 -1.3905805 -0.1806826 1.402270 FALSE 3.8861615 -0.7353801 -0.6776548 -2.1259607 -0.8583374 2.292695 FALSE 2.9963954 -0.9894774 0.1446876 -3.1154380 -0.7136497 3.196131 FALSE 0.8551238 0.6561251 0.7546522 -2.4593130 0.0410024 2.459655 FALSE 0.4233886 0.9117020 0.4108522 -1.5476110 0.4518546 1.612226 FALSE 0.8114898 0.6884186 0.7253136 -0.8591924 1.1771682 1.457373 FALSE 2.4700328 -0.7828521 0.6222079 -1.6420445 1.7993761 2.435993 FALSE 0.0162276 0.9998683 0.0162269 -0.6421761 1.8156030 1.925826 FALSE 3.8968689 -0.7280822 -0.6854899 -1.3702583 1.1301131 1.776165 FALSE It remains only to package our code into a simulation function. We will allow the user to specify the fixed initial number of steps (it does not have to be 1000), and also to determine what distance counts as a “close return.” drunkenSim &lt;- function(steps = 1000, reps = 10000, close = 0.5, seed = NULL, table = FALSE) { if ( !is.null(seed) ) { set.seed(seed) } # set up returns vector to store the number of # close returns in each repetition: returns &lt;- numeric(reps) for (i in 1:reps) { angle &lt;- runif(steps, 0 , 2*pi) xSteps &lt;- cos(angle) ySteps &lt;- sin(angle) x &lt;- cumsum(xSteps) y &lt;- cumsum(ySteps) dist &lt;- sqrt(x^2 + y^2) closeReturn &lt;- (dist &lt; 0.5) returns[i] &lt;- sum(closeReturn) } if ( table ) { cat(&quot;Here is a table of the number of close returns:\\n\\n&quot;) tab &lt;- prop.table(table(returns)) print(tab) cat(&quot;\\n&quot;) } cat(&quot;The average number of close returns was: &quot;, mean(returns), &quot;.&quot;, sep = &quot;&quot;) } Let’s try it out: drunkenSim(steps = 1000, reps = 10000, close = 0.5, seed = 3535, table = TRUE) ## Here is a table of the number of close returns: ## ## returns ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ## 0.3881 0.2290 0.1517 0.0908 0.0572 0.0335 0.0227 0.0107 0.0064 0.0048 0.0018 0.0012 0.0008 0.0007 ## 14 15 16 17 ## 0.0003 0.0001 0.0001 0.0001 ## ## The average number of close returns was: 1.5655. Notice that 38.81% of the time the turtle did not make a close return at all during the first thousand steps. On the other hand it is possible, though not at all likely, for the turtle to make quite a few close returns.22 It is interesting to look specifically at the distances from the origin. The following function draws a graph of the distance from the origin for the specified number of turtle steps: drunkenSim2 &lt;- function(steps = 1000, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } angle &lt;- runif(steps, 0 , 2*pi) xSteps &lt;- cos(angle) ySteps &lt;- sin(angle) x &lt;- cumsum(xSteps) y &lt;- cumsum(ySteps) dist &lt;- sqrt(x^2 + y^2) plotTitle &lt;- paste0(&quot;First &quot;, steps, &quot; Steps of the Drunken Turtle&quot;) p &lt;- ggplot(mapping = aes(x = 1:steps, y=dist)) + geom_line() + labs(x = &quot;Step&quot;, y = &quot;Distance From Origin&quot;, title = plotTitle) print(p) } Let’s try it out! The results appear in Figure 6.6 drunkenSim2(steps = 1000, seed = 2525) Figure 6.6: Line plot of the Turtle’s distance from the origin, as a function of how many steps the turtle has taken. It appears that although the turtle might have returned close to the origin a couple of times, for the most part it seems to be wandering further and further away. In the mathematical field known as stochastic processes, it has been shown that if the turtle is allowed to go on forever then it will certainly make a close return infinitely many times. These returns, though, will tend to be spaced further and further apart as time goes on, and our graph suggests that this is so. Note that these proportions depend heavily on how we define “close”. If the cut-off had been lower than \\(1/2\\), then we would have seen fewer close returns.↩ "],
["glossary-4.html", "Glossary", " Glossary Probability of an Event The long-run proportion of times that the event will occur if the underlying random process is repeated many, many times. Random Variable A number whose value depends on the outcome of a chance process. Expected Value of a Random Variable The long-run average of the values of a random variable, where the underlying chance process is repeated many, many times. Continuous Random Variable A random variable that can assume any value in a range of real numbers. Distribution of a Random Variable A statement of the probabilities for a random variable to assume its various possible values. Encapsulation and Generalization A method for developing a computer program according to which the programmer first designs a basic procedure, then encapsulates it in one or more functions, and then progressively generalizes these functions until the program possesses all desired features. "],
["exercises-4.html", "Exercises", " Exercises Consider the following two games. In Game A you flip a fair coin. If the coin comes up Heads you get two dollars, whereas if it comes up Tails you get one dollar. In Game B you roll a fair die. If the six-spot comes up, you win twenty-five dollars. If you get 2, 3, 4, or 5, nothing happens. If the one-spot comes up, you lose fifteen dollars. In this exercise you need to answer two questions: If you could choose to play either Game A or Game B just once, which game would you prefer to play, and why? Suppose that you can choose either to play Game A ten thousand times, or Game B ten thousand times. Which choice would you prefer, and why? Answers to the first question will vary from person to person, depending on circumstances and personal taste. On the other hand, astute consideration of expected values leads most people to answer the second question in the same way. Therefore, before you answer the question please write two simulation functions: one called GameA that provides an estimate of the expected value of the winnings from a play of Game A, and another called GameB that estimates the expected value of the winnings from a play of Game B. The functions should have two parameters: a reps parameter to permit the user to choose the number of repetitions of the game; a seed parameter to permit the user to choose a starting seed. Use both functions with fifty thousand reps, in order to obtain estimates for the expected amount of winnings in a single play of each game. Use a simple starting seed for each function. Report the seeds you used, along with the estimated expected values for each game. Use your results to decide which game is the better choice to play ten thousand times. Note: Please keep in mind that the fifty-thousand figure is just the number of times you repeat your simulations in order to estimate the expected value of a single play of one of the games. It’s not how many times you actually get to play either game—that’s ten thousand. Reconsider the meeting of Anna and Raj. Suppose that they still plan to meet during the same one-hour period, but that Anna is willing to wait \\(a\\) minutes and Raj is willing to wait \\(r\\) minutes, where \\(a\\) and \\(r\\) could differ. Modify the meetupSim() function so that it accepts two additional parameters: a: the time Anna is willing to wait; r: the time Raj is willing to wait; Apply the function with ten thousand repetitions (and a simple seed that you report) in order to estimate the probability of a meeting, assuming that Anna is willing to wait 13 minutes and Raj is willing to wait 7 minutes. Hint: Suppose that Anna arrvies at time \\(Anna\\) and Raj arrives at times \\(raj\\). We want a simple mathematical expression that gives the conditions for Anna and Raj to connect. In the example in the text, this was: \\[\\vert\\ anna - raj \\ \\vert &lt; 10\\] because both Anna and Raj were willing to wait the same amount of time: ten minutes. Now we have to think a bit more carefully when Anna waits \\(a\\) minutes and Raj waits \\(r\\) minutes, where \\(a\\) and \\(r\\) may differ. You might start by observing that we must have \\[anna - r \\le raj,\\] for if not then Raj would arrive and leave before Anna gets there. Also, we would have to have \\[raj \\le anna + a,\\] for if not then Anna would arrive and leave before Raj gets there. But if we have both of those conditions: \\[anna - r \\le raj \\text{ and } raj \\le anna + a\\] then they must connect, since neither person will arrive too much before the other. Review the function dual() in the Practice Exercises of this Chapter (see Section 6.3.4). Modify the function as follows: Add a parameter abe that gives the probability for Abe to hit when he shoots, and a parameter bo that gives the chance for Bo to hit when he shoots. the probabilities should be expressed as numbers between 0 and 1. (Thus, a 30% chance of hitting is 0.30.) Make the function estimate the expected value of the number of shots taken in a dual, rather than the chance for Abe to win. When you have your function working, use it to estimate the expected number of shots when: Abe’s chance of hitting is 50 percent and Bo’s chance if 50%; Abe’s chance of hitting is 20% and Bo’s chance of hitting is 25%. In each simulation, use one hundred thousand repetitions and a seed that you choose. A candy-maker makes a particular type of candy that always has 20 candies in each bag. When you buy a bag of this candy, you take a few candies from it every day until they are all gone. The amount you take each day is a random whole number from 1 to 10. A possible scenario is: Day 1: take 4 candies. (There are 16 left.) Day 2: take 8 candies. (There are 8 left.) Day 3: take 3 candies. (There are 5 left.) Day 4: take 6 candies. (There were only 5 left, so you take all the remaining candies.) In the scenario above, it took you four days to finish the bag. Write a function called daysNeededSim() that will estimate the expected number of days required to empty a bag. It should take two parameters: reps: the number of times to simulate the process of emptying one bag. The default value should be 10,000. seed: a random seed that the user can set. The default value should be NULL. Apply the function with 50,000 repetitions and a seed that you report, in order to estimate the expected number of days required to empty the bag. Hint: This scenario is quite similar to the numberNeededSim() problem from this Chapter. Begin by reviewing it. (*) Refer back to the numberNeededSim() function. Write a program that computes the estimated expected number needed, for the following targets: targets &lt;- seq(0.05, 0.95, by = 0.05) Each estimate should be based on ten thousand repetitions. Start with a simple seed that you report. Report the estimated expected values for all of the required targets. Compare these estimates with exp(targets) (the number \\(e\\) raised to the power of each of the targets.) Formulate a conjecture about the value of the expected number of numbers needed, when the target is a real number between 0 and 1. Hint: Recall that numberNeededSim() function returns its estimate of the expected number needed. Hence you could use it inside a for-loop that iterates through the elements of the targets vector above, something like this: targets &lt;- seq(0.05, 0.95, by = 0.05) n &lt;- length(targets) results &lt;- numeric(n) set.seed(3030) # or some other simple seed that you like for ( i in 1:n ) { # use numberNeededSim() with: # * 10000 reps # * seed left at the default NULL (you provided one already) # * target set to targets[i] # * report left at FALSE (no need to have R talk to you at each step) # make sure to store the estimate in results[i] } # after the loop, you can compare results with exp(targets) (*) A pipe-smoker has two boxes of matches in his pocket. Both boxes contain 40 matches. Every time he lights his pipe, the smoker reaches into his pocket and randomly picks one of the boxes, pulling a match from the box. Eventually one of the boxes runs out. What is the expected value of the number of matches remaining in the other box at that time? Write a simulation function to estimate the answer. Your function should have at least a reps and a seed parameter. Apply the function with ten thousand repetitions—and with a simple seed that you report—in order to estimate the expected value. (*) A gambler starts with 10 dollars, and repeatedly plays a game. If she wins the game she gets one dollar and if she loses the game she loses one dollar. Her chance of winning each game is a fixed number that is less than 0.50. Write a function to simulate the gambler repeatedly playing the game until her money runs out. The function should keep track of how much money she has left after each play, so that it can produce a line graph (similar to the one in the section on the Drunken Turtle) of the money left after each play. Write the function so that it has a start parameter for the initial amount of money the gambler has; a seed parameter`; a p parameter for the chance of winning, so that the user can enter any chance less than or equal to 0.5. (The function should stop the user if the user enters more than 0.5.) Apply the function with a simple seed that you report, a starting amount of ten dollars, and a chance of winning equal to 0.45. (*) An absent-minded professor walks to and from campus every day. Prior to every commute—either from home to office or the reverse—she checks the weather, taking an umbrella with her if it is raining. The problem is that she never takes an umbrella when the weather is dry, so even though she owns quite a few umbrellas the time comes eventually when it is raining but all of her umbrellas are at her destination, so that she will have to put up with a wet commute. Suppose that there are \\(x\\) umbrellas at her house and \\(y\\) umbrellas at her office, and that she begins at home. Suppose further that the chance of rain on any commute is \\(p\\), a number between 0 and 1. Write a simulation function to estimate the expected number of dry commutes that she will enjoy before her first wet commute. The function should have five parameters: x: the initial number of umbrellas at home (default 1); y: the initial number of umbrellas at the office (default 1); p: the probability of rain at any commute (default 0.5); seed: an seed for the randomizers (default NULL). reps: the number of times to simulate commuting until wet. Apply the function with x and y set at three, for the values 0.1, 0.5 and 0.9 for p. Use 10,000 repetitions for each simulation, with seeds that you report. Which value of p results in the smallest expected number of dry commutes? "],
["frames.html", "Chapter 7 Data Frames", " Chapter 7 Data Frames Can one be a good data analyst without being a half-good programmer? The short answer to that is, ‘No.’ The long answer to that is, ‘No.’ —Frank Harrell Up to this point we have given a great deal of attention to vectors, and we have always treated them as one-dimensional objects: a vector has a length, but not a “width.” It is time to begin working in two dimensions. In this Chapter we will study matrices, which are simply vectors that have both length and width. Matrices are immensely useful for scientific computation in R, but for the most part we will treat them as a warm-up for data frames—the two-dimensional R-objects that are especially designed for the storage of data collected in the course of practical data analysis. Once you understand how to construct and manipulate data frames, you will be ready to learn how to visualize and analyze data using R. "],
["introduction-to-matrices.html", "7.1 Introduction to Matrices", " 7.1 Introduction to Matrices In R, a matrix is actually an atomic vector—it can only hold one type of element—but with two extra attributes: a certain number of rows, and a certain number of columns. One way to create is matrix is to take a vector and give it those two extra attributes, via the matrix() function. Here is an example: numbers &lt;- 1:24 # this is an ordinary atomic vector numbersMat &lt;- matrix(numbers, nrow = 6, ncol = 4) # make a matrix numbersMat ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 2 8 14 20 ## [3,] 3 9 15 21 ## [4,] 4 10 16 22 ## [5,] 5 11 17 23 ## [6,] 6 12 18 24 Of course if you are making a matrix out of 24 numbers and you know that it’s going to have 6 rows, then you know it must have 4 columns. Similarly, if you know the number of columns then the number of rows is determined. Hence you could have constructed the matrix with just one of the row or column arguments, like this: numbersMat &lt;- matrix(numbers, nrow = 6) Notice that the numbers went down the first column, then down the second, and so on. If you would rather fill up the matrix row-by-row, then set the byrow parameter, which is FALSE by default, to TRUE: matrix(numbers, nrow = 6, byrow = TRUE) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 ## [5,] 17 18 19 20 ## [6,] 21 22 23 24 Sometimes we like to give names to our rows, or to our columns, or even to both: rownames(numbersMat) &lt;- letters[1:6] colnames(numbersMat) &lt;- LETTERS[1:4] numbersMat ## A B C D ## a 1 7 13 19 ## b 2 8 14 20 ## c 3 9 15 21 ## d 4 10 16 22 ## e 5 11 17 23 ## f 6 12 18 24 Matrices don’t have to be numerical. They can be character or logical matrices as well: creatures &lt;- c(&quot;Dorothy&quot;, &quot;Lion&quot;, &quot;Scarecrow&quot;, &quot;Oz&quot;, &quot;Toto&quot;, &quot;Boq&quot;) matrix(creatures, ncol = 2) ## [,1] [,2] ## [1,] &quot;Dorothy&quot; &quot;Oz&quot; ## [2,] &quot;Lion&quot; &quot;Toto&quot; ## [3,] &quot;Scarecrow&quot; &quot;Boq&quot; If you have to spread out the elements of a matrix into a one-dimensional vector, you can do so: as.vector(numbersMat) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 7.1.1 Practice Exercises Let’s work with the following vector: dozen &lt;- letters[1:12] Starting with dozen write a command that produces the following matrix: ## [,1] [,2] [,3] [,4] ## [1,] &quot;a&quot; &quot;d&quot; &quot;g&quot; &quot;j&quot; ## [2,] &quot;b&quot; &quot;e&quot; &quot;h&quot; &quot;k&quot; ## [3,] &quot;c&quot; &quot;f&quot; &quot;i&quot; &quot;l&quot; Starting with dozen write a command that produces the following matrix: ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;e&quot; &quot;i&quot; ## [2,] &quot;b&quot; &quot;f&quot; &quot;j&quot; ## [3,] &quot;c&quot; &quot;g&quot; &quot;k&quot; ## [4,] &quot;d&quot; &quot;h&quot; &quot;l&quot; Starting with dozen write a command that produces the following matrix: ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; ## [3,] &quot;g&quot; &quot;h&quot; &quot;i&quot; ## [4,] &quot;j&quot; &quot;k&quot; &quot;l&quot; Starting with dozen, write commands that produce the following matrix: ## c1 c2 c3 ## r1 &quot;a&quot; &quot;b&quot; &quot;c&quot; ## r2 &quot;d&quot; &quot;e&quot; &quot;f&quot; ## r3 &quot;g&quot; &quot;h&quot; &quot;i&quot; ## r4 &quot;j&quot; &quot;k&quot; &quot;l&quot; Suppose you make the following matrix: smallMat &lt;- matrix(c(8, 5, 3, 4), nrow =2) smallMat ## [,1] [,2] ## [1,] 8 3 ## [2,] 5 4 What’s a one-line command to get the folowing vector from smallMat? ## [1] 8 5 3 4 nrow() is a function that, when given a matrix, will tell you the number of rows in that matrix. Write a one-line command to find the number of rows in a matrix called mysteryMat. ncol() is a function that, when given a matrix, will tell you the number of rows in that matrix. Write a one-line command to find the number of columns in a matrix called mysteryMat. 7.1.2 Solutions to Practice Exercises Here’s one way to do it: matrix(dozen, nrow = 3) Here’s another way: matrix(dozen, ncol = 4) Here’s one way to do it: matrix(dozen, nrow = 4) Here’s one way to do it: matrix(dozen, nrow = 4, byrow = TRUE) Here’s one way to do it: answerMatrix &lt;- matrix(dozen, nrow = 4, byrow = TRUE) rownames(answerMatrix) &lt;- c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;) colnames(answerMatrix) &lt;- c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;) answerMatrix Here’s how: as.vector(smallMat) The command nrow(mysteryMat) will work. The command ncol(mysteryMat) will work. "],
["matrix-indexing.html", "7.2 Matrix Indexing", " 7.2 Matrix Indexing Matrices are incredibly useful in data analysis, but the primary reason we are talking about them now is to get you used to working in two dimensions. Let’s practice sub-setting with matrices. We use the sub-setting operator [ to pick out parts of a matrix. For example, in order to get the element in the second row and third column of numbersMat, ask for: numbersMat[2,3] ## [1] 14 The row and column numbers are called indices. If we want the entire second row, then we could ask for: numbersMat[2,1:4] ## A B C D ## 2 8 14 20 The result is a one-dimensional vector consisting of the elements in the second row of numbersMat. It inherits as its names the column names of numbersMat. Actually, if you want the entire row you don’t have to specify which columns you want. Just leave the spot after the comma empty, like this: numbersMat[2, ] ## A B C D ## 2 8 14 20 What if you want some items on the second row, but only the items in columns 1, 2 and 4? Then frame your request in terms of a vector of column-indices: numbersMat[2, c(1, 2, 4)] ## A B D ## 2 8 20 You can specify a vector of row-indices along with a vector of column-indices, if you like: numbersMat[1:2, 1:3] ## A B C ## a 1 7 13 ## b 2 8 14 If the vector has row or column names then you may use them in place of indices to make a selection: numbersMat[, c(&quot;B&quot;, &quot;D&quot;)] ## B D ## a 7 19 ## b 8 20 ## c 9 21 ## d 10 22 ## e 11 23 ## f 12 24 You can use sub-setting to change the values of the elements of a matrix numbersMat[2,3] &lt;- 0 numbersMat ## A B C D ## a 1 7 13 19 ## b 2 8 0 20 ## c 3 9 15 21 ## d 4 10 16 22 ## e 5 11 17 23 ## f 6 12 18 24 You can assign a value to an entire row: numbersMat[2,] &lt;- 0 numbersMat ## A B C D ## a 1 7 13 19 ## b 0 0 0 0 ## c 3 9 15 21 ## d 4 10 16 22 ## e 5 11 17 23 ## f 6 12 18 24 In the code above, the 0 was “recycled” into each of the four elements of the second row You can assign the elements of a vector to corresponding selected elements of a matrix: numbersMat[2,] &lt;- c(100, 200, 300, 400) numbersMat ## A B C D ## a 1 7 13 19 ## b 100 200 300 400 ## c 3 9 15 21 ## d 4 10 16 22 ## e 5 11 17 23 ## f 6 12 18 24 7.2.1 To Drop or Not? Note that when we ask for a single row of numbersMat we got a regular one-dimensional vector: numbersMat[3, ] ## A B C D ## 3 9 15 21 The same things happens if we ask for a single column: numbersMat[ , 2] ## a b c d e f ## 7 200 9 10 11 12 We get the second column of numbersMat, but as a regular vector. It’s not a “column” anymore. (Note that it inherits the row names from numbersMat.) When a subset of a matrix comes from only one row or column, R takes the opportunity to “drop” the class of the subset from “matrix” to “vector.” If you would like the subset to stay a vector, set the drop parameter, which by default is TRUE, to FALSE. Thus the second column of numbersMat, kept as a matrix with six rows and one column, is found as follows: numbersMat[ , 2, drop = FALSE] ## B ## a 7 ## b 200 ## c 9 ## d 10 ## e 11 ## f 12 In most applications people want the simpler vector structure, so they usually leave drop at its default value. 7.2.2 Practice Exercises In these exercises we’ll work with the following matrix: numbers &lt;- 1:40 practiceMatrix &lt;- matrix(numbers, nrow = 4) rownames(practiceMatrix) &lt;- letters[1:4] colnames(practiceMatrix) &lt;- LETTERS[1:10] practiceMatrix ## A B C D E F G H I J ## a 1 5 9 13 17 21 25 29 33 37 ## b 2 6 10 14 18 22 26 30 34 38 ## c 3 7 11 15 19 23 27 31 35 39 ## d 4 8 12 16 20 24 28 32 36 40 Write two different one-line commands to get this matrix: ## B C D E ## a 5 9 13 17 ## c 7 11 15 19 Write a one-line command to get this matrix: ## A C E G I ## a 1 9 17 25 33 ## b 2 10 18 26 34 ## c 3 11 19 27 35 ## d 4 12 20 28 36 Write a one-line command to get this vector: ## a b c d ## 1 2 3 4 Write a one-line command to get this vector: ## A B C D E F G H I J ## 2 6 10 14 18 22 26 30 34 38 Write a one-line command to get this matrix: ## A ## a 1 ## b 2 ## c 3 ## d 4 Write a convenient one-line command to get this matrix: ## A B C D E F G H I ## a 1 5 9 13 17 21 25 29 33 ## b 2 6 10 14 18 22 26 30 34 ## c 3 7 11 15 19 23 27 31 35 ## d 4 8 12 16 20 24 28 32 36 Write a convenient one-line command to get this matrix: ## A C D E F G H I ## a 1 9 13 17 21 25 29 33 ## b 2 10 14 18 22 26 30 34 ## c 3 11 15 19 23 27 31 35 ## d 4 12 16 20 24 28 32 36 Write a function called myRowSums() that will find the sums of the rows of any given matrix. The function should use a for-loop (see the Chapter on Flow Control). The function should take a single parameter called mat, the matrix whose rows the user wishes to sum. It should work like this: myMatrix &lt;- matrix(1:24, ncol = 6) myRowSums(mat = myMatrix) ## [1] 66 72 78 84 7.2.3 Solutions to Practice Exercises Here are two ways: practiceMatrix[c(1,3), 2:5] practiceMatrix[c(&quot;a&quot;,&quot;c&quot;), 2:5] Here’s one way: practiceMatrix[ , seq(1, 9, by = 2)] Here’s one way: practiceMatrix[ , 1] Here’s one way: practiceMatrix[2, ] Here’s one way: practiceMatrix[ , 1, drop = FALSE] Here’s one way: practiceMatrix[ , -10] Here’s one way: practiceMatrix[ , -c(2, 10)] Here is one way to write the function: myRowSums &lt;- function(mat) { n &lt;- nrow(mat) sums &lt;- numeric(n) for (i in 1:n) { sums[i] &lt;- sum(mat[i, ]) } sums } "],
["operations-on-matrices.html", "7.3 Operations on Matrices", " 7.3 Operations on Matrices Matrices can be involved in arithmetical and logical operations. 7.3.1 Arithmetical Operations The usual arithmetic operations apply to matrices, operating element-wise. For example, suppose that we have: mat1 &lt;- matrix(rep(1, 4), nrow = 2) mat2 &lt;- matrix(rep(2, 4), nrow = 2) To get the sum of the above two matrices, R adds their corresponding elements and forms a new matrix out of their sums, thus: mat1 + mat2 ## [,1] [,2] ## [1,] 3 3 ## [2,] 3 3 R applies recycling as needed. For example, suppose we have: mat &lt;- matrix(1:4, nrow = 2) mat ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 In order to multiply each element of mat by 2, we need not create a 2-by-2 matrix of 2’s. We can simply multiply by 2, and R will take care of recycling the 2: 2 * mat ## [,1] [,2] ## [1,] 2 6 ## [2,] 4 8 Or we could subtract 3 from each element of mat: mat - 3 ## [,1] [,2] ## [1,] -2 0 ## [2,] -1 1 7.3.2 Matrix Multiplication This section is optional reading, but it may interest you if you know about matrix multiplication in linear algebra. In order to accomplish matrix multiplication, we have to keep in mind that the regular multiplication operator * works element-wise on matrices, as we have already seen. For matrix multiplication R provides the special operator %*%. For example, consider the following matrices: a &lt;- matrix(1:6, ncol = 3) a ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 b &lt;- matrix(c(2, 1, -1), nrow = 3) b ## [,1] ## [1,] 2 ## [2,] 1 ## [3,] -1 Observe that the number of columns of a is equal to the number of rows of b. Hence it is possible to form the matrix product a %*% b: a %*% b ## [,1] ## [1,] 0 ## [2,] 2 As expected, the result is a matrix having as many rows as the rows of aand as many columns as the columns of b. It is also interesting to recall how matrix multiplication works when the second matrix has only one column. The product is obtained by multiplying each column of a by the element on the corresponding row of b, and adding the resulting matrices: b[1,1]*a[ ,1, drop = FALSE] + b[2,1, drop = FALSE]*a[ ,2] + b[3,1]*a[ ,3, drop = FALSE] ## [,1] ## [1,] 0 ## [2,] 2 7.3.3 Logical Operations Boolean operations apply to matrices element-wise, just as they do to ordinary vectors. The result is a matrix of logical values. For examples, consider the original matrix numbersMat: numbersMat &lt;- matrix(1:24, nrow = 6) Suppose we wish to determine which elements of numbersMat are odd. Then we simply ask whether the remainder of an element after division by 2 is equal to 1: numbersMat %% 2 == 1 ## [,1] [,2] [,3] [,4] ## [1,] TRUE TRUE TRUE TRUE ## [2,] FALSE FALSE FALSE FALSE ## [3,] TRUE TRUE TRUE TRUE ## [4,] FALSE FALSE FALSE FALSE ## [5,] TRUE TRUE TRUE TRUE ## [6,] FALSE FALSE FALSE FALSE We can select elements from a matrix using a Boolean operator, too: numbersMat[numbersMat %% 2 == 1] ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 Note that the result is an ordinary, one-dimensional vector. 7.3.4 Practice Exercises We’ll work with the following three matrices: a &lt;- matrix(c(7, 4, 9, 10), nrow = 2) a ## [,1] [,2] ## [1,] 7 9 ## [2,] 4 10 b &lt;- matrix(1:4, nrow = 2) b ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 c &lt;- matrix(letters[1:24], nrow = 6, byrow = TRUE) c ## [,1] [,2] [,3] [,4] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## [2,] &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; ## [3,] &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; ## [4,] &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; ## [5,] &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; ## [6,] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; Find a one-line command using a that results in: ## [,1] [,2] ## [1,] 10 12 ## [2,] 7 13 Find a one-line command using a that results in: ## [,1] [,2] ## [1,] 14 18 ## [2,] 8 20 Find a one-line command using a that results in: ## [,1] [,2] ## [1,] 49 81 ## [2,] 16 100 Find a one-line command using a and b that results in: ## [,1] [,2] ## [1,] 6 6 ## [2,] 2 6 Describe in words what the following command does: a &gt; 5 Write a one-line command using a that tells you which elements of a are one more than a multiple of 3. Using c, write a one-line boolean expression that produces the following: ## [,1] [,2] [,3] [,4] ## [1,] FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE TRUE ## [3,] TRUE TRUE TRUE TRUE ## [4,] TRUE TRUE TRUE TRUE ## [5,] TRUE TRUE TRUE TRUE ## [6,] TRUE TRUE TRUE TRUE 7.3.5 Solutions to Practice Exercises Here’s one way: a + 3 Here’s one way: 2 * a Here’s one way: a^2 Here’s one way: ```r a - b ``` It produces a logical matrix of the same dimensions as a. The new matrix will have TRUE in a cell when the corresponding cell of a is greater than 5. Otherwise, the cell will have FALSE in it. Here’s one way: a %% 3 == 1 Here’s one way: c &gt;= &quot;h&quot; "],
["introduction-to-data-frames.html", "7.4 Introduction to Data Frames", " 7.4 Introduction to Data Frames R is known as a domain-specific programming language, meaning that although it can in principle perform any sort of computation that a human can perform (given enough pencil, paper and time), it was originally designed to perform tasks in a particular area of application. R’s area of application is data analysis and statistics, especially when performed interactively—i.e., in a setting where the analyst asks for a relatively small computation, examines the results, modifies his or her requests and asks again, and so on.23 Although R can be used effectively for a wide range of programming tasks, data analysis is where it really shines. The data structures of R reflect its orientation to data analysis. We have met a data-oriented structure already—the table, which is one of many convenient ways to display the results of data analysis. For the purpose of organizing data in preparation for analysis, R provides the structure known as the data frame. A data frame facilitates the storage of related data in one location, in a form that makes the most sense to human users. A data frame is like a matrix in that it is two-dimensional—it has rows and columns. Unlike a matrix, though, the elements of a data frame do not have to be all of the same data-type. Each column of a data frame is a vector—of the same length as all the others—but these vectors may be of different types: some numerical, some logical, etc. 7.4.1 Viewing a Data Frame Let’s take a close look at a data frame: the frame m111survey, which is available from the bcscr package (White 2020). First let’s attach the package itself: library(bcscr) In the R Studio IDE, we can get a look at the frame in a tab in the Editor pane if we use the View() function: View(m111survey) As with many objects provided by a package, we can get more information about it: help(&quot;m111survey&quot;) From the Help we see that m111survey records the results of a survey conducted in a number of sections of an elementary statistics course at Georgetown College. From the View we see that the frame is arranged in rows and columns. Each row corresponds to what in data analysis is known as a case or an individual: here, each row goes with a student who participated in the survey. The columns correspond to variables: measurements made on each individual. For a student on a given row, the values in the columns are the values recorded for that student. When you are not working in R Studio, there are still a couple of way so view the frame. You could print it all out to the console: m111survey You could also use the head() function to view a specified number of initial rows: head(m111survey, n = 6) # see first six rows 7.4.2 The Stucture of a Data Frame Further information about the frame may be obtained with the str() function: str(m111survey) ## &#39;data.frame&#39;: 71 obs. of 12 variables: ## $ height : num 76 74 64 62 72 70.8 70 79 59 67 ... ## $ ideal_ht : num 78 76 NA 65 72 NA 72 76 61 67 ... ## $ sleep : num 9.5 7 9 7 8 10 4 6 7 7 ... ## $ fastest : int 119 110 85 100 95 100 85 160 90 90 ... ## $ weight_feel : Factor w/ 3 levels &quot;1_underweight&quot;,..: 1 2 2 1 1 3 2 2 2 3 ... ## $ love_first : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ extra_life : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 2 2 1 1 2 1 2 2 2 1 ... ## $ seat : Factor w/ 3 levels &quot;1_front&quot;,&quot;2_middle&quot;,..: 1 2 2 1 3 1 1 3 3 2 ... ## $ GPA : num 3.56 2.5 3.8 3.5 3.2 3.1 3.68 2.7 2.8 NA ... ## $ enough_Sleep : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 1 1 1 1 2 1 2 1 2 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 2 1 1 2 2 2 2 1 1 ... ## $ diff.ideal.act.: num 2 2 NA 3 0 NA 2 -3 2 0 ... The concept of structure extends far beyond the domain of computer programming.24 In general the structure of any object consists of: the kind of thing that the object is; the parts of the object is made up of; the relationships between these parts—the rules, if you will, for how the parts work together to make the object do what it does. In the case of m111survey the kind of thing this is its class: it’s a data frame. class(m111survey) ## [1] &quot;data.frame&quot; Next we see the account of the parts of the object and the way in which the parts relate to one another: ## 71 obs. of 12 variables From this we know that there are 71 individuals in the study. The data consists of 12 “parts”—the variables—which are related in the sense that they all provide information about the same set of 71 people. After that the output of str() launches into an account of the structure of each of the parts, for example: ## $ height : num 76 74 64 62 72 70.8 70 79 59 67 ... We are told the kind of thing that height is: it’s a numerical vector (a vector of type double, in fact). Next we are given the beginning of a statement of its parts: the heights of the individuals. So R is actually giving us the structure of the parts, as well as of the whole m11survey. The variable fastest refers to the fastest speed—in miles per hour—that a person has ever driven a car. Note that it is a vector of type integer. Officially this is a numerical variable, too, but R is calling attention to the fact that the fastest-speed data is being stored as integers rather than as floating-point decimals. The variables of a data frame are typically associated with the names of the frame: names(m111survey) ## [1] &quot;height&quot; &quot;ideal_ht&quot; &quot;sleep&quot; &quot;fastest&quot; &quot;weight_feel&quot; ## [6] &quot;love_first&quot; &quot;extra_life&quot; &quot;seat&quot; &quot;GPA&quot; &quot;enough_Sleep&quot; ## [11] &quot;sex&quot; &quot;diff.ideal.act.&quot; By means of the names we can isolate a vector in any column, identified in our code in the format frame$variable. For example, to see the first ten elements of the fastest variable, we ask for: m111survey$fastest[1:10] ## [1] 119 110 85 100 95 100 85 160 90 90 In order to compute the mean fastest speed our subjects drove their cars, we can ask for: mean(m111survey$fastest, na.rm = TRUE) ## [1] 105.9014 If you want to see the speeds that are at least 150 miles per hour, you could ask for: m111survey$fastest[m111survey$fastest &gt;= 150] ## [1] 160 190 If you worry that the form frame$variable will require an annoying amount of typing—as seems to be the case in the the example above—then you can use the with() function: with(m111survey, fastest[fastest &gt;=150]) ## [1] 160 190 It’s instructive to consider how with() works. If we were to includes the names of the parameters of with() explicitly, then the call would have looked like this: with(data = m111survey, expr = fastest[fastest &gt;=150]) For the data parameter we can supply a data frame or any other R-object that can be used to construct an environment . In this case m111survey provides a miniature environment consisting of the names of its variables. For the expr parameter we supply an expression for R to evaluate. As R evaluates the expression, it encounters names (such as fastest). Now ordinarily R would first search whatever counts as the active environment—in this case it’s the Global Environment—for the names in the expression, but with() forces R to look first within the environment created by the data argument. In our example, R finds fastest inside m111survey and evaluates the expression on that basis. If it had not found fastest in m111survey, R would have moved on to the Global Environment and then the rest of the usual search path and (probably) would have found nothing, causing it to throw an “object not found” error message. In R, as in any other programming language, good programming depends very much on paying attention to how the language searches for the objects to which names refer. 7.4.3 Factors Some of the variables in m111survey are called factors; an example is seat, which pertains to where one prefers to sit in a classroom: str(m111survey$seat) ## Factor w/ 3 levels &quot;1_front&quot;,&quot;2_middle&quot;,..: 1 2 2 1 3 1 1 3 3 2 ... Seating preference is an example of a categorical variable: one whose values are not meaningfully expressed in terms of numbers. When a categorical variable has a relatively small number of possible values, it can be convenient to store its values in a vector of class factor. The levels of factor variable are its possible values. In the case of seat, these are: Front, Middle and Back. As a memory-saving measure, R stores the values in the factor as numbers, where 1 stands for the first level, 2 for the second level, and so on. But please bear in mind that we are dealing with a categorical variable, so the numbers don’t relate to the possible values in any natural way: they are just storage conventions. It’s possible to create a factor from any type of vector, but most often this is done with a character vector. Suppose for instance, that eight people are asked for their favorite Wizard of Oz character and they answer: ozFavs &lt;- c(&quot;Glinda&quot;, &quot;Toto&quot;, &quot;Toto&quot;, &quot;Dorothy&quot;, &quot;Toto&quot;, &quot;Glinda&quot;, &quot;Scarecrow&quot;, &quot;Dorothy&quot;) We can create a factor variable as follows: factorFavs &lt;- factor(ozFavs) factorFavs ## [1] Glinda Toto Toto Dorothy Toto Glinda Scarecrow Dorothy ## Levels: Dorothy Glinda Scarecrow Toto Note that the levels are given in alphabetical order: this is the default procedure when R creates a factor. It is possible to ask for a different order, though: factor(ozFavs, levels = c(&quot;Toto&quot;, &quot;Scarecrow&quot;, &quot;Glinda&quot;, &quot;Dorothy&quot;)) ## [1] Glinda Toto Toto Dorothy Toto Glinda Scarecrow Dorothy ## Levels: Toto Scarecrow Glinda Dorothy In many instances it is appropriate to convert a character vector to a factor, but sometimes this is not such a great idea. Consider something like your address, or your favorite inspirational quote: pretty much every person in a study will have a different address or favorite quote than others in the study. Hence there won’t be any memory-storage benefit associated with creating a factor: the vector of levels—itself a character vector—would require as much storage space as the original character vector itself! In addition, we will see that the status of a variable as class “factor” can affect how R’s statistical and graphical functions deal with it. It’s not a good idea to treat a categorical variable as a factor unless its set of possible values is considered important. We will think more about how to deal with factor variables later on, when we begin data analysis in earnest. 7.4.4 Practice Exercises How would you learn more about the data frame RailTrail from the mosaicData package? Write a one-line command to see the first 10 rows of RailTrail in the Console. Write a one-line command to get the names of all of the variables in mosaicData::RailTrail. Regarding RailTrail: write a one-line command to get the high temperature on all the days when the precipitation was more than 0.5 inches. Regarding RailTrail: write a one-line command to sort the average temperatures from highest to lowest. 7.4.5 Solutions to the Practice Exercises One way is to attach, then then ask for help: library(mosaicData) help(RailTrail) Another way is to refer to the data frame through the package, with double colons: library(mosaicData::RailTrail) That way you don’t have to add all the items in mosaicData to your search path. Here’s one way: head(mosaicData::RailTrail, n = 10) It’s names(mosaicData::RailTrail). Here’s one way: with(mosaicData::RailTrail, hightemp[precip &gt; 0.5]) Try this: sort(mosaicData::RailTrail$avgtemp, decreasing = TRUE) References "],
["creating-data-frames.html", "7.5 Creating Data Frames", " 7.5 Creating Data Frames There are many ways to create data frames in R. Here we will introduce just two ways. 7.5.1 Creation from Vectors Whenever you have vectors of the same length, you can combine them into a data frame, using the data.frame() function: n &lt;- c(&quot;Dorothy&quot;, &quot;Lion&quot;, &quot;Scarecrow&quot;) h &lt;- c(58, 75, 69) a &lt;- c(12, 0.04, 18) ozFolk &lt;- data.frame(name = n, height = h, age = a) ozFolk ## name height age ## 1 Dorothy 58 12.00 ## 2 Lion 75 0.04 ## 3 Scarecrow 69 18.00 Note that at the time of creation you can provide the variables with any names that you like. If later on you change your mind about the names, you can always revise them: names(ozFolk) ## [1] &quot;name&quot; &quot;height&quot; &quot;age&quot; names(ozFolk)[2] &lt;- &quot;Height&quot; # &quot;height&quot; was at index 2&quot; ozFolk ## name Height age ## 1 Dorothy 58 12.00 ## 2 Lion 75 0.04 ## 3 Scarecrow 69 18.00 Let’s check the structure of the frame we have made: str(ozFolk) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ name : Factor w/ 3 levels &quot;Dorothy&quot;,&quot;Lion&quot;,..: 1 2 3 ## $ Height: num 58 75 69 ## $ age : num 12 0.04 18 Maybe we would prefer that the name variable not be a factor. We have a couple of options to accomplish this. We could coerce names to a character variable, and assign it to the data frame: ozFolk$name &lt;- as.character(ozFolk$name) str(ozFolk) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ name : chr &quot;Dorothy&quot; &quot;Lion&quot; &quot;Scarecrow&quot; ## $ Height: num 58 75 69 ## $ age : num 12 0.04 18 We could prevent names from being made into a factor at the time of creation: ozFolk &lt;- data.frame(name = n, height = h, age = a, stringsAsFactors = FALSE) str(ozFolk) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ name : chr &quot;Dorothy&quot; &quot;Lion&quot; &quot;Scarecrow&quot; ## $ height: num 58 75 69 ## $ age : num 12 0.04 18 7.5.2 Creation From Other Frames If two frames have the same number of rows, you may combine their columns to form a new frame with the cbind() function: ozMore &lt;- data.frame( color = c(&quot;blue&quot;, &quot;red&quot;, &quot;yellow&quot;), desire = c(&quot;Kansas&quot;, &quot;courage&quot;, &quot;brains&quot;)) cbind(ozFolk, ozMore) ## name height age color desire ## 1 Dorothy 58 12.00 blue Kansas ## 2 Lion 75 0.04 red courage ## 3 Scarecrow 69 18.00 yellow brains Similarly if two data frames have the same number and type of columns then we can use the rbind() function to combine them: ozFolk2 &lt;- data.frame(name = c(&quot;Toto&quot;, &quot;Glinda&quot;), height = c(12, 66), age = c(3, 246), stringsAsFactors = FALSE) rbind(ozFolk, ozFolk2) ## name height age ## 1 Dorothy 58 12.00 ## 2 Lion 75 0.04 ## 3 Scarecrow 69 18.00 ## 4 Toto 12 3.00 ## 5 Glinda 66 246.00 Note: cbind() and rbind() work for matrices, too. "],
["subsetting-data-frames.html", "7.6 Subsetting Data Frames", " 7.6 Subsetting Data Frames Our study of sub-setting matrices can be applied to the selection of parts of a data frame. As with a vector, one or both of the dimensions of the frame can come into play. We can create a new data frame consisting of any columns we like from the original frame: df &lt;- m111survey[, c(&quot;height&quot;, &quot;ideal_ht&quot;)] head(df) ## height ideal_ht ## 1 76.0 78 ## 2 74.0 76 ## 3 64.0 NA ## 4 62.0 65 ## 5 72.0 72 ## 6 70.8 NA If we select just one column, then the result is a vector rather than a data frame: df &lt;- m111survey[, &quot;height&quot;] is.vector(df) ## [1] TRUE If for some reason you want to prevent this, set drop to FALSE: df &lt;- m111survey[, &quot;height&quot;, drop =FALSE] head(df) ## height ## 1 76.0 ## 2 74.0 ## 3 64.0 ## 4 62.0 ## 5 72.0 ## 6 70.8 You may select particular rows, too: m111survey[10:15, c(&quot;height&quot;, &quot;ideal_ht&quot;)] ## height ideal_ht ## 10 67 67 ## 11 65 69 ## 12 62 62 ## 13 59 62 ## 14 78 75 ## 15 69 72 You can even select some of the rows at random. Here is a random sample of size six: n &lt;- nrow(m111survey) df &lt;- m111survey[sample(1:n, size = 6, replace = FALSE), ] df[c(&quot;sex&quot;, &quot;seat&quot;)] # show just two columns ## sex seat ## 13 female 1_front ## 54 male 2_middle ## 56 male 3_back ## 28 female 1_front ## 53 female 3_back ## 46 female 2_middle Note the function nrow() that gives the number of rows of the frame. When we sample six items without replacement from the vector 1:n, we are picking six numbers at random from the row-numbers of the vector. Specifying these six numbers in the selection operator [ yields the desired random sample of rows. 7.6.1 Boolean Expressions It is especially common to select rows by the values of a logical vector. For example, to select the rows where the fast speed ever driven is at least 150 miles per hour, try this: df &lt;- m111survey[m111survey$fastest &gt;= 150, ] df[, c(&quot;sex&quot;, &quot;fastest&quot;)] # show just two of the variables ## sex fastest ## 8 male 160 ## 32 male 190 When you are selecting rows it can be convenient to use the subset() function. The first argument to the function is the frame from which you plan to select, and the second is the Boolean expression by which to select: df &lt;- subset(m111survey, fastest &gt;= 150) df[, c(&quot;sex&quot;, &quot;fastest&quot;)] ## sex fastest ## 8 male 160 ## 32 male 190 Note that we did not need to type m111survey$fastest: the first argument to subset() provides the environment in which to search for names that appear in the Boolean expression. The Boolean sub-setting expressions can be quite complex: df &lt;- subset(m111survey, seat == &quot;3_back&quot; &amp; height &lt; 72 &amp; sex == &quot;female&quot;) df[, c(&quot;sex&quot;, &quot;height&quot;, &quot;seat&quot;)] ## sex height seat ## 9 female 59 3_back ## 20 female 65 3_back ## 30 female 69 3_back ## 53 female 69 3_back ## 70 female 65 3_back Note: subset() takes a third parameter called select that allows you to pick out any desired columns. For example: subset(m111survey, seat == &quot;3_back&quot; &amp; height &lt; 72 &amp; sex == &quot;female&quot;, select = c(&quot;sex&quot;, &quot;height&quot;, &quot;seat&quot;)) ## sex height seat ## 9 female 59 3_back ## 20 female 65 3_back ## 30 female 69 3_back ## 53 female 69 3_back ## 70 female 65 3_back 7.6.2 Practice Exercises We’ll use the CPS85 data frame from the mosaicData package. You should go ahead and load the package and then read about the data frame: library(mosaicData) ?CPS85 Each row in the data frame corresponds to an employee in the survey. Write a command that gives the number of employees in the data frame. Select the employees who are between 40 and 50 years old. Select the employees who are married and have fewer than 30 years of experience. Select the nonunion employees who either live in the South or who have more than 12 years of education (or both). Select the employees who work in the clerical, construction, management or professional sector. Select the employees who make more than 30 dollars per hour, and keep only their wage, sex and sector of employment Select 10 employees at random, keeping only their wage and sex. Select all of the employees, keeping all information about them except for their union status and whether or not they are from the South. 7.6.3 Solutions to Practice Exercises The command is nrow(CPS85). Try this: subset(CPS85, age &gt; 40 &amp; age &lt; 50) Try this: subset(CPS85, married == &quot;Married&quot; &amp; exper &lt; 30) Try this: subset(CPS85, union == &quot;Not&quot; &amp; (south == &quot;S&quot; | educ &gt; 12)) Try this: subset(CPS85, sector %in% c(&quot;clerical&quot;, &quot;construction&quot;, &quot;management&quot;, &quot;professional&quot;)) Try this: CPS85[CPS85$wage &gt; 30, c(&quot;wage&quot;, &quot;sex&quot;, &quot;sector&quot;)] Try this: CPS85[sample(1:nrow(CPS85), size = 10, replace = FALSE), c(&quot;wage&quot;, &quot;sex&quot;)] Try this (south and union are columns 6 and 9, respectively): CPS85[ , -c(6, 9)] The select parameter of the subset() function has a little known feature that allows you to specify columns to omit by name, so the following is another solution: subset(CPS85, select = -c(south, union)) "],
["ordering-data-frames.html", "7.7 Ordering Data Frames", " 7.7 Ordering Data Frames You can reorder as well as select. For example, the following code selects the first five rows ofm111survey and then reverses them: df &lt;- m111survey[, c(&quot;height&quot;, &quot;ideal_ht&quot;)] dfRev &lt;- df[5:1, ] head(dfRev) ## height ideal_ht ## 5 72 72 ## 4 62 65 ## 3 64 NA ## 2 74 76 ## 1 76 78 If you want, you can even scramble the rows of the data frame in a random order: n &lt;- nrow(m111survey) shuffle &lt;- sample(1:n, size = n, replace = FALSE) df &lt;- m111survey[shuffle, ] head(df[c(&quot;sex&quot;, &quot;seat&quot;)]) #show just two columns ## sex seat ## 25 female 2_middle ## 51 female 2_middle ## 69 female 1_front ## 52 female 2_middle ## 64 male 3_back ## 13 female 1_front It is quite common to order the rows of a frame according to the values of a particular variable. For example, you might want to arrange the rows by height, so that the frame begins with the shortest subject and ends with the tallest. Accomplishing this task requires a study of R’s order() function. Consider the following vector: vec &lt;- c(15, 12, 23, 7) Call order() with this vector as an argument: order(vec) ## [1] 4 2 1 3 order() returns the indices of the elements of vec, in the following order: the index of the smallest element (7, at index 4 of vec); the index of the second-smallest element (12, at index 2 of vec); the index of the third-smallest element (15, at index 1 of vec); the index of the largest element (23, at index 3 of vec). Can you guess the output of the following function-call without looking for the answer underneath? vec[order(vec)] ## [1] 7 12 15 23 Sure enough, the result is vec sorted: from smallest to largest element. Now the sorting of vec could have been accomplished with R’s sort()function: sort(vec) ## [1] 7 12 15 23 The power of order() comes with the rearrangement of rows of a data frame. In order to “sort” the frame from shortest to tallest subject, call: df &lt;- m111survey[order(m111survey$height), ] head(df[, c(&quot;sex&quot;, &quot;height&quot;)]) # to show that it worked ## sex height ## 45 female 51 ## 26 female 54 ## 9 female 59 ## 13 female 59 ## 40 female 60 ## 69 female 61 If you want to order the rows from tallest to shortest instead, then use the decreasing parameter, which by default is FALSE: df &lt;- m111survey[order(m111survey$height, decreasing = TRUE), ] head(df[, c(&quot;sex&quot;, &quot;height&quot;)]) # to show that it worked ## sex height ## 8 male 79 ## 14 female 78 ## 1 male 76 ## 58 male 76 ## 34 male 75 ## 54 male 75 Sometimes you want to order by two or more variables. For example suppose you want to arrange the frame so that the folks preferring to sit in front come first, followed by the people who prefer the middle and ending with the people who prefer the back. Within these groups you would like people to be arranged from shortest to tallest. Then call: ordering &lt;- with(m111survey, order(seat, height)) df &lt;- m111survey[ordering, ] head(df[, c(&quot;seat&quot;, &quot;height&quot;)], n = 10) # see if it worked ## seat height ## 45 1_front 51 ## 26 1_front 54 ## 13 1_front 59 ## 69 1_front 61 ## 4 1_front 62 ## 12 1_front 62 ## 23 1_front 63 ## 38 1_front 63 ## 61 1_front 63 ## 57 1_front 64 7.7.1 Practice Exercises Consider the following vector: creatures &lt;- c(&quot;Mole&quot;, &quot;Frog&quot;, &quot;Rat&quot;, &quot;Badger&quot;) Write down what you think will be the result of the call: order(creatures) Then check your answer by actually running: creatures &lt;- c(&quot;Mole&quot;, &quot;Frog&quot;, &quot;Rat&quot;, &quot;Badger&quot;) order(creatures) What will be the result of the following? order(creatures, decreasing = TRUE) Arrange the rows of the data frame mosaicData::CPS85 in order, from the lowest to the highest wage. Break ties by experience (less experience coming before more experience). Arrange the rows of the data frame mosaicData::CPS85 in order, from the lowest to the highest wage. Break ties by experience (more experience coming before less experience). 7.7.2 Solutions to Practice Exercises Here’s what you get: order(creatures) ## [1] 4 2 1 3 Here’s what you get: order(creatures, decreasing = TRUE) ## [1] 3 1 2 4 Here is one way: CPS85[order(CPS85$wage, CPS85$exper), ] Here is one way: CPS85[order(CPS85$wage, CPS85$exper, decreasing = c(FALSE, TRUE)), ] "],
["new-variables-from-old.html", "7.8 New Variables from Old", " 7.8 New Variables from Old Quite often you will want to transform one or more variables in a data frame. Transforming a variable means changing its values in a systematic way. For example, you might want to measure height in feet rather than inches. Then you want the following heightInFeet &lt;- with(m111survey, height/12) # 12 inches in a foot If you plan to use this new variable in your analysis later on, it might be a good idea to add it to the data frame: m111survey$height_ft &lt;- heightInFeet Another common need is to recode the values of a categorical variable. For example, you might want to divide people into two groups: those who prefer to sit in the back and those who don’t. This is a good time to use ifelse(): seat2 &lt;- ifelse(m111survey$seat == &quot;3_back&quot;, &quot;Back&quot;, &quot;Other&quot;) m111survey$seat2 &lt;- seat2 If you plan to re-code into a variable that involves more than two values, then you might want to look into the mapvalues() function from the plyr package (Wickham 2020): seat3 &lt;- plyr::mapvalues(m111survey$seat, from = c(&quot;1_front&quot;, &quot;2_middle&quot;, &quot;3_back&quot;), to = c(&quot;Front&quot;, &quot;Middle&quot;, &quot;Back&quot;)) str(seat3) ## Factor w/ 3 levels &quot;Front&quot;,&quot;Middle&quot;,..: 1 2 2 1 3 1 1 3 3 2 ... The do-it-yourself approach is to write a loop. Remember switch()? seat &lt;- m111survey$seat seat3 &lt;- character(length(seat)) # this will be the recoded variable for ( i in 1:length(seat) ) { seat3[i] &lt;- switch(as.character(seat[i]), &quot;1_front&quot; = &quot;Front&quot;, &quot;2_middle&quot; = &quot;Middle&quot;, &quot;3_back&quot; = &quot;Back&quot;) } str(seat3) ## chr [1:71] &quot;Front&quot; &quot;Middle&quot; &quot;Middle&quot; &quot;Front&quot; &quot;Back&quot; &quot;Front&quot; &quot;Front&quot; &quot;Back&quot; &quot;Back&quot; &quot;Middle&quot; ... The re-coding is done but the result is a character vector and not a factor. We have to make it a factor ourselves: m111survey$seat3 &lt;- factor(seat3, levels = c(&quot;Front&quot;, &quot;Middle&quot;, &quot;Back&quot;)) This seems like a lot of work! Another common transformation involves turning a numerical variable into a factor. For example, we might need to classify people as: Tall (height over 70 inches) Medium (65 - 70 inches) Short (less than 65 inches) The cut() function will be helpful. heightClass &lt;- cut(m111survey$height, breaks = c(-Inf, 65, 70, Inf), labels = c(&quot;Short&quot;, &quot;Medium&quot;,&quot;Tall&quot;), right = TRUE) str(heightClass) ## Factor w/ 3 levels &quot;Short&quot;,&quot;Medium&quot;,..: 3 3 1 1 3 3 2 3 1 2 ... Setting right = TRUE indicates that the upper bound of each interval is included in the interval. Thus, a person with a height of 70 inches is classed as Medium, not Tall. 7.8.1 Getting Rid of Variables We have added several variables to m111survey. In order to remove them (or any other variables we don’t want) we can assign them the value NULL. names(m111survey) ## [1] &quot;height&quot; &quot;ideal_ht&quot; &quot;sleep&quot; &quot;fastest&quot; &quot;weight_feel&quot; ## [6] &quot;love_first&quot; &quot;extra_life&quot; &quot;seat&quot; &quot;GPA&quot; &quot;enough_Sleep&quot; ## [11] &quot;sex&quot; &quot;diff.ideal.act.&quot; &quot;height_ft&quot; &quot;seat2&quot; &quot;seat3&quot; m111survey$height_ft &lt;- NULL m111survey$seat2 &lt;- NULL m111survey$seat3 &lt;- NULL names(m111survey) # the extra variables are gone ## [1] &quot;height&quot; &quot;ideal_ht&quot; &quot;sleep&quot; &quot;fastest&quot; &quot;weight_feel&quot; ## [6] &quot;love_first&quot; &quot;extra_life&quot; &quot;seat&quot; &quot;GPA&quot; &quot;enough_Sleep&quot; ## [11] &quot;sex&quot; &quot;diff.ideal.act.&quot; 7.8.2 Practice Exercises Remove the variables hispanic and married from the mosaicData::CPS85 data frame. Change the units of wage in mosaicData::CPS85 from dollars per hour to dollars per day. Assume an eight-hour working day. For CPS85, create a new variable experGrp that has the following values low for experience less than 10 years; medium for experience of at least 10 years but less than 25 years; high for experience at least 25 years. Using the experGrp variable in the previous exercise, create the following tally of the ages of the employees: ## experGrp ## low medium high ## 179 217 138 You’ve made some changes to CPS85, but in fact you haven’t changed the original data frame in the mosaicData package—you’ve simply made your own copy, which should now be in your Global Environment. Since the Global Environment comes before any package on your search path, if you want to get to the original CPS85 you will either have to refer to it as mosaicData::CPS85. Another option, though, is to remove the modified copy from your Global Environment. Go ahead and remove it now. 7.8.3 Solutions to Practice Exercises Here’s one way to do it: CPS85$hispanic &lt;- NULL CPS85$married &lt;- NULL Here’s one way to do it: CPS85$wage &lt;- CPS85$wage * 8 Here’s one way to do it: CPS85$experGrp &lt;- cut(CPS85$exper, breaks = c(-Inf, 10, 25, Inf), labels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) Use table(CPS85$experGrp). Here’s what to do: rm(CPS85) References "],
["glossary-5.html", "Glossary", " Glossary Matrix An atomic vector that has two additional attributes: a number of rows and a number of columns. Data Frame A two-dimensional data structure in R in which the columns are atomic vectors that can be of different types. Case (also called an Individual) An individual unit under study. In a data frame in R, the rows correspond to cases. Variable (in Data Analysis) In data analysis, a variable is a measurement made on the individuals in a study. Categorical Variable (in Data Analysis) In data analysis, a categorical variable is a variable whose values cannot be expressed meaningfully by numbers. "],
["frames-exercises.html", "Exercises", " Exercises R has a function called t() that computes the transpose of a given matrix. This means that it switches around the rows and columns of the matrix, like this: myMatrix &lt;- matrix(1:24, nrow = 6) myMatrix ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 2 8 14 20 ## [3,] 3 9 15 21 ## [4,] 4 10 16 22 ## [5,] 5 11 17 23 ## [6,] 6 12 18 24 t(myMatrix) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 ## [2,] 7 8 9 10 11 12 ## [3,] 13 14 15 16 17 18 ## [4,] 19 20 21 22 23 24 Write your own function called transpose() that will perform the same task on any given matrix. The function should take a single parameter called mat, the matrix to be transposed. Of course you may NOT use t() in the code for your function! Hints: Your function will have to: break mat down into the vector of its elements, and then build the new matrix from those elements, with a number of rows equal to the number of columns of mat. For the first task, as.vector() will be useful. For the second task, recall (see previous Practice Exercises from this Chapter) that there is a function nrow() that returns the number of rows of a given matrix. It will also be helpful to remember the function ncol() that computes the number of columns of a given matrix. R has functions called rowSums() and colSums() that will respectively sum the rows and the columns of a matrix. Here is an example: myMatrix &lt;- matrix(1:24, nrow = 6) rowSums(myMatrix) ## [1] 40 44 48 52 56 60 Your task is to write your own function called dimSum() that will sum either the rows or the columns of a given matrix. The function should have two parameters: mat: the matrix to be summed. dim: the dimension to sum along, either rows or columns. The default value should be &quot;rows&quot;. If the user sets dim to &quot;columns&quot; then the function would compute the column-sums. You may NOT use rowSums() or colSums() in the code for your function. A typical example of use should look like this: myMatrix &lt;- matrix(1:24, nrow = 6) dimSum(myMatrix) ## [1] 40 44 48 52 56 60 dimSum(myMatrix, &quot;columns&quot;) ## [1] 21 57 93 129 Hint: Recall that in previous Practice Exercises of this Chapter we made a function called myRowSums() that sums the rows of any given matrix. Modify the idea for myRowSums() to write a function called myColSums() that finds the column-sums of any given matrix. You may then use the two previously-created functions to write the required function dimsum(). Starting with m111survey in the bcscr package, write the code necessary to create a new data frame called smaller that consists precisely of the male students who believe in extraterrestrial life and who are more than 68 inches tall. The new data frame should contain all of the original variables except for sex and extra_life. Write a function called dfRandSelect() that randomly selects (without replacement) a specified number of rows from a given data frame. The function should have two parameters: df: the data frame from which to select; n: the number of rows to select. If n is greater than the number of rows in df, the function should return immediately with a message informing the user that the required task is not possible and informing him/her of the number of rows in df. Typical examples of use should be as follows: dfRandSelect(bcscr::fuel, 5) ## speed efficiency ## 12 120 9.87 ## 15 150 12.83 ## 7 70 6.30 ## 6 60 5.90 ## 8 80 6.95 dfRandSelect(bcscr::fuel, 200) ## No can do! The frame has only 15 rows. Hint: Use the function nrow(), which gives the number of rows of a matrix or data frame. (*) Create your own data frame, named myFrame. The frame should have 100 rows, along with the following variables: lowerLetters: a character vector randomly-produced 3-letter strings, like “chj”, “bbw”, and so on. The letters should all be lowercase. height: a numerical vector consisting of real numbers chosen randomly between the values of 60 and 75. sex: a factor whose possible value are “female” and “male”. Again, these values should be chosen randomly. A call to str(myFrame) would come out like this (although your results will vary a bit since the vectors are constructed randomly): str(myFrame) ## &#39;data.frame&#39;: 100 obs. of 3 variables: ## $ lowerLetters: chr &quot;usu&quot; &quot;uhl&quot; &quot;xyj&quot; &quot;uyd&quot; ... ## $ height : num 73.7 72.4 73.8 65.2 61.3 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 1 2 2 2 2 1 2 1 1 1 ... summary() is useful when working with data frames. Here is how a call to summary(myFrame) might look: summary(myFrame) ## lowerLetters height sex ## Length:100 Min. :60.00 female:57 ## Class :character 1st Qu.:63.63 male :43 ## Mode :character Median :68.28 ## Mean :67.62 ## 3rd Qu.:71.63 ## Max. :74.57 Hint: If you have a vector of three letters, such as vec &lt;- c(&quot;g&quot;, &quot;a&quot;, &quot;r&quot;) then you can paste them together as follows: paste0(vec, collapse = &quot;&quot;) ## [1] &quot;gar&quot; (*) Study the data frame fuel in the bcscr package. Note that the fuel efficiency is reported as the number of liters of fuel required to travel 100 kilometers. Look up the conversion between gallons and liters and between kilometers and miles, and use this information to create a new variable called mpg that gives the fuel efficiency as miles per gallon. While you are at it, create a new variable mph that gives the speed in miles per hour. Finally, add these new variables to the fuel data frame. (*) Use matrices to generalize the simulation in the Appeals Court Paradox (see Section 6.5). Your goal is to write a simulation function called appealsSimPlus() that comes with all the options provided in the text, but with additional parameters so that the user can choose: the number of judges on the court; the probability for each judge to make a correct decision; the voting pattern (how many votes each judge gets). A typical call to the functions should look like this: appealsSimPlus(reps = 10000, seed = 5252, probs = c(0.95, 0.90, 0.90, 0.90, 0.80), votes = c(2, 1, 1, 1, 0)) In the above call the court consists of five judges. The best one decides cases correctly 95% of the time, three are right 90% of the time and one is right 80%of the time. The voting arrangement is that the best judge gets two votes, the next three get one vote each, and the worst gets no vote. Any voting scheme—even a scheme involving fractional votes—should be allowed so long as the votes add up to the number of judges. Here is a hint. When you write the function it may be helpful to use the fact that rbinom() can take a prob parameter that is a vector of any length. Here’s an example: results &lt;- rbinom(6, size = 100, prob = c(0.10, 0.50, 0.90)) results ## [1] 20 49 94 15 50 88 The first and fourth entries simulate a person tossing a fair coin 100 times when she has only a 10% chance of heads. The second and fifth entries simulate the same, when the chance of heads is 50%. The third and sixth simulate coin-tossing when there is a 90% chance of heads. If you would like to arrange the results more nicely—say in a matrix where each column gives the results for a different person—you can do so: resultsMat &lt;- matrix(results, ncol = 3, byrow = TRUE) resultsMat ## [,1] [,2] [,3] ## [1,] 20 49 94 ## [2,] 15 50 88 Of course judges don’t flip a coin 100 times, they decide one case at a time. Suppose you have five judges with probabilities as follows: probCorrect &lt;- c(0.95, 0.90, 0.90, 0.90, 0.80) If you would like to simulate the judges deciding, say, 6 cases, try this: results &lt;- rbinom(5*6, size = 1, prob= rep(probCorrect, 6)) resultsMat &lt;- matrix(results, nrow = 6, byrow = TRUE) resultsMat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1 1 0 1 ## [2,] 0 1 1 1 1 ## [3,] 1 1 1 1 1 ## [4,] 1 1 1 1 1 ## [5,] 1 1 1 1 1 ## [6,] 1 1 1 1 0 When it comes to applying the voting pattern to compute the decision in each case, consider matrix multiplication. For example, suppose that the pattern is: votes &lt;- c(2, 1, 1, 1, 0) Then make votes a one-column matrix and perform matrix multiplication: correctVotes &lt;- resultsMat %*% matrix(votes, nrow = 5) correctVotes ## [,1] ## [1,] 4 ## [2,] 3 ## [3,] 5 ## [4,] 5 ## [5,] 5 ## [6,] 5 Think about how to encapsulate all of this into a nice, general simulation function. "],
["graphics.html", "Chapter 8 Graphics", " Chapter 8 Graphics It’s hard to succinctly describe how ggplot2 works because it embodies a deep philosophy of visualisation. —Hadley Wickham (creator of ggplot2) Now that we know a bit about how data can be stored and manipulated in data frames, we can begin to analyze data, so in this Chapter we will take a closer look at the aspect of data analysis known as data visialization. We’ll become acquainted with the grammar of graphics, a general approach to visualization, and then learn how this approach is implemented in the ggplot2 with which we have worked previously. Finally, we’ll engage in a case study. "],
["the-grammar-of-graphics.html", "8.1 The Grammar of Graphics", " 8.1 The Grammar of Graphics A graph begins with data, and the data we work with will be tidy data that comes in a data frame. Leland Wilkinson’s Grammar of Graphics (see (Wilkinson 2005)) posits that most quantitative graphics constructed from a data frame can be understood in terms of a few basic elements. In our quite elementary introduction to the Grammar, the elements to which we will pay the most attention are as follows: Glyphs: the basic units of a graph. Glyphs represent cases in the data frame. Each glyph corresponds to one or more cases, but no two glyphs correspond to the same case. Aesthetics: perceptual properties of glyphs that are not the same for all glyphs but instead vary depending on the values of variables for the case (or cases) that each glyph represents. Frame: special aesthetics that relate the position of each glyphs in the graph to values of variables for the cases that the glyph represents. Scales: particular choices that determine the precise relationship between aesthetic properties and data values for glyphs. Guides: visual aids that help the human viewer to infer data values for cases from the aesthetic properties of the glyphs that represent them. We will clarify these abstract ideas with a series of examples. Many of our examples will be drawn from the m111survey data frame in the tigerstats package. library(bcscr) help(m111survey) You will recall that the data frame records the results of a survey of 71 students at Georgetown College in Kentucky. Each case (row in the frame) corresponds to an individual student. See Table 8.1. Table 8.1: The first few rows of the m111survey data frame. Five variables are shown. sex fastest GPA seat weight_feel male 119 3.56 1_front 1_underweight male 110 2.50 2_middle 2_about_right female 85 3.80 2_middle 2_about_right female 100 3.50 1_front 1_underweight male 95 3.20 3_back 1_underweight male 100 3.10 1_front 3_overweight 8.1.1 Example: a Scatterplot We begin with a simple scatter plot based on the data. A scatter plot is often a good way to investigate graphically the relationship between two numerical variables. Figure 8.1 shows a scatter plot of student GPA vs. the fastest speed at which the student has ever driven a car. Figure 8.1: Scatterplot of fastest driving speed and GPA. Points are colored by sex of the student. 8.1.1.1 The Glyphs In this scatter plot, the glyphs are points. Each case—each student in the survey—is represented by one and only one point on the plot. 8.1.1.2 The Aesthetics In ordinary discourse the term aesthetic refers to any perceptual property of an object. For a point, the list of its perceptual properties includes its location, its shape, its size, its color, and so on. In the Grammar of Graphics, however, only some of the properties—the one that vary from glyph to glyph depending on data—count as aesthetics in the graph. For the scatter plot, the property of size is not considered to be an aesthetic: we can see that this is so because all of the points are the same size, and so the size cannot vary with the values of some variable in the data frame. The same goes for the property of shape: all of the points in this scatter plot are circular. On the other hand, the property of color IS an aesthetic for the glyphs in the graph, since the males and the females in the study are represented by points of different colors. You could say that color is mapped to the variable sex in the data frame: the reddish color goes with the value “female”; the turquoise color goes with the value “male”. 8.1.1.3 The Frame In our scatter plot there are two other glyph properties that count as aesthetics: x-location: the position of the glyph relative to the horizontal axis of the graph; y-location: the position of the glyph relative to the vertical axis. We can see that these properties are aesthetics because: x-location is mapped to the variable fastest: the further to the right the glyph is, the greater is the value of fastest for the student represented by that glyph. y-location is mapped to the variable GPA: the higher up the glyph is, the greater is the value of GPA for the student represented by that glyph. Although x and y locations are just two more aesthetics, they are so crucial to the nature of a two-dimensional graph that they are classed separately in the Grammar of Graphics as the frame for the graph. In the graphs we consider in this Chapter, the frame will always consist of at least the x-location, and sometimes—as in the case of our scatter plot—the y-location as well. 8.1.1.4 Scales We can decide that color (for example) is to be mapped to sex, but that decision leaves open the question of how, precisely, to make the connection. The computer can make thousands of colors: which one will correspond to the value “male”, and which to “female”? To answer that question is to choose a scale. In this example our scale was: reddish = female turquoise = male But we might have adopted a different scale, such as: blue = female pink = male Every aesthetic mapping involves a choice of a scale. Consider x-location: apparently a point on the extreme left of the scatter plot represent a student who drove 50 miles per hour. A point at the extreme right corresponds to a speed of 200 miles per hour, and in general the relationship between x-location and fastest is linear: for example, a point halfway across the graph goes with a speed of 125 miles per hour, halfway between 50 mph and 200 mph. In the same way, the mapping of y-location to GPA involves a linear choice of scale. 8.1.1.5 Guides How were we able to see what the scales were for each of the three aesthetic mappings in the scatter plot? We were assisted by three set of guides, one for each mapping: the legend to the right of the plot guided us from color to value of sex; the labels and tick marks on the x-axis and the thin vertical white lines guided us from x-location to value of fastest; the labels and tick marks on the y-axis and the thin horizontal white lines guided us from y-location to value of GPA. Most of the time, every aesthetic mapping is accompanied by a guide that gives the human viewer at least a rough idea of the scale chosen for that mapping. 8.1.1.6 Summary In summary we say that for this scatter plot: The glyphs are points. This time each glyph represents one and only one case. The frame is: x = fastest y = GPA Other aesthetics are: color = sex There are scales for the three aesthetic mappings above. (But we usually don’t say much about the x and y-location scales if they are linear, and we don’t make a big deal of the color scale unless we went to some trouble to choose it ourselves.) The legend and the axis labels, tick marks and hash-lines are the guides. 8.1.2 Example: Two Bar Graphs Bar graphs are useful in the study of categorical variables, especially factor variables that have only a few possible values. Figure 8.2 shows the distribution of the factor variable seat in the mat111survey data frame. Figure 8.2: Bar graph of seating preference. The bars have a burlywood fill. In this graph: The glyphs are bars. This time each glyph an entire group of cases: there is a bar for the students who prefer the front, a bar for the students who prefer the middle, and a bar for the back-sitters. The frame is: x = seat. Note that it is possible for x-location to map to a categorical variable! In this graph the y-location does not count as part of the frame, since it is not really an aesthetic. Instead the height of a bar along the y-axis tells us how many students are represented by that bar. In the Grammar of Graphics we say that the y-axis represents a statistic—a value computed from the data. In the situation at hand, our statistic is a simple tally of the cases for each value of seat. There are no other aesthetics! The glyphs have various perceptual properties such as a shape rectangular and color, but these don’t vary with the cases: the shape is always rectangular and the color is always burlywood. There is a scale for the x-location, but there is nothing very interesting about it: the three values of seat are equally spaced along the axis. There is a guide for the x-location: labels on the x-axis tell us which bar goes with which value of the variable seat. Bar graphs can also be used to study the relationship between two categorical variables. Figure 8.3 shows the relationship between sex and seating preference in the m111survey data. Figure 8.3: Seating preference, by sex. Again the glyphs are bars and each bar represents many cases, but now there is a bar for each combination of the values of sex and seat. The frame is again specified only by the x-location, but this time it is mapped to sex. There is another aesthetic as well: the color (more technically, the fill) of the bars is mapped to the variable seat, allowing us to see the relationship between the two categorical variables sex and seat. Scales and guides work much the same way as in the previous example. 8.1.3 Examples: Histograms, Density Plots and Box Plots In this section we’ll examine some glyphs that are useful in the visualization of numerical variables. 8.1.3.1 Histograms How are the fastest speeds driven distributed, for students in the m111survey data? In order to investigate such a question graphically, we might make a histogram like the one in Figure 8.4. Figure 8.4: Histogram of the fastest speed ever driven. In this graph: The glyphs are rectangles. Each rectangle represents cases where the value of fastest lies within a particular range covered by the bottom left and right corners of the rectangle. The frame is: x = fastest. As with our bar graphs, the y-location does not count as part of the frame, but instead represents a statistic, permitting the height of a rectangle to indicate the number of cases that it represents. Again there are no other aesthetics. The burlywood fill of the rectangles is constant. The scale for x-location, maps location to fastest in the familiar linear fashion, and the x-axis has the usual guides found for numerical variables. Figure 8.5 is a variant, containing a second type of glyph: each student is now represented along the X-axis by a rug-tick located approximately at his or her fastest speed. (The ticks are actually “jittered” randomly so as to avoid over-plotting when two or more students report the same speed.) The addition of a second set of glyphs is called layerng, and is a common device to enhance the communicative power of a graph. Figure 8.5: Histogram of the fastest speed ever driven. 8.1.3.2 Density Plots One may also study the distribution of numerical variable with a density plot, as in Figure 8.6. In this figure there is only one glyph, the curve itself, and it represents all of the cases. However, its height represents crowding (density) of values of fastest for the cases: when the curve is high, many values are crowded closely together on the x-axis, and for speeds where the curve is low the viewer knows that few (if any) students drive around that speed. The y-axis is again used along with a statistic: for density plots the vertical scale is chosen in such a way that the total area under the density curve is 1, so that the area under the curve between two given speeds is approximately equal to the proportion of students who had speeds within that range. For density plots a rug, provided again by slightly jittered ticks, is a useful additional layer to indicate crowding of values. Figure 8.6: Density plot of the fastest speed ever driven. Since they don’t take up much territory on a graph, density curves are especially useful when we want to study the relationship between a numerical and a categorical variable. For example, Figure 8.7 shows density plots of the fastest speeds for each of the three possible seating preferences. The glyphs are again density curves, but since the color aesthetic has been mapped to seat, we get a separate and differently-colored glyphs, one for each seating-preference.. Figure 8.7: Density plot of the fastest speed ever driven. Another approach to the same graphing problem is to use a type of glyph known as a violin. Look at Figure 8.8. Figure 8.8: Violin plot of the fastest speed ever driven. A violin glyph is simply two mirror-images of the same density plot, pasted together along their bases. Thus the violin is thick where many values are clustered together and thin where data values are rare. In this plot, the frame is constituted by mapping x-location to seat and y-location to the variable fastest. For additional communicative power we have layered another set of glyphs–jittered points, one for each case–onto the plot. Suppose that one wished to incorporate a third variable, such as sex, into the graph? One possible way to to this is to divide the graphs into separate plots based on the values of one of the categorical variables in question. The separate plots are known as facets, and are illustrated in Figure 8.9, where facet-ing has been done on the basis of the variable seat. Figure 8.9: Violin plots of the fastest speed ever driven, by sex and seating preference. 8.1.3.3 Box Plots The five number summary is a convenient way to summarize the distribution of a numerical variable. The five numbers involved are: the minimum value the first quartile \\(Q1\\), the \\(25^{\\text{th}}\\) percentile of the values the median, which is the \\(50^{\\text{th}}\\) percentile the third quartile \\(Q3\\), the \\(75^{\\text{th}}\\) percentile the maximum value Also of interest is the interquartile range \\(IQR\\), defined as: \\[IQR = Q3 - Q1.\\] The interquartile range covers measures the spread in the middle 50% of the values. In R the five number summary can be got quickly with the fivenum() function: fnFastest &lt;- fivenum(m111survey$fastest) names(fnFastest) &lt;- c(&quot;min&quot;, &quot;Q1&quot;, &quot;median&quot;, &quot;Q3&quot;, &quot;max&quot;) fnFastest ## min Q1 median Q3 max ## 60.0 90.5 102.0 119.5 190.0 A box-plot glyph is the graphical counterpart of the five number summary. Figure 8.10 shows how it works for the variable fastest in the m111survey data frame. The box ranges from \\(Q1\\) to \\(Q3\\), covering the middle half of the speeds. The lower hinge extends from \\(Q1\\) down to the minimum speed. The upper hinge would have extended from \\(Q3\\) to the maximum value, but the maximum value was flagged as an outlier. When ggplot2 makes a box-plot, any point that is greater than \\(Q3 + 1.5 \\times IQR\\) or less than \\(Q1 - 1.5 \\times IQR\\) is flagged for individual plotting, and the corresponding hinge will be \\(1.5 \\times IQR\\) units long. Figure 8.10: Illustration of a simple box plot. A single box glyph on its own is not very interesting. Where box plots shine is in the study of the relationship between a numerical variable and a categorical with a large number of levels, as in Figure 8.11. Here the glyphs are boxes, with each box being constructed from the bills that were issued in a particular month. Figure 8.11: Utility bills through the year. 8.1.4 Example: Choropleth Maps The term “choropleth” derives from Greek and means “many regions.” A choropleth graph is a graph in which the frame is provided by some sort of map with regions that might be countries, cities or counties in the U.S. etc. In the choropleth map shown in Figure 8.12, is based on a data frame in which ease case is a state in the U.S (along with the District of Columbia). One of the variables is population, the population of the state. The glyphs are the territories of each of the U.S. states. The frame is determined by mapping x and y-location to latitude and longitude. The aesthetic property color is mapped to the population, and a guide is provided to the right of the graph. Figure 8.12: Choropleth map of state populations in the U.S. 8.1.5 Practice Exercises In each of the exercises below, consult the Help for the relevant data frame. (You’ll need to identify variables by their names in the data frame when you discuss aesthetic mappings.) The following graph is based on the data frame mosaicData::SwimRecords: What variables are used to make the frame? What are the two types of glyphs? What other aesthetic(s) are there (besides the x and y-locations in the frame)? To what variable(s) are they mapped? What guides do you see? The following graph is based on the data frame mosaicData::KidsFeet: What variable(s) are used to make the frame? What are the two types of glyphs? What other aesthetic(s) are there (besides the frame)? To what variable(s) are they mapped? What guides do you see? The following graph is based on the data frame mosaicData::Galton: What variable(s) are used to make the frame? What are the two types of glyphs? What other aesthetic(s) are there (besides the frame)? To what variable(s) are they mapped? What guides do you see? 8.1.6 Solutions to Practice Exercises Answers: Frame: x -&gt; year, y -&gt; time; Glyphs: points and line-segments between pairs of points; Other aesthetics: point-color and line-color are both mapped to sex; Guides: legend for sex, axis labels and ticks for year and time. Answers: Frame: x -&gt; biggerfoot; Glyphs: bars; Other aesthetics: bar fill -&gt; sex; Guides: legend for sex, axis labels and ticks for biggerfoot. Answers: Frame: x -&gt; father; Glyphs: density curve, jittered rug-ticks; Other aesthetics: none; Guides: axis labels and ticks for father. References "],
["implementation-in-ggplot2.html", "8.2 Implementation in ggplot2", " 8.2 Implementation in ggplot2 In its syntax, the ggplot2 package attempts to follow the Grammar of Graphics fairly closely. Let’s see how this works by building up, in step-by-step fashion, to our initial graph example—the scatter plot in Figure 8.1. 8.2.1 Basic Setup: the Data Frame Construction of a graph in ggplot2 begins with the ggplot() function. The first parameter of the function is data, the value of which will be the data frame on which we plan to build the graph. It is possible call ggplot() with just the data, and indeed it is instructive to do so. The result is seen in Figure 8.13: it is simply a blank window. ggplot(data = m111survey) Figure 8.13: A completely blank plot! 8.2.2 More Setup: Establishing the Frame ggplot() has a second parameter, the parameter mapping. Usually it is assigned the result of a call to the ggplot function aes(), which is used to establish aesthetic mappings. The common procedure is to use this first call to aes() to establish the frame: later calls will map other aesthetics properties to other variables, as desired. If we want to work toward Figure 8.1, we will have to map x-location to fastest and y-location to GPA. This is accomplished by the following code: ggplot(data = m111survey, mapping = aes(x = fastest, y = GPA)) Figure 8.14: Just the frame: no glyphs yet! The result appears as Figure 8.14. A frame has been established, along with guides to ggplot2’s default choice of linear scales for the mappings to fastest and to GPA. It is worth noting that most programmers do not bother to name the data and mapping parameters. Figure 8.14 could just as well have been produced as follows: ggplot(m111survey, aes(x = fastest, y = GPA)) In the future we will also drop these parameter names. 8.2.3 Labels At any point we can add labels to our plot. If you are simply exploring data you don’t need labels, but if you are writing up the final version of a report you will want to give careful consideration to labeling axes and to providing a good title (or—if you are able to to do so—a good caption). The following code adds labels for the x and y axes, a title—and even a subtitle, although subtitles are somewhat rare in practice. ggplot(m111survey, aes(x = fastest, y = GPA)) + labs(x = &quot;fastest speed ever driven (mph)&quot;, y = &quot;grade point average&quot;, title = &quot;Dunno what to say, yet!&quot;, subtitle = paste0(&#39;A title should briefly indicate the main&#39;, &#39; lesson the plot has for us. Instead of:&#39;, &#39; &quot;Scatterplot of\\nGPA vs. fastest speed&quot;,&#39;, &#39; say something like: &quot;Speed and GPA are&#39;, &#39; not strongly related.&quot;&#39;)) Figure 8.15: You can always add some labels! 8.2.4 Adding a Type of Glyph It is high time now to make some data appear on our plot, so let’s add some glyphs. In ggplot2 syntax glyphs are added with functions whose names are of the form: geom_gylphType() Thus we have such things as: geom_point() for points; geom_line() for line segments between points; geom_bar() for the bars of a bar graph; geom_histogram() for the rectangles that make up a histogram; geom_density() for the curve of a density plot; geom_violin() for the violins of a violin plot; geom_jitter() for jittered points representing individual cases; geom_rug() for rug-ticks representing individual cases; and a number of other geom’s! 8.2.4.1 Our First Geoms Let’s add some points to the plot with the following code. The result appears as Figure 8.16. We are now quite close to the target plot. ggplot(m111survey, aes(x = fastest, y = GPA)) + geom_point() + labs(x = &quot;fastest speed ever driven (mph)&quot;, y = &quot;grade point average&quot;, title = &quot;Speed and GPA are not strongly related.&quot;) Figure 8.16: Finally: the data appears! 8.2.4.2 Further Aesthetic Mappings The final step in our first example is to map the color property of points to the variable sex. We do so by a call to aes(). Conventionally a mapping for a glyph is accomplished inside the geom-function that creates the glyph, as in the code below that creates figure 8.17, our target plot: ggplot(m111survey, aes(x = fastest, y = GPA)) + geom_point(aes(color = sex)) + labs(x = &quot;fastest speed ever driven (mph)&quot;, y = &quot;grade point average&quot;, title = &quot;Speed and GPA are not strongly related.&quot;, subtitle = &quot;(But guys tend to drive faster, and to have lower GPAs.)&quot;) Figure 8.17: This is the target plot! Points have other perceptual properties in besides their color. Shape is such a property. (From the point of view of the Grammar of Graphics, a point in itself is only an abstract location in space. Only when it assumes all of its perceptual properties does it actually “appear”, and when it does appear its shape may be other than circular, just as its color may be other than, for instance, black.) Thus alternative way to incorporate sex into the graph would have been to map shape to sex,as in the following code that results in Figure 8.18: ggplot(m111survey, aes(x = fastest, y = GPA)) + geom_point(aes(shape = sex)) + labs(x = &quot;fastest speed ever driven (mph)&quot;, y = &quot;grade point average&quot;, title = &quot;Speed and GPA are not strongly related.&quot;, subtitle = &quot;(But guys tend to drive faster, and to have lower GPAs.)&quot;) Figure 8.18: Mapping shape to the variable sex. Passing now from our scatter plot example, we consider how to achieve another of the plots studied in the previous section, namely Figure 8.3. Following the same logic of calls to ggplot() and a geom-function, we see that the bar graph on sex and seating preference can be obtained by mapping the fill property of bars to seat as seen in the following code (results shown again as Figure `8.19) ggplot(m111survey, aes(x = sex)) + geom_bar(aes(fill = seat)) + labs(x = &quot;Sex&quot;, title = &quot;Males are more likely to prefer the Back!&quot;) Figure 8.19: Seating preference, by sex. Some people don’t like the glyphs “stacked” in bar graphs. In order to mollify them we can set position to “dodge”, as in the code below. The results appear in Figure 8.20. ggplot(m111survey, aes(x = sex)) + geom_bar(aes(fill = seat), position =&quot;dodge&quot;) Figure 8.20: Seating preference, by sex—no stacking of bars.. Note that position is not an aesthetic property: all of the bar dodge each other. Dodginess is not something that varies from glyph to glyph according to values in the data. 8.2.4.3 Aesthetic Mappings vs. Fixed Properties It is wise to dwell a bit on the distinction between aesthetic mappings on the one and hand and fixed properties of glyphs on the other hand. The key is this: An aesthetic mapping are always accomplished as an argument in a call to aes(). In this argument, the aesthetic property is the parameter name, and a variable is assigned to it, thus: geom_bar(aes(fill = seat)) geom_point(aes(color = sex)) A fixed property is determined by an argument to a geom-function call. The property to be fixed is the name of the parameter, and its constant value is the value supplied, thus: Code Effect geom_point(color = &quot;blue&quot;) all the points are blue geom_point(shape = 22) all points are solid squares geom_point(size = 3) all points are bigger than default size(1) geom_bar(fill = &quot;burlywood&quot;) all bars have the burlywood fill-color As an example, let’s code up the density plot of fastest speeds that occurred in Figure 8.4. The code is shown below and appears as 8.21 ggplot(m111survey, aes(x = fastest)) + geom_histogram(fill = &quot;burlywood&quot;) + labs(x = &quot;Fastest speed ever driven (mph)&quot;, title = &quot;For most students the fastest speed is around 100 mph&quot;) Figure 8.21: Histogram of the fastest speed ever driven. The fill-property of the curve is fixed to the ever-popular ‘burlywood’ color. 8.2.4.4 Adjusting Scales When we spoke of aesthetic mapping, we stressed that any mapping implies a specific choice of scale, i.e, choices about which values of the property go with which values of the variable to which the property is being mapped. ggplot2 tries to provide a sensible default scale for any mapping, but if we don’t like its choice then we can change it ourselves through a host of functions with names like these: scale_color_manual() scale_shape_manual() scale_fill_manual() scale_size_manual() scale_x_continuous() (for setting the scale in the mapping of x-location to a numerical variable) scale_x_discrete() (for setting the scale in the mapping of y-location to a categorical variable) and many others! Here is one simple example of setting our own scales. The code below produces Figure 8.22, where we have set that “female” should go with pink and “male” with red. ggplot(m111survey, aes(x = fastest, y = GPA)) + geom_point(aes(color = sex)) + scale_color_manual(values = c(&quot;pink&quot;, &quot;red&quot;)) + labs(x = &quot;fastest speed ever driven (mph)&quot;, y = &quot;grade point average&quot;) Figure 8.22: Color scale adjusted manually. 8.2.5 Layering: Adding Another Glyph Type If you want to add another layer of glyphs, simply add on another call to a geom-function. In order to produce Figure 8.23, for example, we use the code below: ggplot(m111survey, aes(x = seat, y = fastest)) + geom_violin(fill = &quot;burlywood&quot;) + geom_jitter(width = 0.2) + labs(x = &quot;Seating preference&quot;, y = &quot;Fastest speed ever driven (mph)&quot;, title = &quot;There aren&#39;t so many back-sitters.&quot;) Figure 8.23: Violin plot of the fastest speed ever driven. Note that the width parameter in the call to geom_jitter() determines how much the points are allowed to jitter horizontally. 8.2.5.1 Jitter-It-Yourself (JIY) “Rug” glyphs are excellent, in especially in conjunction with density curves, but they have a downside. Consider, for example Figure 8.24 produced by the code below. When you examine the plot you will see that there aren’t as many rug-ticks as there are students in the m111survey data. Many students reported driving at the same speed, so their rug-ticks plotted over each other. ggplot(m111survey, aes(x = fastest)) + geom_density(fill = &quot;burlywood&quot;) + geom_rug() + labs(x = &quot;Fastest speed ever driven (mph)&quot;, title = &quot;For most students the fastest speed is around 100 mph&quot;) Figure 8.24: Density plot of the fastest speed ever driven. Some rug glyphs overplot each other. It would be nice to solve the problem by jittering the rug-ticks, but unfortunately rug-ticks added to density plots don’t jitter nicely on their own. One reasonable workaround is to create one’s own randomly-jittered speeds and map the x-location of the rug-ticks to the new variable that holds the jittered values. The code below shows implements this idea, and results in Figure 8.25. n &lt;- nrow(m111survey) m111survey$jitteredSpeeds &lt;- m111survey$fastest + runif(n, -1, 1) ggplot(m111survey, aes(x = fastest)) + geom_density(fill = &quot;burlywood&quot;) + geom_rug(aes(x = jitteredSpeeds)) + labs(x = &quot;Fastest speed ever driven (mph)&quot;, title = &quot;For most students the fastest speed is around 100 mph&quot;) Figure 8.25: Density plot of the fastest speed ever driven. Rug glyphs are jittered. 8.2.6 Facets As you will recall, a graph has facets when it is sub-divided into plots with one plot for each of the values of a categorical variable. ggplot2 has two functions to manage facet-ing: facet_grid() facet_wrap() We’ll examine both of these functions in the context of some data frames from the mosaicData package, so you want to make sure to attach it to your search path: library(mosaicData) 8.2.6.1 facet_grid() The data frame mosaicData::RailTrail has information on usage of a converted railroad trail every day from April 5 to November 15, 2005. Study the Help file: help(RailTrail) Every row in the data frame represents a particular day between April 5 and November 15. Our goal is to study how the season (Spring, summer or Fall) and the time of week (weekday Mon-Fri vs. weekend Sat-Sun) relate to volume the number of people who use the trail on a given day. Inforomation about the season in which the day occurs is spread over the three 0-1 numerical variables spring, summer and fall. We propose to construct a single factor variable season variable from these three variables, as follows: n &lt;- nrow(RailTrail) season &lt;- character(n) for ( i in 1:n ) { if ( RailTrail$spring[i] ) { season[i] &lt;- &quot;spring&quot; } else if ( RailTrail$summer[i] ) { season[i] &lt;- &quot;summer&quot; } else if ( RailTrail$fall[i] ) { season[i] &lt;- &quot;fall&quot; } } RailTrail$season &lt;- factor(season, levels = c(&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;)) We’ll also make a variant of the “0”-“1” character-based variable weekday that has more informative values: RailTrail$wkday &lt;- ifelse(RailTrail$weekday == &quot;1&quot;, &quot;Mon-Fri&quot;, &quot;Sat-Sun&quot;) We are now ready make our graph. One possibility is to make a separate density plot of volume for each of the six possible combinations of values of the season and wkday variables. With facet_grid() we can arrange the plots in a grid so that the value of season is constant along rows and the value of wkday is constant along columns. This is accomplished by the following code, and the result appears as Figure 8.26. ggplot(RailTrail, aes(x = volume)) + geom_density(fill = &quot;burlywood&quot;) + facet_grid(season ~ wkday) Figure 8.26: Volume of daily trail usage, by seaon and time of week. Of course our aim is to see how volume varies with season and time of week, but the horizontal orientation of the volume variable in the above graph makes comparison difficult for most human viewers. Perhaps facet-ing in two dimensions was a bit too much, in this situation. In the code below, we produce a one-row, three-column layout in which each facet corresponds to one of the three seasons.25 Within each facet, the days are broken down by time of week and volumes are compared with boxplots. The result is seen in Figure 8.27. In the effort to incorporate the factor variables season and wkday into the graph, this second approach appears to strike a good balance between facet-ing and aesthetic mapping. ggplot(RailTrail, aes(x = wkday, y = volume)) + geom_boxplot(aes(fill = wkday)) + facet_grid( . ~ season) + labs(x = &quot;Time of Week&quot;, fill = &quot;Time of Week&quot;) + theme(legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot;) Figure 8.27: Striking a good balance between facet-ing and aesthetic mapping. 8.2.6.2 facet_wrap() Frequently it happens that one desires to facet by a single categorical variable, and the number of levels of a factor variable is too large for the entire graph to be displayed well along a single row or a single column. In that event, use facet_wrap(). Consider, for example, the data frame mosaicData::CPS85, and suppose that we want to compare the ages of workers in the eight different sectors of employment. Eight is a rather large number of plots, so we facet in “wrap-style” by means of the code below. The resulting plot appears as Figure 8.28. ggplot(CPS85, aes(x = age)) + geom_density(fill = &quot;burlywood&quot;) + facet_wrap(~ sector, nrow = 3) Figure 8.28: Age by sector. Once again, though, it may be wise to consider an approach that involves aesthetic mapping. When the number of levels is large, violin plots or boxplots may better approaches for representing a numerical variable such as age, as in the code below. The resulting graph is shown in Figure 8.29. ggplot(CPS85, aes(x = sector, y = age)) + geom_boxplot(fill = &quot;burlywood&quot;) Figure 8.29: Aesthetic mapping is probably superior to facetting in this case. In the exercises of this Chapter we will meet a case in which “wrap-style” facet-ing is quite useful. 8.2.7 Practice Exercises With mosaicData::SwimRecords, make the following graph: With mosaicData::KidsFeet, make the following graph: With mosaicData::TenMileRace, make the following graph: Hint: Make the call geom_point(alpha = 0.2). The alpha parameter has a default-value of 1. The lower you set it, the more “transparent” the points are. Low values for alpha are helpful to deal with the effects of “over-plotting” when many points are crowded together. With mosaicData::Gestation make the following graph. The fill for the boxes is set to &quot;burlywood&quot;. The x-location is mapped to factor(smoke), rather than to smoke. With mosaicData::Galton, make the following graph: Hint: The fill of the density plot is set to &quot;burlywood&quot;. The rug is made of randomly jittered father-heights. 8.2.8 Solutions to Practice Exercises The call was: ggplot(mosaicData::SwimRecords, aes(x = year, y = time)) + geom_point(aes(color = sex)) + geom_line(aes(color = sex)) + labs(x = &quot;year record was set&quot;, y = &quot;time (seconds)&quot;, title = &quot;100m record times have decreased, for both sexes.&quot;) The call was: ggplot(mosaicData::KidsFeet, aes(x = biggerfoot)) + geom_bar(aes(fill = domhand), position = &quot;dodge&quot;) + labs(x = &quot;the bigger foot&quot;, title = &quot;Foot-size and Handedness for 39 Children&quot;, subtitle = paste0(&quot;When your right foot is bigger, &quot;, &quot;are you more likely to be right-handed?&quot;)) The call was: ggplot(mosaicData::TenMileRace, aes(x = age, y = time)) + geom_point(alpha = 0.2) + facet_wrap(~ sex) + labs(x = &quot;age in years&quot;, y = &quot;net time to finish (sec)&quot;, title = &quot;Ten-Mile Race Times&quot;) The call was: ggplot(mosaicData::Gestation, aes(x = factor(smoke), y = wt)) + geom_boxplot(fill = &quot;burlywood&quot;) + labs(x = &quot;smoking status of mother&quot;, y = &quot;birth weight (ounces)&quot;, title = &quot;Birth Weights&quot;, subtitle = &quot;Children of smoking mothers have lower birth-weights.&quot;) First, make the jittered points. It’s a good idea to load the data set directly, if you haven’t already attached mosaicData: data(&quot;Galton&quot;, package = &quot;mosaicData&quot;) Now make the points: jitteredFather &lt;- Galton$father + runif(nrow(Galton), -0.5, 0.5) Galton$jitteredFather &lt;- jitteredFather Finally, the graph: ggplot(mosaicData::Galton, aes(x = father)) + geom_density(fill = &quot;burlywood&quot;) + geom_rug(x = jitteredFather) + labs(x = &quot;height of the father (inches)&quot;) Note that the formula season ~ . in the call to facet_grid() would have produced a three-row, one-column layout.↩ "],
["a-case-study-us-births.html", "8.3 A Case Study: US Births", " 8.3 A Case Study: US Births In Section 1.2.5, we made a plot of the number of births in the United States for each day of that year (see Figure 8.30). We noticed that there appear to be two clouds of points. What accounts for this phenomenon? By now we have the R-programming chops to take on this question. Figure 8.30: Some of the days have significantly fewer births. What’s going on? To begin with, look at all of the variables available in the data frame Births78: str(Births78) ## &#39;data.frame&#39;: 365 obs. of 8 variables: ## $ date : Date, format: &quot;1978-01-01&quot; &quot;1978-01-02&quot; &quot;1978-01-03&quot; ... ## $ births : int 7701 7527 8825 8859 9043 9208 8084 7611 9172 9089 ... ## $ wday : Ord.factor w/ 7 levels &quot;Sun&quot;&lt;&quot;Mon&quot;&lt;&quot;Tue&quot;&lt;..: 1 2 3 4 5 6 7 1 2 3 ... ## $ year : num 1978 1978 1978 1978 1978 ... ## $ month : num 1 1 1 1 1 1 1 1 1 1 ... ## $ day_of_year : int 1 2 3 4 5 6 7 8 9 10 ... ## $ day_of_month: int 1 2 3 4 5 6 7 8 9 10 ... ## $ day_of_week : num 1 2 3 4 5 6 7 1 2 3 ... We see that the variable wday gives the name of the day of the week, for each of the days in the year. On a hunch, we make violin plots of the births for each of the days of the week. The code appears below, and the resulting plot is shown in Figure 8.31 ggplot(Births78, aes(x = wday, y = births)) + geom_violin(fill = &quot;burlywood&quot;) + geom_jitter() Figure 8.31: Violin plot of births, by day of the week. Aha! There are considerably fewer births on the weekend-days—Saturday and Sunday. Perhaps the entire lower cloud of points is composed of weekends. Let’s check this by re-coding the days according to whether or not they are during the week or at the weekend: weekend &lt;- with(Births78, ifelse(wday %in% c(&quot;Sat&quot;,&quot;Sun&quot;), &quot;weekend&quot;, &quot;weekday&quot;)) Births78$weekend &lt;- weekend Note that we have added the new variable to the data frame, so that it will be easy in ggplot2 to use that variable for grouping, as in the code below. The results appear in Figure 8.32. ggplot(Births78, aes(x = date, y = births)) + geom_point(aes(color = weekend)) + labs(x = &quot;Day of the Year&quot;, y = &quot;Number of U.S. Births&quot;, title = &quot;Daily U.S. Birth-Numbers in 1978&quot;) Figure 8.32: The days with fewer births are almost always weekend-days. Well, a few of the points in the lower cloud are weekdays. Is there anything special about them? To find out, we subset the data frame to examine only those points: df &lt;- subset(Births78, weekend != &quot;weekend&quot; &amp; births &lt;= 8500) df ## date births wday year month day_of_year day_of_month day_of_week weekend ## 2 1978-01-02 7527 Mon 1978 1 2 2 2 weekday ## 149 1978-05-29 7780 Mon 1978 5 149 29 2 weekday ## 185 1978-07-04 8433 Tue 1978 7 185 4 3 weekday ## 247 1978-09-04 8481 Mon 1978 9 247 4 2 weekday ## 327 1978-11-23 7915 Thu 1978 11 327 23 5 weekday ## 359 1978-12-25 7846 Mon 1978 12 359 25 2 weekday If you consult a calendar for the year 1978, you will find that every one of the above days was a major holiday. Apparently doctors prefer not to deliver babies on weekend and holidays. Scheduled births—induced births or births by non-emergency Cesarean section—are not usually set for weekends or holidays. Perhaps this accounts for the two clouds we saw in the original scatter plot. "],
["factors-in-plotting.html", "8.4 Factor Variables in Plotting", " 8.4 Factor Variables in Plotting It is worthwhile to reconsider factor variables (see 7.4.3) and to consider their role in the appearance of plots. We’ll do this by way of an example. Consider the data frame firesetting in the tigerData package: data(&quot;firesetting&quot;, package = &quot;tigerData&quot;) ?tigerData::firesetting As we see from the Help file, fire-setting offers information about a large sample of high-school students. Some of them are known to be arsonists, while of course most are not. The purpose for gathering the data was to determine what characteristics of a child might be risk factors in whether he/she would develop into a fire-setter. Among the variables of interest are: race, the ethnicity of the student, a factor with three levels: “white”, “black”, and “other”; school.attitude, a scaled score on a personality inventory in which high scores indicate a poor attitude toward school; fires, a factor variable with levels “0” (does not set fires) and “1” (sets fires). We might study the relationship between these variables with some box-plots via the code below. The results appear as Figure 8.33. ggplot(firesetting, aes(x = race, y = school.attitude)) + geom_boxplot(fill = &quot;burlywood&quot;, outlier.alpha = 0) + geom_jitter(width = 0.20, size = 0.1) + facet_wrap(~ fires, nrow = 2) + labs(x = &quot;Ethnicity&quot;, y = &quot;School-Attitude Score&quot;) Figure 8.33: Boxplots with jittered individual values. School attitudes are generally worse among fire-setters. We could improve the appearance of the plot with respect to two of the variables involved: fires: We should display values that are more meaningful to a human viewer than 0 and 1. race: Let’s change the names of the values somewhat, keeping their current order along the x-axis. For fires, we simply need to map the current values onto others that we prefer. Currently the levels are: levels(firesetting$fires) ## [1] &quot;0&quot; &quot;1&quot; We can re-map as follows: betterFires &lt;- plyr::mapvalues(firesetting$fires, from = c(&quot;0&quot;, &quot;1&quot;), to = c(&quot;no fires&quot;, &quot;sets fires&quot;)) firesetting$betterFires &lt;- betterFires For race, we’d like to substitute “White” for “white”; “AfrAm” for “black” “Other” for “other” “Unknown” instead of NA We’d like the order along the horizontal axis to remain as it is. We might begin by replacing the NA-values with “Unknown”, as follows: tempRace &lt;- firesetting$race tempRace[is.na(tempRace)] &lt;- &quot;Unknown&quot; We get an error! That’s because race is a factor with only three “possible values”, as given by its levels: levels(tempRace) ## [1] &quot;white&quot; &quot;black&quot; &quot;other&quot; “Unknown” is not considered a “possible value” for tempRace, any attempt to set that value in any elements of tempRace will be resisted. We can overcome this resistance by coercing tempRace into a mere character-vector: tempRace &lt;- as.character(tempRace) Now tempRace doesn’t come with a limit on its “possible values”. We try again: tempRace[is.na(tempRace)] &lt;- &quot;Unknown&quot; This apparently worked. Let’s check: unique(tempRace) ## [1] &quot;white&quot; &quot;other&quot; &quot;Unknown&quot; &quot;black&quot; So far, so good. Now let’s re-map the other three values: tempRace2 &lt;- plyr::mapvalues(tempRace, from = c(&quot;white&quot;, &quot;black&quot;, &quot;other&quot;), to = c(&quot;White&quot;, &quot;AfrAm&quot;, &quot;Other&quot;)) Let’s check that it worked: unique(tempRace2) ## [1] &quot;White&quot; &quot;Other&quot; &quot;Unknown&quot; &quot;AfrAm&quot; Great. Now let’s add tempRace2 as a new variable into firsetting. In that data frame, it will be called betterRace. Here’s the code to do this: firesetting$betterRace &lt;- tempRace2 Let’s try the graph again. We will need to modify the code a bit, so that we’re using the new and improved variable betterRace, as well as the new variable betterFires. Figure 8.34 is the result. ggplot(firesetting, aes(x = betterRace, y = school.attitude)) + geom_boxplot(fill = &quot;burlywood&quot;, outlier.alpha = 0) + geom_jitter(width = 0.20, size = 0.1) + facet_wrap(~ betterFires, nrow = 2) + labs(x = &quot;Ethnicity&quot;, y = &quot;School-Attitude Score&quot;) Figure 8.34: We have re-mapped the fires and race variables. This looks better, but now the order along the x-axis isn’t as we desired. Recall that race is now a character vector only. Since it doesn’t have levels that specify a particular order, ggplot2 uses alphabetical order as the default ordering along the x-axis. Accordingly we should convert betterRace to a factor variable, and be careful to set the levels in the order that we want: tempRace &lt;- firesetting$betterRace betterRace2 &lt;- factor(tempRace, levels = c(&quot;White&quot;, &quot;AfrAm&quot;, &quot;Other&quot;, &quot;Unknown&quot;)) firesetting$evenBetterRace &lt;- betterRace2 Now try again. Note that in the code below we switch to evenBetterRace. See Figure 8.35 for the result. ggplot(firesetting, aes(x = evenBetterRace, y = school.attitude)) + geom_boxplot(fill = &quot;burlywood&quot;, outlier.alpha = 0) + geom_jitter(width = 0.20, size = 0.1) + facet_wrap(~ betterFires, nrow = 2) + labs(x = &quot;Ethnicity&quot;, y = &quot;School-Attitude Score&quot;) Figure 8.35: Now the order of the race-values is correct! This works! 8.4.1 Practice Exercises With mosaicData::KidsFeet, make the following graph. (Hint: Use plyr::mapvalues().) With mosaicData::TenMileRace, make the following graph. (Hint: Use cut() to make age groups. The fill for the boxes is the ever-popular &quot;burlywood&quot;.) With mosaicData::Gestation, make the following graph. (Hint: Use !is.na() to select the rows of Gestation where smoke is not NA. Then use plyr::mapvalues() on smoke.) 8.4.2 Solutions to Practice Exercises Here’s the code: data(&quot;KidsFeet&quot;, package = &quot;mosaicData&quot;) tempBiggerfoot &lt;- KidsFeet$biggerfoot biggerfoot2 &lt;- plyr::mapvalues(tempBiggerfoot, c(&quot;L&quot;, &quot;R&quot;), to = c(&quot;left foot&quot;, &quot;right foot&quot;)) KidsFeet$betterBiggerfoot &lt;- biggerfoot2 tempDomhand &lt;- KidsFeet$domhand domhand2 &lt;- plyr::mapvalues(tempDomhand, from = c(&quot;L&quot;, &quot;R&quot;), to = c(&quot;left hand&quot;, &quot;right hand&quot;)) KidsFeet$betterDomhand &lt;- domhand2 ggplot(KidsFeet, aes(x = betterBiggerfoot)) + geom_bar(aes(fill = betterDomhand), position = &quot;dodge&quot;) + labs(x = &quot;the bigger foot&quot;, title = &quot;Foot-size and Handedness for 39 Children&quot;, subtitle = paste0(&quot;When your right foot is bigger, &quot;, &quot;are you more likely to be right-handed?&quot;)) Here’s the code: data(&quot;TenMileRace&quot;, package = &quot;mosaicData&quot;) tempSex &lt;- TenMileRace$sex sex2 &lt;- plyr::mapvalues(tempSex, from = c(&quot;F&quot;, &quot;M&quot;), to = c(&quot;female&quot;, &quot;male&quot;)) TenMileRace$betterSex &lt;- sex2 ageGroup &lt;- cut(TenMileRace$age, breaks = c(-Inf, 20, 30, 40, 50, 60, 70, Inf), labels = c(&quot;&lt;20&quot;, &quot;20s&quot;, &quot;30s&quot;, &quot;40s&quot;, &quot;50s&quot;, &quot;60s&quot;, &quot;70+&quot;)) TenMileRace$ageGroup &lt;- ageGroup ggplot(TenMileRace, aes(x = ageGroup, y = time)) + geom_boxplot(fill = &quot;burlywood&quot;) + facet_grid(betterSex ~ .) + labs(x = &quot;Age Group&quot;, y = &quot;net time to finish (sec)&quot;, title = &quot;Ten-Mile Race Times&quot;) Here’s the code: data(&quot;Gestation&quot;, package = &quot;mosaicData&quot;) Gestation &lt;- subset(Gestation, !is.na(smoke)) tempSmoke &lt;- Gestation$smoke smoke2 &lt;- plyr::mapvalues(tempSmoke, from = 0:3, to = c(&quot;never&quot;, &quot;smokes now&quot;, &quot;until curr. preg.&quot;, &quot;once smoked&quot;)) Gestation$betterSmoke &lt;- smoke2 ggplot(Gestation, aes(x = factor(betterSmoke), y = wt)) + geom_boxplot(fill = &quot;burlywood&quot;) + labs(x = &quot;smoking status of mother&quot;, y = &quot;birth weight (ounces)&quot;, title = &quot;Birth Weights&quot;, subtitle = &quot;Children of smoking mothers have lower birth-weights.&quot;) "],
["learn-more.html", "8.5 Learn More", " 8.5 Learn More From time to time we will return to gplot2 and deepen our study of this remarkable graphing system. If you are impatient to learn more right way, you can explore the package’s documentation site. The site teaches the system by way of numerous examples that you can copy and modify. "],
["glossary-6.html", "Glossary", " Glossary Frame The aesthetics (usually x and y position) that help locate cases on a plot. Glyph The basic graphical unit that corresponds to a case in the data table. Aesthetic A perceptible property of a glyph that varies from case to case. Scale The relationship between the value of a variable and the graphical attribute to be displayed for that value. Guide An indication, for the human viewer, of the scale being used in an aesthetic mapping. "],
["graphics-exercises.html", "Exercises", " Exercises Using the bcscr::m111survey data frame, write the ggplot2 code necessary to produce the graph in the figure below. (The points are all blue.) Hint: For the points, map the aesthetic property shape ot the variable sex. On the other hand, color is a fixed property. Using the mosaicData::Utilities data frame, write the ggplot2 code necessary to produce the graph in the figure below. Hint: The month variable in Utilities is given numerically: 0 for January, 1 for February, and so on. You’ll need to use plyr::mapvalues() to map the numbers from 1 to 12 to the abbreviated month names. (See section 8.4 for a review of this.) The special R-vector month.abb will render the re-mapping task easy: month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; In fact, you can create your new variable with abbreviated monnths with this code: monthAbbr &lt;- with(Utilities, plyr::mapvalues(month, from = 1:12, to = month.abb)) You also need to make sure that the months come in the right order along the x-axis of the graph. To do this consider resetting the levels of your new monthAbbr variable. One way to accomplish this is to convert monthAbbr back to a factor with levels in the order you want, as done in Section 8.4, like this: monthAbbr &lt;- factor(monthAbbr, levels = month.abb) Then you can put your new variable into the data frame, naming it anything you like: Utilities$monthName &lt;- monthAbbr The next few exercises pertain to the data frame CPS85 from the package mosaicData. Learn about it with help(CPS85). We will use the ggplot2 graphing package to explore whether men were being paid more than women in 1985. Make a density plot of the wages of the people in the study. As with all plots you make, it should have well-labelled axes (with units if possible). For a density plot you should label the horizontal axis, but you can let ggplo2 provide the label for the “density” axis. As always, provide a descriptive title. Also provide a “rug” of individual values along the horizontal axis. Look at the plot you made in the previous exercise: you will notice that one person made a wage that was much higher than all the rest. In data analysis, when a value is much higher or lower than the rest of the values we call it an outlier. Write the code needed to find the age, sex and sector of employment of the person who made this extraoridinarily high wage. Report the age, sex and sector of this person. Create a new data frame called cpsSmall that is the same as CPS85 except that it excludes the row corresponding to the outlier-individual. In order to explore the relationship between wage and sex in the CPS study, make violin plots for the wages of men and women. (In this exercise and in subsequent exercises, use the cpsSmall data frame so as to exclude the outlier.) Based on the plot, who tends to earn higher wages: men or women? (*) Someone might argue that men don’t earn higher wages because of sex-discrimination in the workplace, but rather because of some other factor. For example, it could be that in 1985 women chose to work in low-wage sectors of the economy, whereas men tended to work in higher-wage sectors. Of course for this explanation to be viable, some sectors of the economy have to pay more on average than other sectors do. In order to verify whether this is the case, make a box plot of wage vs. sector of employment. Use the plot to name a couple of high-wage sectors and a couple of low-wage sectors. (*) From the previous exercise you now know that some sectors of the economy pay more than other sectors. Hence in order to investigate properly whether there was wage-discrimination in the workforce based on sex, we would have to compare the wages of men and women who work in the same sector. To this end it would be nice to have eight separate box plots, one for each sector. Each plot would compare the wages of men and women in that sector. Use facet_wrap() to construct a graph that displays all eight plots at once. Examine your graph. Are there any sectors in which it seems that women typically make more than men. If so, what sectors are they? On the other hand, are there any sectors where men typically make more than women? If so, what sectors are they? Based on your analysis, does it seem plausible that women made less than men simply because they chose lower-paying sectors of employment? "],
["lists.html", "Chapter 9 Lists", " Chapter 9 Lists In this Chapter we will study lists, another important data structure in R. "],
["introduction-to-lists.html", "9.1 Introduction to Lists", " 9.1 Introduction to Lists So far the vectors that we have met have all been atomic, meaning that they can hold only one type of value. Hence we deal with vectors of type integer, or of type double, or of type character, and so on. A list is a special kind of vector. Like any other vector it is one-dimensional, but unlike an atomic vector it can contain objects of any sort: atomic vectors, functions—even other lists! We say, therefore, that lists are heterogeneous vectors. The most direct way to create a list is with the function list() . Let’s make a couple of lists: lst1 &lt;- list(name = &quot;Dorothy&quot;, age = 12) df &lt;- data.frame(x = c(10, 20, 30), y = letters[1:3]) lst2 &lt;- list(vowels = c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;), myFrame = df) lst3 &lt;- list(nums = 10:20, bools = c(T, F, F), george = lst1) Note that the elements of our three lists are not objects of a single data type. Note also that lst3 actually contains lst1 as one of its elements. When you call list() to create a list, you have the option to assign a name to one or more of the elements. In the code above we chose, for both of our lists, to assign a name to each element. Let’s print out a list to the console. We’ll choose lst1, since it’s rather small: lst1 ## $name ## [1] &quot;Dorothy&quot; ## ## $age ## [1] 12 Note that the name of each elements appears before the element itself is printed out, and that the names are preceded by dollar signs. This is a hint that you can access a single member of the list in a way similar to the frame$variable format for data frames: lst1$age ## [1] 12 You can make an empty list, too: emptyList &lt;- list() This is useful when you want to build up a list gradually, but you do not yet know what will go into it. 9.1.1 Practice Exercises Make a list called ozStuff. The list should contain three elements: The sequence of even numbers from 4 to 100. Its name should be lion. The uppercase letters of the alphabet. Its name should be scarecrow. The data frame alcohol from the fuel package. Its name should be wizard. Suppose that ozStuff has been created in the previous problem. Describe in your own words what the following expression does: ozStuff &lt;- c(ozStuff, list(dorothy = &quot;Kansas&quot;)) 9.1.2 Solutions to the Practice Exercises Here’s one way to do it: ozStuff &lt;- list(lion = seq(4, 100, by = 2), scarecrow = LETTERS, wizard = bcscr::fuel) One way to describe it is as follows: the expression creates a new list consisting of all the elements of ozStuff together with a new element called dorothy (which is the string &quot;Kansas&quot;), and then binds the name “ozStuff” to that new four-element list. "],
["subsetting-and-accessing.html", "9.2 Subsetting and Accessing", " 9.2 Subsetting and Accessing You can subset lists in the same way that you subset a vector: simply use the [ sub-setting operator. Let’s pick out the first two elements of lst3: lst3[1:2] ## $nums ## [1] 10 11 12 13 14 15 16 17 18 19 20 ## ## $bools ## [1] TRUE FALSE FALSE We get a new list consisting of the desired two elements. Suppose we want to access just one element from lst3: the numbers, for instance. We could try this: justNumbers &lt;- lst3[1] justNumbers ## $nums ## [1] 10 11 12 13 14 15 16 17 18 19 20 Now suppose that we want to access the third number in the nums vector. You might think this would work fine: justNumbers[3] ## $&lt;NA&gt; ## NULL Wait a minute! The third number in nums is 12: so why are we getting NA? Look carefully again at the printout for justNumbers: justNumbers ## $nums ## [1] 10 11 12 13 14 15 16 17 18 19 20 The $nums give us the clue: justNumbers is not just the vector nums—in fact it’s not an atomic vector at all. It is a list whose only element is a vector with the name nums. Another way to see this is to check the length of justNumbers: length(justNumbers) ## [1] 1 The fact is that the sub-setting operator [, applied to lists, always returns a list. If you want access to an individual element of a list, then you need to use the double-bracket [[ operator: reallyJustNumbers &lt;- lst3[[1]] reallyJustNumbers ## [1] 10 11 12 13 14 15 16 17 18 19 20 Of course if an element of a list is named, then you may also access it with the dollar sign: lst3$nums ## [1] 10 11 12 13 14 15 16 17 18 19 20 From time to time it’s useful to “flatten out” a list into a vector of values of its elements. This is accomplished by the function unlist() : unlist(lst1) ## name age ## &quot;Dorothy&quot; &quot;12&quot; As the example above shows, you have to exercise caution with unlist(). Since unlist() returns an atomic vector, when it encounters values of different types then it has to coerce them to be of the same type. In the competition between double and character types, character wins, so you end up with a vector of strings. 9.2.1 Practice Exercises These exercises involve the following list: grabBag &lt;- list(letters = letters, as.character(1:10), df = bcscr::fuel) Observe that the second element of this list was NOT given a name. Describe in words what grabBag[2:3] is. Describe in words what grabBag[3] is. Describe in words what `grabBag[[3]] is. Find two ways to access the letter &quot;d&quot; in the first element of grabBag. Find a way to access the last five elements of the second element of grabBag. Find two ways to access the variable speed in the data frame in grabBag. 9.2.2 Solutions to the Practice Exercises grabBag[2:3] is a list containing two elements: the vector of whole numbers from 1 to 10 turned into strings, and the data frame fuel from the bcscr package. grabBag[3] is a list containing just one element: the data frame fuel from the bcscr package. grabBag[[3]] is the data frame fuel from the bcscr package. Here are two ways: grabBag$letters[4] grabBag[[1]][4] Try this: grabBag[[2]][6:10] Here are two ways: grabBag$df$speed grabBag[[3]]$speed "],
["lists-splitting.html", "9.3 Splitting", " 9.3 Splitting Sometimes it is useful to split a vector or data frame into pieces according to the value of a variable. For example, from m111survey we might like to have separate data frames for each of the three seating preferences. We can accomplish this with the split() function: bySeat &lt;- split(m111survey, f = m111survey$seat) If you run the command str(bySeat), you find that bySeat is a list consisting of three data frames: 1_front: the frame of all subjects who prefer the Front; 2_middle: the frame of all subjects who prefer the Middle; 3_back: the frame of all subjects who prefer the Back. Now you can carry on three separate analyses, working with one frame at a time. There is a pitfall which of you should be aware. If you try to access any one of the frames by its name, you will get an error: bySeat$1_front ## Error: unexpected numeric constant in &quot;bySeat$1&quot; The reason is that variable names cannot begin with a number! You have two options, here. You could access a single frame by using the name in quotes: bySeat[[&quot;1_front&quot;]] Your second option is to use the index of the element you want: bySeat[[1]] "],
["returning-multiple-values.html", "9.4 Returning Multiple Values", " 9.4 Returning Multiple Values Lists combine many different sorts of objects into one object. This makes them very useful in the context of certain functions. Consider, for example, the drunken-turtle simulation from Section 6.8: drunkenSim &lt;- function(steps = 1000, reps = 10000, close = 0.5, seed = NULL, table = FALSE) { if ( !is.null(seed) ) { set.seed(seed) } returns &lt;- numeric(reps) for (i in 1:reps) { angle &lt;- runif(steps, 0 , 2*pi) xSteps &lt;- cos(angle) ySteps &lt;- sin(angle) x &lt;- cumsum(xSteps) y &lt;- cumsum(ySteps) dist &lt;- sqrt(x^2 + y^2) closeReturn &lt;- (dist &lt; 0.5) returns[i] &lt;- sum(closeReturn) } if ( table ) { cat(&quot;Here is a table of the number of close returns:\\n\\n&quot;) tab &lt;- prop.table(table(returns)) print(tab) cat(&quot;\\n&quot;) } cat(&quot;The average number of close returns was: &quot;, mean(returns), &quot;.&quot;, sep = &quot;&quot;) } Suppose that we would like to store several of the results of the simulation: the vector of the number of close returns on each repetition; the table made from the close-returns vector; the mean number of returns. Unfortunately a function can only return one object. The solution to your problem is to make a list of the three objects we want, and then return the list. We can re-write the function so as to make all output to the console optional. The function will construct the list and return it invisibly. drunkenSimList &lt;- function(steps = 1000, reps = 10000, close = 0.5, seed = NULL, verbose = FALSE) { if ( !is.null(seed) ) { set.seed(seed) } # get the returns: returns &lt;- numeric(reps) for (i in 1:reps) { angle &lt;- runif(steps, 0 , 2*pi) xSteps &lt;- cos(angle) ySteps &lt;- sin(angle) x &lt;- cumsum(xSteps) y &lt;- cumsum(ySteps) dist &lt;- sqrt(x^2 + y^2) closeReturn &lt;- (dist &lt; 0.5) returns[i] &lt;- sum(closeReturn) } # compute the table and the mean: tableReturns &lt;- table(returns) meanReturns &lt;- mean(returns) # handle output to console if user wants it if ( verbose ) { cat(&quot;Here is a table of the number of close returns:\\n\\n&quot;) print(prop.table(tableReturns)) cat(&quot;\\n&quot;) cat(&quot;The average number of close returns was: &quot;, meanReturns, &quot;.&quot;, sep = &quot;&quot;) } # assemble the desired three items into a list # (for conveneince, name the items) results &lt;- list(tableReturns = tableReturns, meanReturns = meanReturns, returns = returns) # return the list invisible(results) } Now we can run the function simply to acquire the simulation results for later use: simResults &lt;- drunkenSimList(seed = 3939) We can use any of the results at any time and in any way we like: cat(&quot;On the first ten repetitions, the number of close returns were:\\n\\n\\t&quot;, simResults$returns[1:10]) ## On the first ten repetitions, the number of close returns were: ## ## 0 6 4 4 2 0 2 5 2 4 "],
["iterating-over-a-list.html", "9.5 Iterating Over a List", " 9.5 Iterating Over a List Lists are one-dimensional, so you can loop over them just as you would loop over a atomic vector. Sometimes this can be quite useful. Here is a toy example. We will write a function that, when given a list of vectors, will return a vector consisting of the means of each of the vectors in the list. means &lt;- function(vecs = list(), ...) { n &lt;- length(vecs) if ( n == 0 ) { return(cat(&quot;Need some vectors to work with!&quot;)) } results &lt;- numeric() for ( vec in vecs ) { print(vec) results &lt;- c(results, mean(vec, ...)) } results } vec1 &lt;- 1:5 vec2 &lt;- 1:10 vec3 &lt;- c(1:20, NA) means(vecs = list(vec1, vec2, vec3), na.rm = TRUE) ## [1] 1 2 3 4 5 ## [1] 1 2 3 4 5 6 7 8 9 10 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 NA ## [1] 3.0 5.5 10.5 Another possibility—and one that will work a bit more quickly—is to iterate over the indices of the list of vectors: means2 &lt;- function(vecs = list(), ...) { n &lt;- length(vecs) if ( n == 0 ) { return(cat(&quot;Need some vectors to work with!&quot;)) } results &lt;- numeric(n) for ( i in 1:n ) { results[i] &lt;- mean(vecs[[i]], ...) } results } means2(vecs = list(vec1, vec2, vec3), na.rm = TRUE) ## [1] 3.0 5.5 10.5 "],
["a-note-on-ellipses.html", "9.6 A Note on Ellipses", " 9.6 A Note on Ellipses The functions of the previous section contained a mysterious ... argument in their definitions. This is known in R as the ellipsis argument, and it signals the possibility that one or more additional arguments may be supplied when the function is actually called. The following function illustrates the operation of the ellipsis argument: ellipisDemo &lt;- function(...) { cat(&quot;I got the following arguments:\\n\\n&quot;) print(list(...)) } ellipisDemo(x = 3, y = &quot;cat&quot;, z = FALSE) ## I got the following arguments: ## ## $x ## [1] 3 ## ## $y ## [1] &quot;cat&quot; ## ## $z ## [1] FALSE At this point in our study of R, ... is useful in two ways. 9.6.1 Use #1: Passing Additional Arguments to Functions “Inside” Look again at the code for the function means2(): means2 &lt;- function(vecs = list(), ...) { n &lt;- length(vecs) if ( n == 0 ) { return(cat(&quot;Need some vectors to work with!&quot;)) } results &lt;- numeric(n) for ( i in 1:n ) { results[i] &lt;- mean(vecs[[i]], ...) } results } We plan to take the mean of some vectors and therefore the mean() function will be used in the body of means2(). However we would like the user to be able to decide how mean() deals with NA-values. When we include the ellipsis argument in the definition of means2() we have the option to pass its contents into mean(), and we exercise that option in the line: results[i] &lt;- mean(vecs[[i]], ...) Now we can see what happens in the call: means2(vecs = list(vec1, vec2, vec3), na.rm = TRUE) The ellipsis argument will consist of the argument na.rm = TRUE, hence the call to mean() inside the loop is equivalent to: results[i] &lt;- mean(vecs[[i]], na.rm = TRUE) Consider, on the other hand, the call: means2(vecs = list(vec1, vec2, vec3)) Now the ellipsis is empty. In this case the code in the loop will be equivalent to: means2(vecs = list(vec1, vec2, vec3)) ## [1] 3.0 5.5 NA As a result, mean() will use the default value of na.rm, which is FALSE. For any input-vector having NA-values, the mean will be computed as NA. 9.6.2 Use #2: Permitting Any Number of Arguments Another application of the ellipsis argument is in the writing of functions where the number of “primary” arguments is not determined in advance. We have seen a few R-functions that can deal with any number of arguments. cat() is an example: cat(&quot;argument one,&quot;, &quot;argument two,&quot;, &quot;and as many more as you like!&quot;) ## argument one, argument two, and as many more as you like! With the ellipsis argument we can do this sort of thing ourselves. For example, here is a function that takes any number of vectors as arguments and determines whether the vectors are all of the same length: sameLength &lt;- function(...) { vecs &lt;- list(...) numVecs &lt;- length(vecs) if ( numVecs &lt;= 1 ) { return(cat(&quot;Need two or more vectors.&quot;)) } allSame &lt;- TRUE len &lt;- length(vecs[[1]]) for ( i in 2:numVecs ) { if ( length(vecs[[i]]) != len ) { allSame &lt;- FALSE break } } allSame } We can give this function two or more vectors, as follows: vec1 &lt;- 1:3 vec2 &lt;- 1:4 vec3 &lt;- 1:3 sameLength(vec1, vec2, vec3) ## [1] FALSE "],
["investigate-your-object-str-and-lists.html", "9.7 Investigate Your Object: str() and Lists", " 9.7 Investigate Your Object: str() and Lists Let’s reconsider the Meetup Simulation from Section 6.4: meetupSim &lt;- function(reps = 10000, table = FALSE, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } anna &lt;- runif(reps, 0, 60) raj &lt;- runif(reps, 0, 60) connect &lt;- (abs(anna - raj) &lt; 10) if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) print(table(connect)) cat(&quot;\\n&quot;) } cat(&quot;The proportion of tims they met was &quot;, mean(connect), &quot;.\\n&quot;, sep = &quot;&quot;) } You will recall that when the user asks for a table of results, the function prints out a table that looks like this: ## Here is a table of the results: ## connect ## FALSE TRUE ## 69781 30219 There are a couple of small irritations, here: The name of the table (“connect”) appears in the output, even though it was a name that was given in the code internal to the function. As a name for the output-table, it’s not the most descriptive choice. Besides, we really don’t need a name here, because have just cat-ed out a sentence that introduces the table. The names for the columns (FALSE and TRUE) again pertain to features internal to the code of the function. The user should see more descriptive names. In order to investigate how we might deal with these issues, let’s create a small table here: logicalVector &lt;- c(rep(TRUE, 6), rep(FALSE, 4)) tab &lt;- table(logicalVector) tab ## logicalVector ## FALSE TRUE ## 4 6 One way to deal with the column-name issues might be to isolate each table value and then repackage the values. We can access the individual table-values with sub-setting. For example, the first value is: tab[1] ## FALSE ## 4 Hence we could grab the values, create a vector from them, and then provide names for the vector that we like. Thus: results &lt;- c(tab[1], tab[2]) names(results) &lt;- c(&quot;did not meet&quot;, &quot;met&quot;) results ## did not meet met ## 4 6 Another approach—and this is the more instructive and generally-useful procedure—is to begin by looking carefully at the structure of the problematic object: str(tab) ## &#39;table&#39; int [1:2(1d)] 4 6 ## - attr(*, &quot;dimnames&quot;)=List of 1 ## ..$ logicalVector: chr [1:2] &quot;FALSE&quot; &quot;TRUE&quot; We see that the table has an attribute called dimnames dimnames is a list of length one. It is a named list. The name of its only element is logicalVector. The elements of this vector are the column names for the table. If you would like to see the dimnames attribute all by itself, you can access it with the attr() function : attr(tab, which = &quot;dimnames&quot;) # &quot;which&quot; says which attribute you want! ## $logicalVector ## [1] &quot;FALSE&quot; &quot;TRUE&quot; You can also use attr() to set the values of an attribute. Here, we want dimnames to be a list of length one that does not have a name for its sole element. The following should do the trick: attr(tab, which = &quot;dimnames&quot;) &lt;- list(c(&quot;did not meet&quot;, &quot;met&quot;)) Let’s see if this worked: tab ## did not meet met ## 4 6 It appears to have worked very nicely! Hence we may rewrite meetupSim() as follows: meetupSim &lt;- function(reps = 10000, table = FALSE, seed = NULL) { if ( !is.null(seed) ) { set.seed(seed) } anna &lt;- runif(reps, 0, 60) raj &lt;- runif(reps, 0, 60) connect &lt;- (abs(anna - raj) &lt; 10) if ( table ) { cat(&quot;Here is a table of the results:\\n\\n&quot;) tab &lt;- table(connect) attr(tab, which = &quot;dimnames&quot;) &lt;- list(c(&quot;did not meet&quot;, &quot;met&quot;)) print(tab) cat(&quot;\\n&quot;) } cat(&quot;The proportion of tims they met was &quot;, mean(connect), &quot;.\\n&quot;, sep = &quot;&quot;) } Let’s try it out: meetupSim(reps = 100000, table = TRUE, seed = 3939) ## Here is a table of the results: ## ## did not meet met ## 69781 30219 ## ## The proportion of tims they met was 0.30219. Much better! The moral of the story is: Make a habit of examining your objects with the str() function. Combining str() with your abilities to manipulate lists allows you to access and set pieces of the object in helpful ways. Note: the dimnames attribute for tables and matrices is so frequently used that it has its own special function for accessing and setting: dimnames(). Other popular attributes, such as names for a vector and levels for a factor, also have dedicated access/set functions—names() and levels() respectively. But keep in mind that you can access and set the values for any attribute at all with the attr() function. 9.7.1 Practice Exercises Consider the following matrix: myMat &lt;- matrix(1:24, nrow = 4) rownames(myMat) &lt;- letters[1:4] colnames(myMat) &lt;- LETTERS[1:6] myMat ## A B C D E F ## a 1 5 9 13 17 21 ## b 2 6 10 14 18 22 ## c 3 7 11 15 19 23 ## d 4 8 12 16 20 24 Find a way to change the row names of myMAT to “x”, “y”, “z” and “w”, using the attr() function rather than the rownames() function. 9.7.2 Solutions to Practice Exercises First, run str(myMat). You find that it has an attribute called dimnames that is a list of length 2. The first element of this list is the vector of row names. Hence you need to assign new row names to this element. You can do so as follows: attr(myMat, which = &quot;dimnames&quot;)[[1]] &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;) myMat ## A B C D E F ## x 1 5 9 13 17 21 ## y 2 6 10 14 18 22 ## z 3 7 11 15 19 23 ## w 4 8 12 16 20 24 It worked! "],
["glossary-7.html", "Glossary", " Glossary List A heterogeneous vector; that is, a vector whose elements can be any sort of R-object. "],
["exercises-5.html", "Exercises", " Exercises We are given the following list: lst &lt;- list(yabba = letters, dabba = list(x = LETTERS, y = 1:10), do = bcscr::m111survey) One way to access the letter “b” in the first element of lst is as follows: lst$yabba[2] ## [1] &quot;b&quot; Another way is: lst[[1]][2] ## [1] &quot;b&quot; For each of the following objects, find at least two ways to access it within lst: the vector of letters from “c” to “j”; the capital letter “F”; the vector of numbers from 1 to 10; the heights of the five tallest individuals in m111survey. Write a function called goodStats() that, when given a vector of numerical values, computes the mean, median and standard deviation of the values, and returns these values in a list. The function should take two parameters: x: the vector of numerical values; ...: the ellipses, which allow the user to pass in additional arguments. The list returned should name each of the three quantities: the name of the mean should be mean; the name of the standard deviation should be sd; the name of the median should be median. Typical examples of use should look like this: vec &lt;- 1:5 goodStats(x = vec) ## $mean ## [1] 3 ## ## $sd ## [1] 1.581139 ## ## $median ## [1] 3 vec &lt;- c(3, 7, 9, 11, NA) myStats &lt;- goodStats(x = vec, na.rm = TRUE) myStats$mean ## [1] 7.5 "],
["tidyverse-concepts.html", "Chapter 10 Basic Tidyverse Concepts", " Chapter 10 Basic Tidyverse Concepts Figure 10.1: The Treachery of Images (Rene Magritte, 1948). In this chapter we will introduce a few tools from the tidyverse set of R-packages: the pipe operator %&gt;% for chaining function calls in a convenient and readable way; the tibble class, a variant of the data frame that is especially suitable for large data sets; data manipulation functions from the dplyr package suitable for use with the pipe operator: filter() and select() for sub-setting; mutate() for transforming variables; group_by() and summarise() for numerical summaries of data. "],
["tidyverse.html", "10.1 The Tidyverse", " 10.1 The Tidyverse The tidyverse isn’t a package, exactly—it’s a collection of packages. Go ahead and attach it: library(tidyverse) ## Loading tidyverse: ggplot2 ## Loading tidyverse: tibble ## Loading tidyverse: tidyr ## Loading tidyverse: readr ## Loading tidyverse: purrr ## Loading tidyverse: dplyr ## Conflicts with tidy packages ----------------------- ## filter(): dplyr, stats ## lag(): dplyr, stats You get an account of the packages that have been attached. We have worked before with ggplot and by the end of CSC 215 we will have worked with all of the others. You need not worry about the fact that filter() and lag() mask functions from the stats package. "],
["the-pipe-operator.html", "10.2 The Pipe Operator", " 10.2 The Pipe Operator The pipe operator looks like this: %&gt;%. It comes from the magrittr package.26 The pipe operator connects two function calls by making the value returned by the first call the first argument of the second call. Here’s an example: &quot;hello&quot; %&gt;% rep(times = 4) ## [1] &quot;hello&quot; &quot;hello&quot; &quot;hello&quot; &quot;hello&quot; This is the same as the more familiar: rep(&quot;hello&quot;, times = 4) ## [1] &quot;hello&quot; &quot;hello&quot; &quot;hello&quot; &quot;hello&quot; Here’s another example: # same as nrow(bcscr::m111survey) bcscr::m111survey %&gt;% nrow() ## [1] 71 Here’s two pipes: &quot;hello&quot; %&gt;% rep(times = 4) %&gt;% length() ## [1] 4 By default the value of the left-hand call is piped into the right-hand call as the first argument. You can make it some other argument by referring to it as the dot ., for example: 4 %&gt;% rep(&quot;hello&quot;, times = .) ## [1] &quot;hello&quot; &quot;hello&quot; &quot;hello&quot; &quot;hello&quot; Since sub-setting is actually a function call under the hood, you can use the dot there, too: # gets the third element of the sequence 1, 4, 9, ..., 97: seq(1, 100, by = 4) %&gt;% .[3] ## [1] 9 The pipe operator isn’t all that useful when you only use it once or twice in succession. Its true value becomes apparent in the chaining together of many manipulations involving data frames. 10.2.1 Practice Exercises Rewrite the following call with the pipe operator, in three different ways: seq(2, 22, by = 4) ## [1] 2 6 10 14 18 22 Consider mosaicData::CPS85: data(&quot;CPS85&quot;, package = &quot;mosaicData&quot;) Use the pipe operator with subset() to find the row of mosaicData::CPS85 containing the worker who made more than 40 dollars per hour. Display only the sex, age and wage of the worker. 10.2.2 Solutions to the Practice Exercises Here are three ways: 2 %&gt;% seq(22, by = 4) 22 %&gt;% seq(2, ., by = 4) 4 %&gt;% seq(2, 22, by = .) Try this: CPS85 %&gt;% subset(wage &gt; 40) %&gt;% .[, c(&quot;sex&quot;, &quot;age&quot;, &quot;wage&quot;)] ## sex age wage ## 249 F 21 44.5 magrittr is not attached in the tidy-verse, but most of the capability of this package is imported by dplyr.↩ "],
["tibbles.html", "10.3 Tibbles", " 10.3 Tibbles The tibble package gives us tibbles, which are very nearly the same thing as a data frame. Indeed, the name “tibble” is supposed to remind us of a data “table.” Consider the class of bcscr::m111survey: class(bcscr::m111survey) ## [1] &quot;data.frame&quot; Yep, it’s a data frame. But we can convert it to a tibble, as follows: survey &lt;- as_tibble(bcscr::m111survey) class(survey) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; You can treat tibbles like data frames. For now the primary practical difference is manifest when you print a tibble to the Console: survey ## # A tibble: 71 x 12 ## height ideal_ht sleep fastest weight_feel love_first extra_life seat GPA enough_Sleep sex ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 76 78 9.5 119 1_underwei… no yes 1_fr… 3.56 no male ## 2 74 76 7 110 2_about_ri… no yes 2_mi… 2.5 no male ## 3 64 NA 9 85 2_about_ri… no no 2_mi… 3.8 no fema… ## 4 62 65 7 100 1_underwei… no no 1_fr… 3.5 no fema… ## 5 72 72 8 95 1_underwei… no yes 3_ba… 3.2 no male ## 6 70.8 NA 10 100 3_overweig… no no 1_fr… 3.1 yes male ## 7 70 72 4 85 2_about_ri… no yes 1_fr… 3.68 no male ## 8 79 76 6 160 2_about_ri… no yes 3_ba… 2.7 yes male ## 9 59 61 7 90 2_about_ri… no yes 3_ba… 2.8 no fema… ## 10 67 67 7 90 3_overweig… no no 2_mi… NA yes fema… ## # … with 61 more rows, and 1 more variable: diff.ideal.act. &lt;dbl&gt; The output is automatically truncated, and the number of columns printed is determined by the width of your screen. This is a great convenience when one is dealing with larger data sets. Many larger data tables in packages will come to you as tibbles. "],
["subsetting-with-dplyr.html", "10.4 Subsetting with dplyr", " 10.4 Subsetting with dplyr The dplyr function filter() is the rough equivalent of select(): it picks out rows of a data frame (or similar objects such as a tibble). The dplyr function select() subsets for columns. Thus you can use the two functions together to do perform sub-setting. With the pipe operator, your code can be quite easy to read: survey %&gt;% filter((sex == &quot;male&quot; &amp; height &gt; 70) | (sex ==&quot;female&quot; &amp; height &lt; 55)) %&gt;% select(sex, height, fastest) ## # A tibble: 22 x 3 ## sex height fastest ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 male 76 119 ## 2 male 74 110 ## 3 male 72 95 ## 4 male 70.8 100 ## 5 male 79 160 ## 6 male 73 110 ## 7 male 73 120 ## 8 female 54 130 ## 9 male 74 119 ## 10 male 72 125 ## # … with 12 more rows Note that dplyr data-functions like filter() and select() take a data table as their first argument, and return a data table as well. Hence they may be chained together as we saw in the above example. With select() it’s easy to leave out columns, too: survey %&gt;% select(-ideal_ht, -love_first) ## # A tibble: 71 x 10 ## height sleep fastest weight_feel extra_life seat GPA enough_Sleep sex diff.ideal.act. ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 76 9.5 119 1_underweight yes 1_front 3.56 no male 2 ## 2 74 7 110 2_about_right yes 2_middle 2.5 no male 2 ## 3 64 9 85 2_about_right no 2_middle 3.8 no fema… NA ## 4 62 7 100 1_underweight no 1_front 3.5 no fema… 3 ## 5 72 8 95 1_underweight yes 3_back 3.2 no male 0 ## 6 70.8 10 100 3_overweight no 1_front 3.1 yes male NA ## 7 70 4 85 2_about_right yes 1_front 3.68 no male 2 ## 8 79 6 160 2_about_right yes 3_back 2.7 yes male -3 ## 9 59 7 90 2_about_right yes 3_back 2.8 no fema… 2 ## 10 67 7 90 3_overweight no 2_middle NA yes fema… 0 ## # … with 61 more rows 10.4.1 Practice Exercises Can you use the pipe to chain dplyr functions along with nrow() to find out how many people in survey believe in love at first sight and drove more than 120 miles per hour? Find the three largest heights of the males who drove more than 120 miles per hour. Use the pipe and filter() to make violin plots of the wages of men and women in CPS85, where the outlier-person (whose wage was more than 40 dollars per hour) has been eliminated prior to making the graph. 10.4.2 Solutions to Practice Exercises Try this: survey %&gt;% filter(love_first == &quot;yes&quot; &amp; fastest &gt; 120) %&gt;% nrow() ## [1] 3 Here’s one way: survey %&gt;% filter(sex == &quot;male&quot; &amp; fastest &gt; 120) %&gt;% .$height %&gt;% # this is just a vector sort(decreasing = TRUE) %&gt;% # so you can sort it ... .[1:3] # then get its first three elements ## [1] 79 75 75 Try this code: CPS85 %&gt;% filter(wage &lt;= 40) %&gt;% ggplot(aes(x = sex, y = wage)) + geom_violin(fill = &quot;burlywood&quot;) "],
["transforming-variables-with-dplyr.html", "10.5 Transforming Variables with dplyr", " 10.5 Transforming Variables with dplyr In dplyr you transform variables with the function mutate(). Here is an example: survey %&gt;% mutate(dareDevil = fastest &gt; 125) %&gt;% select(sex, fastest, dareDevil) ## # A tibble: 71 x 3 ## sex fastest dareDevil ## &lt;fct&gt; &lt;int&gt; &lt;lgl&gt; ## 1 male 119 FALSE ## 2 male 110 FALSE ## 3 female 85 FALSE ## 4 female 100 FALSE ## 5 male 95 FALSE ## 6 male 100 FALSE ## 7 male 85 FALSE ## 8 male 160 TRUE ## 9 female 90 FALSE ## 10 female 90 FALSE ## # … with 61 more rows In mutate() there is always a variable-name on the left-hand side of the = sign. It could be the same as an existing variable in the table if you are content to overwrite that variable. On the right side of the = is a function that can depend on variables in the data table. You can transform more than one variable in a single call to mutate(), as in the code below. The output is shown in 10.2. survey %&gt;% mutate(dareDevil = fastest &gt; 125, speedKmHr = fastest * 1.60934) %&gt;% ggplot(aes(x = dareDevil, y = GPA)) + geom_boxplot(fill = &quot;burlywood&quot;, outlier.alpha = 0) + geom_jitter(width = 0.2) Figure 10.2: Graph produced after mutation. 10.5.1 Practice Exercises In mosaicData::CPS85 transform the wage variable to units of dollars per day. (Assume an 8-hour working day.) 10.5.2 Solutions to Practice Exercises Try this: CPS85 %&gt;% as_tibble() %&gt;% # for display in Console mutate(dailyWage = wage * 8) %&gt;% select(sex, sector, dailyWage) # for display in Console ## # A tibble: 534 x 3 ## sex sector dailyWage ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 M const 72 ## 2 M sales 44 ## 3 F sales 30.4 ## 4 F clerical 84 ## 5 M const 120 ## 6 F clerical 72 ## 7 F service 76.6 ## 8 M sales 120 ## 9 M manuf 88 ## 10 F sales 40 ## # … with 524 more rows "],
["grouping-and-summaries.html", "10.6 Grouping and Summaries", " 10.6 Grouping and Summaries The next two dplyr data-functions are useful for generating numerical summaries of data. Consider, for example, CPS85. We know from graphical studies that the men in the study are paid more than women, but how might we verify this fact numerically? One approach would be to separate the men and the women into two different groups and compute the mean wage for each group. This is accomplished by calling group_by() and summarise() in succession: CPS85 %&gt;% group_by(sex) %&gt;% summarize(meanWage = mean(wage)) ## # A tibble: 2 x 2 ## sex meanWage ## &lt;fct&gt; &lt;dbl&gt; ## 1 F 7.88 ## 2 M 9.99 It’s possible to create more than one summary variable in a single call to summarise(), for example: CPS85 %&gt;% group_by(sex) %&gt;% summarize(meanWage = mean(wage), n = n()) ## # A tibble: 2 x 3 ## sex meanWage n ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 F 7.88 245 ## 2 M 9.99 289 In the previous example, dplyr::n() was used to count the number of cases in each group. For a more complete account of a numerical variable, one might consider the five-number summary: the minimum value the first quartile (Q1) the median the third quartile (Q3) the maximum value These quantities are conveniently computed by R’s fivenum() function: CPS85 %&gt;% .$wage %&gt;% fivenum() ## [1] 1.00 5.25 7.78 11.25 44.50 Let’s find the five number summaries for the wages of men and women: CPS85 %&gt;% group_by(sex) %&gt;% summarise(n = n(), min = fivenum(wage)[1], Q1 = fivenum(wage)[2], median = fivenum(wage)[3], Q3 = fivenum(wage)[4], max = fivenum(wage)[5]) ## # A tibble: 2 x 7 ## sex n min Q1 median Q3 max ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 F 245 1.75 4.75 6.8 10 44.5 ## 2 M 289 1 6 8.93 13 26.3 It’s also possible to group by more than one variable at a time. For example, suppose that we wish to compare the wages of men and women in the various sectors of employment. All we need to do is group by both sex and sector: CPS85 %&gt;% group_by(sector, sex) %&gt;% summarise(n = n(), min = fivenum(wage)[1], Q1 = fivenum(wage)[2], median = fivenum(wage)[3], Q3 = fivenum(wage)[4], max = fivenum(wage)[5]) ## # A tibble: 15 x 8 ## # Groups: sector [8] ## sector sex n min Q1 median Q3 max ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 clerical F 76 3 5.1 7 9.55 15.0 ## 2 clerical M 21 3.35 6 7.69 9 12 ## 3 const M 20 3.75 7.15 9.75 11.8 15 ## 4 manag F 21 3.64 6.88 10 11.2 44.5 ## 5 manag M 34 1 8.8 14.0 18.2 26.3 ## 6 manuf F 24 3 4.36 4.9 6.05 18.5 ## 7 manuf M 44 3.35 6.58 8.94 11.2 22.2 ## 8 other F 6 3.75 4 5.62 6.88 8.93 ## 9 other M 62 2.85 5.25 7.5 11.2 26 ## 10 prof F 52 4.35 7.02 10 12.3 25.0 ## 11 prof M 53 5 8 12 16.4 25.0 ## 12 sales F 17 3.35 3.8 4.55 5.65 14.3 ## 13 sales M 21 3.5 5.56 9.42 12.5 20.0 ## 14 service F 49 1.75 3.75 5 8 13.1 ## 15 service M 34 2.01 4.15 5.89 8.75 25 Note that there were no women in the construction sector, so that group did not appear in the summary. 10.6.1 Note on Binding Keep in mind that you can always “save” the results of any computation by binding them to a variable name, thus: sexSector &lt;- CPS85 %&gt;% group_by(sector, sex) %&gt;% summarise(n = n(), min = fivenum(wage)[1], Q1 = fivenum(wage)[2], median = fivenum(wage)[3], Q3 = fivenum(wage)[4], max = fivenum(wage)[5]) class(sexSector) ## [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Note that the result has data.frame as one of its classes, so you may extract components in any of the ways you have learned. The old ways, for instance, are fine: # minimum wage among male professionals: with(sexSector, min[sex == &quot;M&quot; &amp; sector == &quot;prof&quot;]) ## [1] 5 10.6.2 Practice Exercises These exercises deal with flight data from the nycflights13 data frame: data(&quot;flights&quot;, package = &quot;nycflights13&quot;) The flights table gives information about each departure in the year 2013 from one of the three major airports near New York City: John F. Kennedy (JFK), LaGuardia (LGA) or Newark (EWR). The airport from which the plane departed is recorded in the variable origin. The variable dep_delay gives the delay in departure, in minutes. (This is a negative number if the plane left early). Find the number of departures and the mean departure delay for each of the three airports. (Note that dep_delay for cancelled flights will be NA.) The variable distance gives the distance, in miles, between an origin and destination airport. For July 26, 2013, make a violin plot of the distances traveled by the departing planes from the each of the three New York airports. Use the pipe and filter() to take flights into the desired plot. Examine the plot you made in the previous problem: two of the flights appear to be about 5000 miles. Use the pipe, filter() and select() to display the origin, destination and distance for these two flights. 10.6.3 Solutions to Practice Exercises Flights that were cancelled have NA for their departure delay, so we need to filter out these cases first, in order to correctly count the number of flights that actually left the airport. Try this: flights %&gt;% filter(!is.na(dep_delay)) %&gt;% group_by(origin) %&gt;% summarise(departures = n(), meanDelay = mean(dep_delay)) ## # A tibble: 3 x 3 ## origin departures meanDelay ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 EWR 117596 15.1 ## 2 JFK 109416 12.1 ## 3 LGA 101509 10.3 Try this: flights %&gt;% filter(month == 6 &amp; day == 26) %&gt;% ggplot(aes(x = origin, y = distance)) + geom_violin(fill = &quot;burlywood&quot;) + geom_jitter(width = 0.25, size = 0.1) Try this: flights %&gt;% filter(month == 6 &amp; day == 26 &amp; distance &gt; 4000) %&gt;% select(origin, dest, distance) ## # A tibble: 2 x 3 ## origin dest distance ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 JFK HNL 4983 ## 2 EWR HNL 4963 "],
["exercises-6.html", "Exercises", " Exercises Use the pipe operator to rewrite the following command in three ways: runif(10, min = 0, max = 5) Rewrite the following command using two pipe operators in succession: paste(&quot;hello&quot;, &quot;there&quot;, &quot;Bella&quot;) ## [1] &quot;hello there Bella&quot; Use the pipe operator and dplyr functions to rewrite the following command: head(subset(m111survey, sex == &quot;female&quot;)[, c(&quot;height&quot;, &quot;fastest&quot;)],6) The next few exercises are about the babynames data frame from the babynames package. Find the names for females born in 2015 that were given to more than 1% of female applicants (i.e., prop is bigger than 0.01). Use the pipe operator and dplyr functions to produce the following graph of the popularity of “Mary” and “Mia” as girl-names over the years. Note that popularity is given as number per one thousand applicants, i.e., as prop * 1000. "],
["strings.html", "Chapter 11 Strings", " Chapter 11 Strings Figure 11.1: RTL, by xkcd. In this chapter we will take a closer look at character-vectors, and in particular at character vectors of length one, which are commonly called “strings.” The ability to manipulate strings is the foundation for all text-processing in computer programming. "],
["character-vectors-strings.html", "11.1 Character Vectors: Strings", " 11.1 Character Vectors: Strings Computers work at least as much with text as they do with numbers. In computer science the values that refer to text are called strings. In R, as in most other programming languages, we use quotes as delimiters, meaning that they mark the beginning and the end of strings. Recall that in R, strings are of type character. For example: greeting &lt;- &quot;hello&quot; typeof(greeting) ## [1] &quot;character&quot; Of course, a single string does not exist on its own in R. Instead it exists as the only element of a character-vector of length 1. is.vector(greeting) ## [1] TRUE length(greeting) ## [1] 1 To make strings we can use double quotes or single quotes. Since the string-value does not include the quotes themselves but only what appears between them, it does not make any difference which type of quotes we use: greeting1 &lt;- &quot;hello&quot; greeting2 &lt;- &#39;hello&#39; greeting1 == greeting2 ## [1] TRUE When we make a character vector of length greater than one, we can even use both single and double quotes: politeWords &lt;- c(&quot;Please?&quot;, &#39;Thank you!&#39;) politeWords ## [1] &quot;Please?&quot; &quot;Thank you!&quot; Notice that when R prints politeWords to the console it uses double-quotes. Indeed, double-quoting is the recommended and most common way to construct strings in R. "],
["characters-and-special-characters.html", "11.2 Characters and Special Characters", " 11.2 Characters and Special Characters Strings are made up of characters: that’s why R calls them “character vectors.” From your point of view as a speaker of the English language, characters would seem to be the things you would have entered on a typewriter, and which can be entered from your computer keyboard as well: the lower-case letters a-z; the upper case letters A-Z; the digits 0,1, …, 9 (0-9); the punctuation characters: ., -, ?, !, ;, :, etc. (and of course the comma, too!) a few other special-use characters: ~, @, #, $, %, _, +, =, and so on; and the space, too! All of the above can be part of a string. But quote-marks (used in quotation and as apostrophes) can also be part of a string: &quot;Welcome&quot;, she said, &quot;the coffee&#39;s on me!&quot; Since quote-marks are used to delimit strings but can also be part of them, designers of programming languages have to think carefully about how to manage quote-marks. Here’s how it works in R: If you choose to delimit a string with double-quotes, then you can put single-quotes anywhere you like within the string and they will be treated by the computer as literal single-quotes, not as string-delimiters. Here is an example: cat(&quot;&#39;Hello&#39;, she said.&quot;) ## &#39;Hello&#39;, she said. If you delimit with double-quotes and you want to place a double-quote in your string, then you have to escape that double-quote with the backslash character \\: cat(&quot;\\&quot;Hello\\&quot;, she said.&quot;) ## &quot;Hello&quot;, she said. If you choose to delimit a string with single-quotes, then you can put double-quotes anywhere you like within the string and they will be treated by the computer as literal double-quotes, not as string-delimiters. cat(&#39;&quot;Hello&quot;, she said.&#39;) ## &quot;Hello&quot;, she said. If you delimit with single-quotes and you want to place a single-quote in your string, then you have to escape that single-quote: cat(&#39;\\&#39;Hello\\&#39;, she said.&#39;) ## &#39;Hello&#39;, she said. In R and in many other programming languages the backslash \\ permits the following character to “escape” any special meaning that is otherwise assigned to it by the language. When we write \\&quot; we say that we are “escaping” the double-quote; more precisely, we are escaping the special role of the double-quote as a delimiter for strings. Of course the foregoing implies that the backslash character has a special role in the language: as an escaping-device. So what can we do if we want a literal backslash in our string? Well, we simply escape it by preceding it with a backslash: cat(&quot;up\\\\down&quot;) ## up\\down Another example: cat(&quot;C:\\\\\\\\Inetpub\\\\\\\\vhosts\\\\\\\\example.com&quot;) ## C:\\\\Inetpub\\\\vhosts\\\\example.com So much for “ordinary” characters. But there are special characters, too, sometimes called control characters, that do not represent written symbols. We have seen a couple of them already; the newline character \\n is one: bye &lt;- &quot;Farewell!\\n\\n&quot; cat(bye) ## Farewell! # first \\n moves us to a new line ... ## # .. which is empty due the next \\n We have also seen the tab-character \\t: cat(&quot;First Name\\tLast Name&quot;) ## First Name Last Name Notice that the backslash character is used here to allow the n and t to escape their customary roles as the letters “n” and t respectively. If you ask R, (try help(Quotes)), you will learn that there are several control characters, including: Table 11.1: Some control characters. Character Meaning \\n newline \\r carriage return \\t tab \\b backspace \\a alert (bell) \\f form feed \\v vertical tab It is worth exploring their effects. Here are a couple of examples27: cat(&quot;Hell\\to&quot;) ## Hell o cat(&quot;Hell\\ro&quot;) ## Hell o A number of other non-control characters can be generated with the backslash. Unicode characters, for instance, are generated by \\u{nnnn}, where the n’s represent hexadecimal digits. Try the following in your console, and see what you get: cat(&quot;\\u{2603}&quot;) # the Snowman ## ☃ Or, for something zanier: cat(&quot;Hello\\u{202e}there, Friend!&quot;) ## Hello‮there, Friend! Note that cat(&quot;Hell\\ao&quot;) won’t give you “Hello” with a bell-sound. To hear a bell you have to work with a terminal on your own computer. On Linux or Mac, type echo -e &quot;\\a&quot; and you should hear a beep.↩ "],
["basic-string-operations.html", "11.3 Basic String Operations", " 11.3 Basic String Operations We now introduce a few basic operations for examining, splitting and combining strings. Some of the functions we discuss come from the stringr package, which is installed along with the tidyverse but is not automatically attached. Make sure you attach it when you work with strings: library(stringr) 11.3.1 Is and As Recall from Chapter 2 that as.character() coerces other data types into strings: as.character(3.14) ## [1] &quot;3.14&quot; as.character(FALSE) ## [1] &quot;FALSE&quot; as.character(NULL) ## character(0) Also, is.character() tests whether an object is character-vector: is.character(3.14) ## [1] FALSE 11.3.2 Number of Characters How many characters are in the word “hello”? Let’s try: length(&quot;hello&quot;) ## [1] 1 Oh, right, strings don’t exist alone: &quot;hello&quot; is actually a character-vector of length 1. Instead we should use the str_sub() function: str_length(&quot;hello&quot;) ## [1] 5 11.3.3 Substrings and Trimming We can pull out pieces of a string with the str_sub() function: poppins &lt;- &quot;Supercalifragilisticexpialidocious&quot; str_sub(poppins, start = 10, end = 20) ## [1] &quot;fragilistic&quot; One can also use substr() to replace part of a string with some other string: str_sub(poppins, start = 10, end = 20) &lt;- &quot;ABCDEFGHIJK&quot; poppins ## [1] &quot;SupercaliABCDEFGHIJKexpialidocious&quot; Don’t forget: “vector-in, vector-out” usually applies: words &lt;- c(&quot;Mary&quot;, &quot;Poppins&quot;, &quot;practically&quot;, &quot;perfect&quot;) str_length(words) ## [1] 4 7 11 7 str_sub(words, 1, 3) ## [1] &quot;Mar&quot; &quot;Pop&quot; &quot;pra&quot; &quot;per&quot; In practical data-analysis situations you’ll often have to work with strings that include unexpected non-printed characters at the beginning or the end, especially if the string once occurred at the end of a line in a text file. For example, consider: lastWord &lt;- &quot;farewell\\r\\n&quot; str_length(lastWord) ## [1] 10 cat(lastWord) ## farewell From its display on the console, you might infer that lastWord consists of only the eight characters: f, a, r, e, w, e, l, and l. (You can’t see the carriage return followed by the newline.) But str_length() clearly shows that it’s got two characters after the final “l”, even if you can’t see them. If you think your strings might contain unnecessary leading or trailing white-space, you can remove it with str_trim(): str_trim(lastWord) ## [1] &quot;farewell&quot; 11.3.4 Changing Cases You can make all of the letters in a string lowercase: str_to_lower(&quot;My name is Rhonda.&quot;) ## [1] &quot;my name is rhonda.&quot; You can make them all uppercase: str_to_upper(&quot;It makes me wanna holler!&quot;) ## [1] &quot;IT MAKES ME WANNA HOLLER!&quot; 11.3.5 Splitting Strings Consider the following character vector that records several dates: dates &lt;- c(&quot;3-14-1963&quot;, &quot;04-01-1965&quot;, &quot;12-2-1983&quot;) You might want to print them out in some uniform way, using the full name of the month, perhaps. Then you would need to gain access to the elements of each date separately, so that you could transform month-numbers to month-names. str_split() will do the job for you: str_split(dates, pattern = &quot;-&quot;) ## [[1]] ## [1] &quot;3&quot; &quot;14&quot; &quot;1963&quot; ## ## [[2]] ## [1] &quot;04&quot; &quot;01&quot; &quot;1965&quot; ## ## [[3]] ## [1] &quot;12&quot; &quot;2&quot; &quot;1983&quot; The result is a list with one element for each date in dates. Each element of the list is a character vector containing the elements—month-number, day-number and year—that were demarcated in the original strings by the hyphen -, the value given to the pattern parameter. If we wish, we may now access the elements of the list and process them in any way we like. We might report the months, for example: dates %&gt;% str_split(pattern = &quot;-&quot;) %&gt;% unlist() %&gt;% .[c(1, 4, 7)] %&gt;% as.numeric() %&gt;% month.name[.] ## [1] &quot;March&quot; &quot;April&quot; &quot;December&quot; (Note the use in the code above of the months.name constant provided by R.) Sometimes it’s handy to split a string word-by-word: &quot;you have won the lottery&quot; %&gt;% str_split(pattern = &quot; &quot;) %&gt;% unlist() ## [1] &quot;you&quot; &quot;have&quot; &quot;won&quot; &quot;the&quot; &quot;lottery&quot; Of course splitting on the space would not have worked if some of the words had been separated by more than one space: &quot;you have won the lottery&quot; %&gt;% # two spaces betwen &#39;the&#39; and &#39;lottery&#39; str_split(pattern = &quot; &quot;) %&gt;% unlist() ## [1] &quot;you&quot; &quot;have&quot; &quot;won&quot; &quot;the&quot; &quot;&quot; &quot;lottery&quot; We’ll address this problem soon. In order to split a string into its constituent characters, split on the string with no characters: &quot;aardvark&quot; %&gt;% str_split(pattern = &quot;&quot;) %&gt;% unlist() ## [1] &quot;a&quot; &quot;a&quot; &quot;r&quot; &quot;d&quot; &quot;v&quot; &quot;a&quot; &quot;r&quot; &quot;k&quot; This would be useful if you wanted to, say, count the number of occurrences of “a” in a word: &quot;aardvark&quot; %&gt;% str_split(pattern = &quot;&quot;) %&gt;% unlist() %&gt;% .[. == &quot;a&quot;] %&gt;% length() ## [1] 3 11.3.6 Pasting and Joining Strings We are already familiar with paste(), which allows us to paste together the arguments that are passed to it: paste(&quot;Mary&quot;, &quot;Poppins&quot;) ## [1] &quot;Mary Poppins&quot; By default paste() separates the input strings with a space, but you can control this with the sep parameter: paste(&quot;Mary&quot;, &quot;Poppins&quot;, sep = &quot;:&quot;) ## [1] &quot;Mary:Poppins&quot; paste(&quot;Yabba&quot;,&quot;dabba&quot;,&quot;doo!&quot;, sep = &quot;&quot;) ## [1] &quot;Yabbadabbadoo!&quot; If you want the separator to be the empty string by default, then you could use paste0(): paste0(&quot;Yabba&quot;,&quot;dabba&quot;,&quot;doo!&quot;) ## [1] &quot;Yabbadabbadoo!&quot; The stringr version of paste0() is str_c(): str_c(&quot;Yabba&quot;,&quot;dabba&quot;,&quot;doo!&quot;) ## [1] &quot;Yabbadabbadoo!&quot; What if you had a character-vector whose elements you wanted to paste together? For example, consider: poppins &lt;- c(&quot;practically&quot;, &quot;perfect&quot;, &quot;in&quot;, &quot;every&quot;, &quot;way&quot;) Now suppose you want to paste the elements of poppins together into one string where the words are separated by spaces. str_c() will do the job for you, if you use its collapse parameter: poppins %&gt;% str_c(collapse = &quot; &quot;) ## [1] &quot;practically perfect in every way&quot; We’ll call this process joining. In an atomic vector all of the elements have to be of the same data type (all character, all numerical, etc.). What if you want to join objects of different types? If there are only a few, feel free to type them in as separate arguments to str_c(): str_c(&quot;March&quot;, 14, 1963, sep = &quot; &quot;) ## [1] &quot;March 14 1963&quot; If the objects are many, then you could arrange for them appear as the elements of a list: list(&quot;Mary&quot;, 343, &quot;Poppins&quot;, FALSE) %&gt;% str_c(collapse = &quot; &quot;) ## [1] &quot;Mary 343 Poppins FALSE&quot; Joining appears to be the opposite of splitting, but in R that’s not quite so. Suppose, for instance, that you have dates where the month, day and year are separated by hyphens and you want to replace the hyphens with forward slashes: 3-14-1963 # you have this 3/14/1963 # you want this You could try this: &quot;3-14-1963&quot; %&gt;% str_split(pattern = &quot;-&quot;) %&gt;% str_c(collapse = &quot;/&quot;) ## [1] &quot;c(\\&quot;3\\&quot;, \\&quot;14\\&quot;, \\&quot;1963\\&quot;)&quot; That’s not what we want. We have to remember than the result of applying str_split() is a list: &quot;3-14-1963&quot; %&gt;% str_split(pattern = &quot;-&quot;) ## [[1]] ## [1] &quot;3&quot; &quot;14&quot; &quot;1963&quot; We need to unlist prior to the join. The correct procedure is: &quot;3-14-1963&quot; %&gt;% str_split(pattern = &quot;-&quot;) %&gt;% unlist() %&gt;% str_c(collapse = &quot;/&quot;) ## [1] &quot;3/14/1963&quot; Now all is well. Soon, though, we’ll learn a superior method for performing substitutions in strings. "],
["formatted-printing.html", "11.4 Formatted Printing", " 11.4 Formatted Printing Quite often when we are printing out to the console we want each line to follow some uniform format. This can be accomplished with the sprintf() function.28 Lets begin with an example: first &lt;- &quot;Mary&quot; last &lt;- &quot;Poppins&quot; sprintf(fmt = &quot;%10s%20s&quot;, first, last) ## [1] &quot; Mary Poppins&quot; sprintf() builds a string from the strings first and last that were passed to it. The fmt parameter is a string that encodes the format of the result. In this example, the command comes down to: create a string of width 10, consisting of five spaces followed by the five characters of “Mary” create a string of width 20, consisting of 13 spaces followed by the seven characters of “Poppins” The preceding two strings are called fields. We then join the above the fields, with nothing between them. Here is the result, cated out: sprintf(fmt = &quot;%10s%20s&quot;, first, last) %&gt;% cat() ## Mary Poppins The “s” in the the fmt argument is called a conversion character. It tells sprintf() to expect a string. Each percent sign indicates the beginning of a new field. For each field, the desired field-width should appear between the percent-sign and the conversion character for the field. In the text above, the names are right-justified, meaning that they appear at the end of their respective fields. If you want a field to be left-justified, insert a hyphen anywhere between the percent sign and the conversion character, like so: # left-justify both fields: sprintf(fmt = &quot;%-10s%-20s&quot;, first, last) %&gt;% cat() ## Mary Poppins Other common conversion characters are: d: an integer f: a decimal number (default is 6 digits precision) g: a decimal number where the default precision is determined by the number of significant figures in the given number Here is another example: sprintf(fmt = &quot;%-10s%-10d%-10f&quot;, &quot;Mary&quot;, 1955, 3.2) %&gt;% cat() ## Mary 1955 3.200000 The following example is the same as above, except that we retain only the significant figures in the 3.2: sprintf(fmt = &quot;%-10s%-10d%-10g&quot;, &quot;Mary&quot;, 1955, 3.2) %&gt;% cat() ## Mary 1955 3.2 When you are creating a field for a decimal number, you can specify both the total field-width and the precision together if you separate them with a .. Thus, if you want the number 234.5647 to appear right-justified in a field of width 10, showing only the first three decimal places, then try: sprintf(fmt = &quot;%-10s%-10d%-10.3f&quot;, &quot;Mary&quot;, 1955, 234.5647) %&gt;% cat() ## Mary 1955 234.565 sprintf() comes in handy when you want your output to appear in nicely-aligned, tabular fashion. Consider this example: # information for three people: firstName &lt;- c(&quot;Donald&quot;, &quot;Gina&quot;, &quot;Rohini&quot;) lastName &lt;- c(&quot;Duck&quot;, &quot;Gentorious&quot;, &quot;Lancaster&quot;) age &lt;- c(17, 19, 20) gpa &lt;- c(3.7, 3.9, 3.823) for (i in 1:3) { sprintf(&quot;%-15s%-20s%-5d%-5.2f\\n&quot;, firstName[i], lastName[i], age[i], gpa[i]) %&gt;% cat() } ## Donald Duck 17 3.70 ## Gina Gentorious 19 3.90 ## Rohini Lancaster 20 3.82 Note the use of “\\n” in the fmt argument to ensure that the output appears on separate lines. You could take advantage of vectorization to avoid the loop: sprintf(&quot;%-15s%-20s%5-d%-5.2f\\n&quot;, firstName, lastName, age, gpa) %&gt;% cat() ## Donald Duck 17 3.70 ## Gina Gentorious 19 3.90 ## Rohini Lancaster 20 3.82 Well, that’s not quite right: the second and third lines begin with a space. This happens because cat() separates its input with a space by default. You can prevent this, however, with the sep parameter of cat(): sprintf(&quot;%-15s%-20s%-5d%-5.2f\\n&quot;, firstName, lastName, age, gpa) %&gt;% cat(sep = &quot;&quot;) ## Donald Duck 17 3.70 ## Gina Gentorious 19 3.90 ## Rohini Lancaster 20 3.82 You can think of sprintf as short for: “formatted printing in S”. S was the forerunner to the R language.↩ "],
["glossary-8.html", "Glossary", " Glossary String A sequence of characters. Control Character A member of a character set that does not represent a written symbol. Unicode A computing-industry standard for the consistent encoding of text in most of the world’s written languages. "],
["exercises-7.html", "Exercises", " Exercises Write a function called revStr() that reverses the characters of any string that it is given. The function should take a single parameter: str: a character-vector of length 1 (a single string). Typical examples of use should look like this: revStr(str = &quot;goodbye&quot;) ## [1] &quot;eybdoog&quot; Hint: Let’s think about how to solve the reversal problem for a specific string, e.g.: str &lt;- &quot;goodbye&quot; First, we could turn the string into a list whose only element is the vector of the characters of the string, as follows: splitString &lt;- str_split(str, pattern = &quot;&quot;) splitString ## [[1]] ## [1] &quot;g&quot; &quot;o&quot; &quot;o&quot; &quot;d&quot; &quot;b&quot; &quot;y&quot; &quot;e&quot; This could be turned into just the desired vector with the unlist() function: unlist(splitString) ## [1] &quot;g&quot; &quot;o&quot; &quot;o&quot; &quot;d&quot; &quot;b&quot; &quot;y&quot; &quot;e&quot; Next, recall that R has a function rev() that, when given a vector, returns a vector with the elements in reverse order: rev(unlist(splitString)) ## [1] &quot;e&quot; &quot;y&quot; &quot;b&quot; &quot;d&quot; &quot;o&quot; &quot;o&quot; &quot;g&quot; Finally, we would need to convert the reversed vector back into a single string. You have learned a stringr function that will accomplish this. After you have solved the problem for the specific vector str, encapsulate your work into the function revStr(). A string is said to be a palindrome if it is the same no matter whether it is spelled backwards or forwards. Write a function called palindromeStr() that determines whether or not a given string is a palindrome. The function should take a single parameter: str: a character-vector of length 1 (a single string). It should return TRUE if str is a palindrome, and return FALSE otherwise. Typical example of use should look like this: palindromeStr(str = &quot;abba&quot;) ## [1] TRUE palindromeStr(&quot;hello&quot;) ## [1] FALSE Hint; Again, you should begin by solving the problem on a specific vector, and only then encapulate your work into a function. To solve the specific problem, you might use the function revStr() from the previous problem. Another possibility is to use rev() along with the function all() that you met in Chapter 2. Write a function called subStrings() that returns a vector of the substrings of a given string that have at least a given number of characters. The function should take two arguments: str: a character-vector of length 1 (a single string); n: the minimum number of characters a substring should have in order to be included in the vector. Validate the input: if the argument for n is less than 1 or greater than the number of characters in str, then the function should advise the user and cease execution. Typical examples of use should look like this (although it is OK if your output-vector contains the sub-strings in a different order): subStrings(&quot;hello&quot;, 3) ## [1] &quot;hello&quot; &quot;hell&quot; &quot;ello&quot; &quot;hel&quot; &quot;ell&quot; &quot;llo&quot; subStrings(&quot;hello&quot;, 6) ## n should be at least 1 and no more than the number ## of characters in str. Hint: Begin by writing a function, called perhaps subStringFixed(), that when given a string and a specific number \\(n\\), returns all of the substrongs of length exactly \\(n\\). It might work like this: subStringFixed(str = &quot;yabbadabbadoo!&quot;, n = 6) ## [1] &quot;yabbad&quot; &quot;abbada&quot; &quot;bbadab&quot; &quot;badabb&quot; &quot;adabba&quot; &quot;dabbad&quot; &quot;abbado&quot; &quot;bbadoo&quot; &quot;badoo!&quot; subStringFixed(str = &quot;yabbadabbadoo!&quot;, n = 0) ## n should be at least 1 and no more than the number ## of characters in str. Write a function called subPalindrome() that, for any given string and specified number \\(n\\), returns a character vector of all the substrings of the string having at least \\(n\\) characters that are also palindromes. The function should take two arguments: str: a character-vector of length 1 (a single string); n: the minimum number of characters a substring should have in order to be included in the vector. Validate the input: if the argument for n is less than 1 or greater than the number of characters in str, then the function should advise the user and cease execution. Typical examples of use should look like this (although it is OK if your output-vector contains the palindromes in a different order): ## Note that palindrome substrings are repeated as many times ## as they occur in the given string: subPalindrome(&quot;yabbadabbadoo!&quot;, 2) ## [1] &quot;abbadabba&quot; &quot;bbadabb&quot; &quot;dabbad&quot; &quot;badab&quot; &quot;abba&quot; &quot;abba&quot; &quot;ada&quot; ## [8] &quot;bb&quot; &quot;bb&quot; &quot;oo&quot; subPalindrome(&quot;yabbadabbadoo!&quot;, 10) ## character(0) subPalindrome(&quot;yabbadabbadoo!&quot;, 0) ## n should be at least 1 and no more than the number ## of characters in str. Write a function called m111Report() that performs formatted printing from the data frame m111survey in the bcscr package. Given a vector of row numbers, the function will print out the sex, feeling about weight, and GPA of the corresponding individuals. Thus each row in the printout will correspond to an individual in the study. Each row will consist of three fields: The first field is 10 characters wide, and contains either “male” or “female”, followed by the appropriate number of spaces. The first field is 15 characters wide, and contains either “underweight” or “about right” or “overweight”, followed by the appropriate number of spaces. The third field is 5 characters wide, and contains an appropriate number of spaces followed by the grade-point average showing only the first two decimal places. This, if a person’s GPA is recorded as 2.714 then the field will be &quot; 2.71&quot;. (Note that, with the space and the decimal point, the total number of characters is 5, as required.) A typical example of use is as follows: m111Report(c(2, 10, 15)) ## male about right 2.50 ## female overweight NA ## male underweight 3.20 Note that you will have to re-code the feelings about weight. "],
["regex.html", "Chapter 12 Regular Expressions", " Chapter 12 Regular Expressions Figure 12.1: Regular Expressions, by xkcd. In this Chapter we introduce the concept of regular expressions, a powerful tool that enables you to search for complex patterns in text. We will continue to use functions from the stringr package, so make sure you have it attached. "],
["motivation.html", "12.1 Motivation", " 12.1 Motivation Suppose you wish to determine how many times the string “ab” appears within some given string. You could write a function to perform this task. occurrences &lt;- function(string) { count &lt;- 0 for (i in 1:str_length(string)) { stringPart &lt;- str_sub(string, i, i+1) if ( stringPart == &quot;ab&quot; ) { count &lt;- count +1 } } count } Let’s try it out: occurrences(&quot;yabbadabbadoo!&quot;) ## [1] 2 This looks right, as there are indeed exactly two occurrences of “ab”: one at beginning at the second character and another beginning at the seventh character. Suppose instead that we are interested in counting occurrences, in some arbitrary given string, of any of the following three strings: “ab” “Ab” “foo” How might we handle this task? Again we could write a function. This time we will generalize it a bit, allowing the user to input, along with the string to be searched, a vector of the sub-strings of interest. # function to count occurrences of substrings in string. # substrings are given as patterns occurrences2 &lt;- function(string, patterns) { count &lt;- 0 for (i in 1:str_length(string)) { for (j in 1:length(patterns)) { pattern &lt;- patterns[j] len &lt;- str_length(pattern) stringPart &lt;- str_sub(string, i, i + len - 1) if ( stringPart == pattern ) { count &lt;- count +1 } } } count } We try out our function on the string “This Labrador is a fool, Abba.”, which matches each of our patterns exactly once, for a total of three matches, occurrences2(&quot;This Labrador is a fool, Abba.&quot;, patterns = c(&quot;ab&quot;, &quot;Ab&quot;, &quot;foo&quot;)) ## [1] 3 Well, and good, but … the coding is beginning to get a bit complex. What if we were searching instead for, say, sub-strings that resemble a phone number with an area code, i.e., strings of the form: ddd-ddd-dddd (Here the d’s represent digits from 0 to 9.) There are \\(10^{10}\\) patterns of interest!29 How would we go about describing them all to R? Fortunately, regular expressions are there to help us out. A regular expression is defined as a sequence of characters that represents a pattern that might or might not be present in any given string. A computer will rely on a regular expression engine—a specific implementation of a system of regular expressions—to use a given regular expression to search in text for matches to the pattern that the expression represents. In practice, regular expressions are like a miniature programming language within a programming language. They are a feature of most major programming languages, including R. With regular expressions we can describe complex string-patterns concisely, and can perform rapid searches for these patterns in a given body of text. The rules for regular expressions vary a bit from one language to another, but the general idea is essentially the same for all of them. In the remainder of this Chapter we’ll learn enough of the principles of regular expressions to describe basic, useful patterns, and we’ll also study R-functions that make use of them. First of all, here’s a quick example to show the power of regular expressions. The work done by occurences2() may also be done in one line with the str_count() function, as follows: str_count(string = &quot;This Labrador is a fool, Abba.&quot;, pattern = &quot;[Aa]b|foo&quot;) ## [1] 3 Wow, that was quick. But what in the world is that &quot;[Aa]b|foo&quot; argument to the pattern parameter? It’s a regular expression! It tells R to look for sub-strings that EITHER: start with either “A” or “a”, and are then followed by a “b”, OR consist of “foo” Clearly it is high time that we learn a bit of regular-expression syntax. 10 digits in a phone number, each of which could be chose in 10 different ways. This results in \\(10^{10}\\), or ten billion possibilities.↩ "],
["regex-practice-sites.html", "12.2 Regex Practice Sites", " 12.2 Regex Practice Sites As we introduce regex syntax in the next few sections, it’s a good idea to try them out yourself and to come up with your own variations. The easiest way to do this is not to work directly in R at the outset; instead, consider using an online regex practice site. I especially recommend RegExr, which has a nice documentation interface. Set the regex flavor to PCRE, as this is the variant of regular expression syntax that is closest to the ICU regex variant used by the stringr package. If you go on to Web Programming course then you can switch to the JavaScript flavor. Bear in mind also that as we learn regex syntax, we’ll focus on the standard, language-independent syntax itself. There are some differences between this standard syntax and the way in which you would actually enter a regex pattern in R. "],
["regex-syntax.html", "12.3 Regex Syntax", " 12.3 Regex Syntax Let’s start learning the syntax. 12.3.1 Matching a Specific Sequence If you are searching for occurrences of one specific sequence of characters, the regular expression to use is just that sequence of characters. For example, if your regex is bet, then you’ll get a match whenever the characters “b”, “e”, and “t” occur consecutively in the text you are searching. In the sample text below, the matches are in italics: I bet you are reading between the lines. Better to read the lines themselves. We didn’t match “Bet” in “Better” because “B” is uppercase. The characters “b”, “e” and “t” in the regex “bet” are examples of literal characters. This means that they stand for exactly what they are: the “b” in the expression matches a “b” in the text we are searching, the “e” in the expression matches an “e” in text, and so on. There are a lot of exceptions to our specific-sequence rule. We’ll get to them soon. 12.3.2 Character Classes Suppose you want to match either “bet” or “Bet”? One way to do this is to use a character class. A character class consists of a set of characters surrounded by square brackets, and it tells the regex engine to match any one of the characters in the class. Consider, for example, the regex [Bb]et. It consists of the character class [Bb] followed by the pair of literal characters et. It matches: I bet you are reading between the lines. Better to read the lines themselves. Another example: t[aeiou] matches any two-character sequence in which “t” is followed by a lowercase vowel: Get thee to a nunnery. 12.3.2.1 Ranges You can match a range of characters. Inside a character class: a-z represents all lowercase letters from a to z; A-Z represents all of the uppercase letters; 0-9 represents all of the decimal digits: 0, 1, 2, …, 9. Other ranges are possible, e.g.: c-f denotes the lowercase letters from c to f; 0-3 denotes 0, 1, 2 and 3. Thus, in order to match any letter followed by two digits, you could use [a-zA-Z][0-9][0-9]: Your room number is B43, not C4 or #39. 12.3.2.2 The Need to Escape Perhaps now you can spot the problem with the sequence-specific rule: what happens if one of the characters in the sequence is, say ‘[’ or ’]’? These characters are examples of metacharacters, which means that in the syntax of regular expressions they don’t match themselves but instead have a special role. In the case of square-brackets, that role is to delimit character classes. If you want your pattern to include a metacharacter you will have to escape it with the backslash. Thus, the correct way to match the string “[aardvark]” would be with the regular expression: \\[aardvark\\]: The [aardvark] appears early in the dictionary. Actually, you only need to escape a metacharacter when it acts in its role as metacharacter. For example, if you want to match “b-b”, you are fine to use b-b. Because the expression contains no square brackets, it’s not possible for the hyphen to act in its special role to set ranges, so it does not have to be escaped. Inside of square brackets it can matter whether you escape the hyphen. Thus: [a-c] matches a, b, and c; [a\\-c] matches a, -, and c (but not b); [a-] matches a and - (the machine can tell that the hyphen was not being used in a range); [a\\-] also matches just a and -, not a, \\ and -. (Apparently the regex syntax takes into account the fact that some folks will worry that they might have to escape the hyphen). Of course since the backslash plays a role in escaping metacharacters, it too acts as a metacharacter at times. Hence if you want to match a backslash you’ll have to escape it! How? By preceding the black-slash with a backslash! Thus: a\\\\b matches “a\\b”; a\\\\\\\\b matches “a\\\\b”. On the other hand: a\\tb matches a followed by a tab followed by b, because in this case the machine recognizes \\t as the control character for a tab; a\\ab matches a followed by the bell-alert followed by b, and so on for other control characters. But keep the following in mind: a\\eb is incorrect regex syntax: \\e is not recognized as one of the control characters. And yet a\\wb is correct regex syntax! (It turns out that the token \\w is a recognized character class shortcut that means the same as [a-zA-Z0-9_] (all of the lowercase and uppercase letters, the digits, and the underscore character). We’ll get to the shortcuts soon. 12.3.2.3 Named Character Classes Some character classes occur so commonly that they have been granted special names. Table 12.1 gives a few that are worth remembering. Table 12.1: A few character classes worth remembering. Class Name Represents [:alpha:] a-zA-Z [:alnum:] a-zA-Z0-9 [:word:] a-zA-Z0-9_ (note the underscore) [:space:] white space [:lower:] a-z [:upper:] A-Z Here’s how you would use character class names in a regular expression: t[[:alnum:]]t matches t followed by any alphanumeric character followed by t. (The double brackets are needed since, according to the rules, t[:alnum:]t would match t followed by any one of :, a, l, n, u or m, followed by t.) 12.3.2.4 Character Class Shortcuts Some character classes are so very common that they merit extra-short shortcuts: most of these shortcuts begin with a backslash. We’ll call them character class shortcuts. Some of the most common character class shortcuts are shown in Table 12.2 Table 12.2: A few character class shortcuts worth remembering. Type Represents \\d any decimal digit (0-9) \\D anything not a decimal digit \\s any white space character \\S anything not a white space character \\w any word character (same as [word]) \\W anything not a word character . any character except newline The . requires special care: if you are searching for a literal dot, you’ll have to escape it with a backslash. Thus 32\\.456 matches “32.456”, whereas 32.456 matches “32a456”, 32b456&quot;, and so on. 12.3.2.5 Negation in a Character Class Suppose you would like to match any sequence of three characters of this form: t any character EXCEPT e, x and z t You can accomplish this by negating within a character class: the regex to use is t[^exz]t. Here the caret ^ functions as a metacharacter, indicating that any character except the others in the class are permitted. In order to function as a negation, the ^ must appear immediately after the opening bracket. If it appears elsewhere in the class, then it’s a literal: it just stands for itself. (Outside of a character class the ^ functions as an anchor—we’ll get to these soon—and as such has to be escaped if you want to act as a literal.) As another example, t[^a-z]t matches t followed by any character expect a lowercase letter, followed by t. Negating within a particular class of characters can be tricky. For example, suppose you are looking for 3-character sequences that consist of t, any letter except e or E, and then t. Rather than trying to use a ^ it’s easiest to work with ranges: t[a-df-zA-DF-Z]t. 12.3.3 Quantification Suppose you want to match phone numbers, where the area code is included and the groups of digits are separated by hyphens, as in: 202-456-1111. Taking advantage of the character class shortcut for digits, you could use the following regex: \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d But that’s a bit difficult to read. And besides, what if you weren’t working with phone numbers but instead wanted to match sequences like the following (which has 10 digits in succession)? A2356737821 It would be awful to write A\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d. This is where quantifiers come in. In regular expression syntax a token of the form {n} indicates that we are looking for n consecutive copies of whatever token precedes the {n}. Thus we can write the phone-number regex more concisely and more legibly as: \\d{3}-\\d{3}-\\d{4} Note that the curly braces { and } may now function as metacharacters, and as such may have to be escaped if you are looking for them specifically, Thus if you want to search for occurrences of “t{3}b”, you’ll need the regex t\\{3\\}b. On the other hand if you want to match “t{swim}b” then it’s fine to use the regex t{swim}b: the machine sees here that the braces don’t play a role in quantification. Quantifiers are quite flexible. Within a quantifier you can use a comma to indicate a range of permissible number of copies of the preceding expression: t{3,5} matches 3, 4 or 5 t’s in succession: ttt, tttt, or ttttt; t{3,} matches three or more t’s in succession: ttt, tttt, ttttt, … . Because quantification is so often required, regular expression syntax provides shortcuts for special cases: t* matches 0 or more t’s; t+ matches one or more t’s; t? matches 0 or 1 t. An example: to match the beginning of a URL, use https?://: The URL https://example.org provides authentication of the site, whereas you should not pay with a credit card on http://flybynight.com, On the other hand htto://example.org is not a valid URL—it’s probably a typo. Note that these shortcuts introduce new metacharacters: *, + and ?. You’ll probably need to escape them when you want to search for them as literals outside of a character class. 12.3.4 Greedy vs. Lazy When it comes to the open-ended quantifiers ({n,} or the shortcuts * and +), the default behavior is to make the longest match possible. This is known as greedy behavior. Consider the matches reported in the following text for b{3,} b bb bbb bbbb bbbbb It is possible, however, to tell a quantifier to be lazy, meaning that it should give the shortest possible matches. The way to do this is to append a ? to the quantifier. Applied to the same text above the regex b{3,}? with the lazy quantifier reports a different set of (sometimes shorter) matches: b bb bbb bbbb bbbbb 12.3.5 Grouping A quantifier refers to the shortest meaningful item immediately preceding it. Look at these examples: ab+ matches “a” followed by 1 or more “b”’s; a\\d+ matches “a” followed by 1 or more digits; a[^bc]+ matches “a” followed by 1 or more occurrence of anything other than “b” or “c”; In the examples above, any match begins with “a”. If we want to get “a” into the scope of the quantifier, we have to group it with the item immediately preceding the quantifier. Grouping is accomplished with parentheses. Consider these examples: (ab)+ matches one or more occurrences of “ab” in succession; (a\\d{2,})+ matches one or more occurrences of “a” followed by at least two digits. Thus it matches “a23” and “a23a773”. It won’t match “a2a3”. It will match only the “a23” in “a23a6” and it will match only the “a567” in “a4a567”. Grouping is a great help in constructing highly complex patterns. Bear in mind that the grouping symbols ( and ) function as metacharacters and will have to be escaped outside of character classes when you are searching for them as literals. Inside of character classes they function only as literals. Thus: [(ab)*] matches any one of the following characters: “(”, “a”, “b”, “)” and &quot;*&quot;. \\(yes\\) matches “(yes)”. 12.3.6 Alternation In regex syntax the symbol | (the vertical “pipe”) functions as a metacharacter meaning or. Thus: a|b matches “a” and it matches “b”; bed|bath matches “bed” and it matches “bath”; a|b|c matches any one of “a”, “b” and “c”; (aa|bb)+ matches one or more occurrence of “aa” or “bb”. Thus it matches “aa”, “bb”, “aaaa”, “aabb”, “bbaa”, “bbbb” and so on. (a(a|b)b)+ matches “aab”, “abb”, “aabaab”, “aababb”, and so on. Use of the pipe-symbol is known as alternation. In most implementations of regular expressions alternation works rather slowly, so use character classes instead whenever you can. For example, [a-e] is preferred over a|b|c|d|e. 12.3.7 Anchors Sometimes we are interested in patterns that occur in specific places in text, such as: at the beginning of a string; at the end of a string at the beginning or end of a word. Anchors help us accomplish this. The most important anchors to remember are: ^, which indicates (in technical terms, asserts) the beginning of a string; $, which asserts the end of a string;30 \\b, which asserts the presence of any type word-boundary (a space, tab, comma, semicolon, etc.). Here are some examples: For ^Hello: Hello got matched, but not the next Hello. For Hello$: Hello did not get matched, but there is a match for the next Hello One thing that’s important to keep in mind about anchors is that they are assertions. This means that they don’t actually count for characters in a match; they merely assert the presence of something: the beginning or end of a string, the boundary of a a word, etc. Thus, there are six tokens in the regular expression ^Hello, but only five characters—the letters in “Hello”—are involved in a match. The^ merely asserts that a match must not only involve the given characters but must also occur at the beginning the string. What does ^Hello$ match? The rules would say that the string must start with H, continue on with e, l, l and then o, and end there, so you might think that the only possible string containing a match of ^Hello$ is the string “Hello” itself. But that’s not quite right: Go your online regex practice site (Regular Expression 101). Enter the regex hello$. Then in the “Flags” dropdown menu, check “multiline”. You should now see “/gm” at the end of the regular expression. You have entered multiline mode. In the test-text field, enter “I say hello”, press Return, and continue on the next line with “Again I say hello”. You’ll see that both hello’s match. The reason for this is that in multiline mode $ stands for the end of each line, not just the absolute end of the string. From time to time you may deal with strings that run over multiple lines, so remember that if you want your ending anchors to represent end-of-line rather than the absolute end of the string, you’ll need to ask R to enter multiline mode. (Later on in the Chapter we’ll discuss some common modes and how to enter them in R.) The word-boundary anchor \\b is quite useful. Consider the regex bed applied to the string below: bed bedtime perturbed There are three matches! With the regex \\bbed there are just two matches: bed bedtime perturbed With the regex \\bbed\\b the only match is with the actual word “bed”: bed bedtime perturbed Note that the beginning and the end of a string count as word-boundaries! 12.3.8 Captures How would you detect whether a particular instance of a pattern is repeated? For instance, suppose you are looking for occurrences of a word repeated immediately after itself with only a space in between, for example: “bye bye birdie” “she said night night” The regex \\b\\w+\\b (word boundary followed by one or more word characters followed by a word boundary) will match words like “bye” and “night”, but if you simply repeated the pattern, say: \\b\\w+\\b \\b\\w+\\b, then you match strings that don’t exhibit repetition, such as “bye hello” and day night&quot;. What you want is for the first part of the regex to state your pattern—a word of one or more characters—then the space, and then something that represents exactly the match that occurs for the first pattern. A capture accomplishes this. The regex you want is: \\b(\\w+) \\1\\b See what it matches in the phrase below: now it is time for bed bed, yes it is bed bedtime Here’s how the regex works: The leading \\b requires the presence of a word-boundary, which is satisfied by the presence, in the string, of the space between “for” and “bed bed”. The second “bed bed” is also OK at this point, due to the space between “is” and the first “bed”. \\w+ matches the first “bed”, and the parentheses make it a group. By default the regex captures the contents of whatever portion of the string matches a group, and remembers those contents for later use. The matches the space between the two “bed” strings. The \\1 is a back-reference: it represents precisely what was matched in the earlier group. For the regex as a whole to produce a match, \\1 has to see an exact repetition of whatever string matched the first parenthesis-group in the regex, so it has to see “bed”. At this point both occurrences of “bed bed”&quot; are still in the running to be matches for the entire regex. The final \\b asserts a word-boundary. This is satisfied by the comma after the first “bed bed”, but not by the “t” after the second “bed bed”. Thus only the first “bed bed” matches the regular expression as a whole. Back-references are denoted \\1, \\2, and so on, and you can use several of them in the same regex. For example, if you want to match expressions such as “big boat big boat” then use: \\b(\\w+) (\\w+) \\1 \\2\\b Think about how the above regex works: To start, it requires the presence of a word-boundary. It sets up a capture-group consisting of one or more word characters. Since this is the first set of parentheses, the group can be referenced later on by \\1. It then sets up a second capture-group that may be referenced later on by \\2. We then must see a space … … followed by the contents of the first group … … followed by the contents of the second group … … at a word-boundary. If you want to match a palindrome31 consisting of five characters (“abcba”, “x444x”, etc.) then use: \\b(\\w)(\\w)\\w\\2\\1\\b 12.3.9 Looking Around Suppose that you have a string containing a number of words involving “bed”, and you would like to find all occurrences of “bed” that begin a word, except for the word “bedtime”. With the tools we have so far this is a difficult task. Fortunately there are look-aheads to simplify our work. The regex \\bbed(?!time\\b) will do the job. Here’s how it works: It begins by asserting a word-boundary. It continues with the characters to match “bed”. It concludes a look-ahead group. The parentheses mark out the group. The initial ? indicates that we plan to look ahead. The ! may be thought of as “not equals”; it means that if we find the pattern that follows the ! we will not have a match. Note the matches in the text below: bedtime bedrock bedrocking bedsheets bedding embedding Note that only “bed” is included in the match. Just like the anchor \\b, the look-ahead is an assertion: it does not add any characters to the match. If we want only the occurrences of “bed” where the word begins in “bed” and ends in either “rock” and “time”, then we could use the regex: \\bbed(?=rock\\b|time\\b) Note the matches in the following text: bedtime bedrock bedrocking bedsheets bedding embedding Of course we could locate the same occurrences with \\bbed(rock|time)\\b, but the matches would be the entire words, not just the “bed” portion. There are four types of look-around groups: Positive look-ahead: regex1(?=regex2). Match when you find an instance of regex2 right after an instance of regex1. Negative look-ahead: regex1(?!regex). Match EXCEPT when you find an instance of regex2 right after an instance of regex1. Positive look-behind: (?&lt;=regex2)regex1. Match when you find an instance of regex2 right before an instance of regex1. Negative look-behind: (?&lt;!regex2)regex1. Match EXCEPT when you find an instance of regex2 right before an instance of regex1. The regex2 expression in look-aheads can be any regex at all. For look-behinds, though, there are some important limitations. The precise restrictions differ from one flavor of regular expressions to another, but roughly the rule is that the machine has to be able to figure out in advance how many characters it might have to look behind. A group like (?&lt;=time\\w*sheets), for instance, would not be permitted, as the quantifier * allows matching strings of arbitrary length. 12.3.10 More to Learn We have not come near to exhausting the syntax of regular expressions. Readers who would like to delve into the subject more deeply should next consult online tutorials on the topics of non-capture groups, conditionals and more. It would also be good to look at the brief overview of the ICU regex engine provided in stringi-search-regex in the documentation for the stringi package on which stringr is based. However, we now have enough background to express some fairly complex patterns quite concisely, so it is now time to learn how to work with them in R. Well, actually it asserts the end of the string when we are not in “multiline mode.” In multiline mode it asserts the end of a line within a multiline string. This will be explained shortly.↩ Recall that a palindrome is a word that is the same when spelled backwards.↩ "],
["entering-a-regex-in-r.html", "12.4 Entering a Regex in R", " 12.4 Entering a Regex in R We now return to the R-language and consider how to apply regular expressions within it. 12.4.1 String to Regex Regular expressions actually play a role in one of the functions you already know, namely the function strsplit(). Recall that you can use the split parameter to specify the sub-string that separates the strings you want to split up. It works like this: &quot;hello there Mary Poppins&quot; %&gt;% str_split(pattern = &quot; &quot;) %&gt;% unlist() ## [1] &quot;hello&quot; &quot;there&quot; &quot;Mary&quot; &quot;Poppins&quot; The task of splitting would appear to a quite challenging if the words are separated in more complex ways, with any amount of white-space. Consider, for example: myString &lt;- &quot;hello\\t\\tthere\\n\\nMary \\t Poppins&quot; cat(myString) ## hello there ## ## Mary Poppins But really it’s not any more difficult, because the split parameter actually takes the string it is given and converts it to a regular expression, splitting on anything that matches. Watch this: myString %&gt;% str_split(pattern = &quot;\\\\s+&quot;) %&gt;% unlist() ## [1] &quot;hello&quot; &quot;there&quot; &quot;Mary&quot; &quot;Poppins&quot; We can almost see how this works. Recall from the last section that the regex \\s is a character class shortcut for any white-space character, so \\s+ stands for one or more white-spaces in succession: precisely the mixtures of tab, spaces and newlines that separated the words in our string. str_split() must be splitting on matches to the regex \\s+. So why did we set pattern = &quot;\\\\s+&quot;? What’s with the extra backslash? The reason is that the argument passed with pattern is a string, not a regular expression object. It starts out life, as if were, as a string, and R converts it to a regular expression, then hands the regex over to its regular expression engine to locate the matches in myString that in turn determine how myString is to be split up. Since in R’s string-world “\\s” is not a recognized character in the way that newline (“\\n”), tab (“\\t”) and other control-characters are, R won’t accept “\\s+” as a valid string. Try it for your self: myString %&gt;% str_split(pattern = &quot;\\s+&quot;) ## Error: &#39;\\s&#39; is an unrecognized escape in character string starting &quot;&quot;\\s&quot; It follows that when you enter regular expressions as strings in R, you’ll have to remember to escape the back-slashed tokens that are used in a regular expression. Table 12.3 gives several examples of this. Table 12.3: Examples of entry of regular expressions as strings, in R. Regular Expression Entered as String \\s+ “\\\\s+” find\\.dot “find\\\\.dot” ^\\w*\\d{1,3}$ &quot;^\\\\w*\\\\d{1,3}$&quot; Keeping in mind the need for an occasional additional escape, it should not be too difficult for you to enter regular expressions in R. 12.4.2 Substitution One of the most useful applications of regular expressions is in substitution. Suppose that we have a vector of dates: dates &lt;- c(&quot;3 - 14 - 1963&quot;, &quot;4/13/ 2005&quot;, &quot;12-1-1997&quot;, &quot;11 / 11 / 1918&quot;) It seems that the folks who entered the dates were not consistent in how to format them. In order to make analysis easier, it would be better if all the dates had exactly the same format. With the function str_replace_all() and regular expressions, this is not difficult: dates %&gt;% str_replace_all(pattern = &quot;[- /]+&quot;, replacement = &quot;/&quot;) ## [1] &quot;3/14/1963&quot; &quot;4/13/2005&quot; &quot;12/1/1997&quot; &quot;11/11/1918&quot; Here: x (not explicitly seen above, due to the piping) is the text in which the substitution occurs; pattern is the regex for the type of sub-string we want to replace; replacment is what we want to replace matches of the pattern with. The all in the name of the function means that we want to replace all occurrences of the pattern with the replacement text. There is also a str_replace() function that performs replacement only with the first match (if any) that it finds: dates %&gt;% str_replace(pattern = &quot;[- /]+&quot;, replacement = &quot;/&quot;) ## [1] &quot;3/14 - 1963&quot; &quot;4/13/ 2005&quot; &quot;12/1-1997&quot; &quot;11/11 / 1918&quot; In our application, that’s certainly NOT what we need. However, in cases where you happen to know that there will be at most one match, str_replace() gets the job done faster than str_replace_all(), which is forced to search through the entire string. 12.4.3 Patterned Replacement In the dates example from Section 12.4.2 the replacement string (the argument for the parameter replacement) was constant: no matter what sort of match we found for the pattern [- /]+, we replaced it with the string “/”. It is important to note, however, that the argument provided for replacement can cause the replacement to vary depending upon the match found. In particular: It can include the back-references \\1, \\2, …, \\9. It can be a defined function of the match. Let’s look at an example. Here is a function that, given a string, will double all of the vowels that it finds: doubleVowels &lt;- function(str) { str %&gt;% str_replace_all(pattern = &quot;([aeiou])&quot;, replacement = &quot;\\\\1\\\\1&quot;) } doubleVowels(&quot;Far and away the best!&quot;) ## [1] &quot;Faar aand aawaay thee beest!&quot; Note that the pattern [aeiou] for vowels had to be enclosed in parentheses so that it could be captured and referred to by the back-reference \\1. Also note that, since R converts the replacement string into a pattern, extra backslash escapes are required, just as in regular expressions. Here is a function to capitalize every vowel found: capVowels &lt;- function(str) { str %&gt;% str_replace_all(pattern = &quot;[aeiou]&quot;, replacement = function(x) str_to_upper(x)) } capVowels(&quot;Far and away the best!&quot;) ## [1] &quot;FAr And AwAy thE bEst!&quot; Here is another function that searches for repeated words and encloses each pair in asterisks: starRepeats &lt;- function(str) { str %&gt;% str_replace_all(pattern = &quot;\\\\b(\\\\w+) \\\\1\\\\b&quot;, replacement = function(x) { str_c(&quot;*&quot;, x, &quot;*&quot;) } ) } starRepeats(&quot;I have a boo boo on my knee knee.&quot;) ## [1] &quot;I have a *boo boo* on my *knee knee*.&quot; 12.4.4 Detecting Matches If you have many strings—in a character-vector, say—and you want to select those that contain a match to a particular pattern, then you want to use str_subset(). Consider, for example, the vector of strings: sentences &lt;- c(&quot;My name is Tom, Sir&quot;, &quot;And I&#39;m Tulip!&quot;, &quot;Whereas my name is Lester.&quot;) If we would like to find the strings that contain a word beginning with capital T, we could proceed as follows: sentences %&gt;% str_subset(pattern = &quot;\\\\bT\\\\w*\\\\b&quot;) ## [1] &quot;My name is Tom, Sir&quot; &quot;And I&#39;m Tulip!&quot; str_subset() returns a vector consisting of the elements of the vector sentences where the string contains at least one word beginning with “T”. A related function is str_detect(): sentences %&gt;% str_detect(pattern = &quot;\\\\bT\\\\w*\\\\b&quot;) ## [1] TRUE TRUE FALSE str_detect() returns a logical vector with TRUE where sentences has a capital-T word, FALSE otherwise. Finally, str_locate() gives the positions in each string where a match begins: sentences %&gt;% str_locate(pattern = &quot;\\\\bT\\\\w*\\\\b&quot;) ## start end ## [1,] 12 14 ## [2,] 9 13 ## [3,] NA NA 12.4.5 Extracting Matches If you require what is actually matched within each string you are processing, then you should look into str_extract() and str_extract_all(). As an example, let’s extract pairs of words beginning with the same letter in sentences2 defined below: sentences2 &lt;- c(&quot;The big bad wolf is walking warily to the cottage.&quot;, &quot;He huffs and he puffs peevishly.&quot;, &quot;He wears gnarly gargantuan bell bottoms!&quot;) sentences2 %&gt;% str_extract(pattern = &quot;\\\\b(\\\\w)\\\\w*\\\\W+\\\\1\\\\w*&quot;) ## [1] &quot;big bad&quot; &quot;puffs peevishly&quot; &quot;gnarly gargantuan&quot; The results are returned as a character vector, in which each element is the first matching pair in the corresponding sentence. If we want all of the matches in each sentence, then we use str_extract_all(): sentences2 %&gt;% str_extract_all(pattern = &quot;\\\\b(\\\\w)\\\\w*\\\\W+\\\\1\\\\w*&quot;) ## [[1]] ## [1] &quot;big bad&quot; &quot;walking warily&quot; &quot;to the&quot; ## ## [[2]] ## [1] &quot;puffs peevishly&quot; ## ## [[3]] ## [1] &quot;gnarly gargantuan&quot; &quot;bell bottoms&quot; Sometimes we want even more information. Suppose, for example, that we want not only the first matching word-pair, but also the repeated initial letter that permitted the match in the first place. In that case we need str_match(): sentences2 %&gt;% str_match(pattern = &quot;\\\\b(\\\\w)\\\\w*\\\\W+\\\\1\\\\w*&quot;) ## [,1] [,2] ## [1,] &quot;big bad&quot; &quot;b&quot; ## [2,] &quot;puffs peevishly&quot; &quot;p&quot; ## [3,] &quot;gnarly gargantuan&quot; &quot;g&quot; str_match() returns a matrix, each row of which corresponds to an element of sentences. The first column gives the value of the entire match, and the second column gives value of the capture-group in the regular expression. If the regular expression had used more capture groups, then the matrix would have had additional columns showing the values of the captures, in order. If you want an analysis of all the matches in a string, then use str_match_all(): sentences2 %&gt;% str_match_all(pattern = &quot;\\\\b(\\\\w)\\\\w*\\\\W+\\\\1\\\\w*&quot;) ## [[1]] ## [,1] [,2] ## [1,] &quot;big bad&quot; &quot;b&quot; ## [2,] &quot;walking warily&quot; &quot;w&quot; ## [3,] &quot;to the&quot; &quot;t&quot; ## ## [[2]] ## [,1] [,2] ## [1,] &quot;puffs peevishly&quot; &quot;p&quot; ## ## [[3]] ## [,1] [,2] ## [1,] &quot;gnarly gargantuan&quot; &quot;g&quot; ## [2,] &quot;bell bottoms&quot; &quot;b&quot; The returned structure is a list and hence more complex, but you can query it for the values you need. 12.4.6 Extraction in Data Frames Quite often you will want to manipulate strings in the context of working with a data frame. For this regex functions we have examined so far will be quite useful, but you should also know about the extract() function from the tidyr package, which is among the packages attached by the tidy-verse. Imagine a data table that contains some names and phone numbers: people &lt;- data.frame( name = c(&quot;Lauf, Bettina&quot;, &quot;Bachchan, Abhishek&quot;, &quot;Jones, Jenna&quot;), phone = c(&quot;(202) 415-3785&quot;, &quot;4133372100&quot;, &quot;310-231-4453&quot;) ) Each person has a standard ten-digit phone number, consisting of: the three-digit area code; the three digit central office number; the four-digit line number. Suppose we would like to create three new variables in the data table, one for each of the three components of the phone number. For this, tidyr::extract() comes in handy: people %&gt;% tidyr::extract(col = phone, into = c(&quot;area&quot;, &quot;office&quot;, &quot;line&quot;), regex = &quot;(?x) # for comments .* # in case of opening paren, etc. (\\\\d{3}) # capture 1: area code .* # possible separators (\\\\d{3}) # capture 2: central office .* # possible separators (\\\\d{4}) # capture 3: line number &quot;) ## name area office line ## 1 Lauf, Bettina 202 415 3785 ## 2 Bachchan, Abhishek 413 337 2100 ## 3 Jones, Jenna 310 231 4453 By default extract() removes the original column, but you can preserve it with remove = FALSE. (For the format of the regular expression in the above call, see the next sub-section.) 12.4.7 Counting Matches The function str_count() provides a very convenient way to tally up the number of matches that a given regex has in a string. Here we use it to count the number of words in a string that begin with a lower or uppercase p. strings &lt;- c(&quot;Mary Poppins is practically perfect in every way!&quot;, &quot;The best-laid plans of mice and men gang oft astray.&quot;, &quot;Peter Piper picked a peck of pickled peppers.&quot;) strings %&gt;% str_count(pattern = &quot;\\\\b[Pp]\\\\w*\\\\b&quot;) ## [1] 3 1 6 How might we find the words in a string that contain three or more of the same letter? In this case str_count() would not be useful. However we could try something like this: &quot;In Patagonia, the peerless Peter Piper picked a peck of pickled peppers.&quot; %&gt;% str_split(&quot;\\\\W+&quot;) %&gt;% unlist() %&gt;% str_subset(pattern = &quot;([[:alpha:]]).*\\\\1.*\\\\1&quot;) ## [1] &quot;Patagonia&quot; &quot;peerless&quot; &quot;peppers&quot; 12.4.8 Regex Modes If you have been practicing consistently with an online regex site, you will have noticed by now that a regex can be accompanied by various options. In most implementations they appear as letters after the closing regex delimiter, like this: /regex/gm Some of the most popular options are: g: “global”, looking for all possible matches in the string; i: “case-insensitive” mode, so that letter-characters in the regex match both their upper and lower-case versions; m: “multiline” mode, so that the anchors ^ and $ are attached to newlines within the string rather than to the absolute beginning and end of the string; x: “white-space” mode, where white-spaces in the regex are ignored unless they are escaped (useful for lining out the regex and inserting comments to explain its operation). Since stringr has both global and non-global versions of regex functions you probably will not bother with g, but the other options—known technically as modes—can sometimes be useful. If you would like to set modes to apply to your entire regex, insert it (or them) like this at the beginning of the expression: (?im)t[aeiou]{1,3}$ In the example above, we are in both case-insensitive and multiline mode, and we are looking for t or T followed by 1, 2 or 3 vowels (upper or lower) at the end of any line in a (possibly) multiline string. Following is an example of the mode to ignore white-space and to ignore case: myPattern &lt;- &quot;(?xi) # ignore whitespace (x) and ignore case (i) \\\\b # assert a word-boundary (\\\\w) # capture the first letter of the first word \\\\w* # rest of the first word \\\\W+ # one or more non-word characters \\\\1 # repeat the letter captured previously \\\\w* # rest of the second word &quot; sentences2 %&gt;% str_match_all(pattern = myPattern) ## [[1]] ## [,1] [,2] ## [1,] &quot;big bad&quot; &quot;b&quot; ## [2,] &quot;walking warily&quot; &quot;w&quot; ## [3,] &quot;to the&quot; &quot;t&quot; ## ## [[2]] ## [,1] [,2] ## [1,] &quot;He huffs&quot; &quot;H&quot; ## [2,] &quot;puffs peevishly&quot; &quot;p&quot; ## ## [[3]] ## [,1] [,2] ## [1,] &quot;gnarly gargantuan&quot; &quot;g&quot; ## [2,] &quot;bell bottoms&quot; &quot;b&quot; Due to the presence of x-flag at the very beginning of the regex, the regex engine knows to ignore white-space throughout, and it will also ignore hash-tags and whatever comes after them on a line. This permits the placement of comments within the regular expression. The i-flag directs the regex engine to ignore case when looking for matches. Accordingly, in the example we pick up the extra match “he huffs”. Some people prefer to control regular-expression modes by means of stringr’s regex() function: myPattern &lt;- regex( pattern = &quot; \\\\b # assert a word-boundary (\\\\w) # capture the first letter of the first word \\\\w* # rest of the first word \\\\W+ # one or more non-word characters \\\\1 # repeat the letter captured previously \\\\w* # rest of the second word &quot;, comments = TRUE, ignore_case = TRUE ) sentences2 %&gt;% str_match_all(pattern = myPattern) ## [[1]] ## [,1] [,2] ## [1,] &quot;big bad&quot; &quot;b&quot; ## [2,] &quot;walking warily&quot; &quot;w&quot; ## [3,] &quot;to the&quot; &quot;t&quot; ## ## [[2]] ## [,1] [,2] ## [1,] &quot;He huffs&quot; &quot;H&quot; ## [2,] &quot;puffs peevishly&quot; &quot;p&quot; ## ## [[3]] ## [,1] [,2] ## [1,] &quot;gnarly gargantuan&quot; &quot;g&quot; ## [2,] &quot;bell bottoms&quot; &quot;b&quot; 12.4.9 Practice Exercises The stringr package comes with fruit, a character-vector of giving the names of 80 fruits. Determine how many fruit-names consist of exactly two words. Find the two-word fruit-names. Find the indices of the two-word fruit names. Find the one-word fruit-names that end in “berry”. Find the fruit-names that contain more than three vowels. In the word “banana” the string “an” appears twice in succession, as does the string “na”. Find the fruit-names containing at least one string of length two or more that appears twice in succession. To the people data frame from this section, add two new variables: first for the first name and last for the last name. The original name variable should be removed. 12.4.10 Solutions to the Practice Exercises Try this: wordCount &lt;- fruit %&gt;% str_count(&quot;\\\\w+&quot;) sum(wordCount == 2) ## [1] 11 Try this: fruit %&gt;% .[str_count(., &quot;\\\\w+&quot;) == 2] ## [1] &quot;bell pepper&quot; &quot;blood orange&quot; &quot;canary melon&quot; &quot;chili pepper&quot; ## [5] &quot;goji berry&quot; &quot;kiwi fruit&quot; &quot;purple mangosteen&quot; &quot;rock melon&quot; ## [9] &quot;salal berry&quot; &quot;star fruit&quot; &quot;ugli fruit&quot; Another way is as follows: fruit %&gt;% str_subset(&quot;^\\\\w+\\\\s+\\\\w+$&quot;) ## [1] &quot;bell pepper&quot; &quot;blood orange&quot; &quot;canary melon&quot; &quot;chili pepper&quot; ## [5] &quot;goji berry&quot; &quot;kiwi fruit&quot; &quot;purple mangosteen&quot; &quot;rock melon&quot; ## [9] &quot;salal berry&quot; &quot;star fruit&quot; &quot;ugli fruit&quot; Try this: fruit %&gt;% str_detect(&quot;^\\\\w+\\\\s+\\\\w+$&quot;) %&gt;% which() ## [1] 5 9 13 17 32 42 66 72 73 75 79 Try this: fruit %&gt;% str_subset(&quot;\\\\w+berry$&quot;) ## [1] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blueberry&quot; &quot;boysenberry&quot; &quot;cloudberry&quot; &quot;cranberry&quot; ## [7] &quot;elderberry&quot; &quot;gooseberry&quot; &quot;huckleberry&quot; &quot;mulberry&quot; &quot;raspberry&quot; &quot;strawberry&quot; Try this: vowelCount &lt;- fruit %&gt;% str_count(&quot;[aeiou]&quot;) fruit[vowelCount &gt; 3] ## [1] &quot;avocado&quot; &quot;blood orange&quot; &quot;breadfruit&quot; &quot;canary melon&quot; ## [5] &quot;cantaloupe&quot; &quot;cherimoya&quot; &quot;chili pepper&quot; &quot;clementine&quot; ## [9] &quot;dragonfruit&quot; &quot;feijoa&quot; &quot;gooseberry&quot; &quot;grapefruit&quot; ## [13] &quot;kiwi fruit&quot; &quot;mandarine&quot; &quot;nectarine&quot; &quot;passionfruit&quot; ## [17] &quot;pineapple&quot; &quot;pomegranate&quot; &quot;purple mangosteen&quot; &quot;tamarillo&quot; ## [21] &quot;tangerine&quot; &quot;ugli fruit&quot; &quot;watermelon&quot; Try this: fruit %&gt;% str_subset(&quot;(\\\\w{2,})\\\\1&quot;) ## [1] &quot;banana&quot; &quot;coconut&quot; &quot;cucumber&quot; &quot;jujube&quot; &quot;papaya&quot; &quot;salal berry&quot; Try this: people %&gt;% tidyr::extract(col = name, into = c(&quot;last&quot;, &quot;first&quot;), regex = &quot;(\\\\w+)\\\\W+(\\\\w+)&quot;) ## last first phone ## 1 Lauf Bettina (202) 415-3785 ## 2 Bachchan Abhishek 4133372100 ## 3 Jones Jenna 310-231-4453 "],
["application-amazon-book-reviews.html", "12.5 Application: Amazon Book Reviews", " 12.5 Application: Amazon Book Reviews The R-package tigerData (White 2018) contains the data set reviews, a collection of user-reviews on Amazon for seven bestsellers. Learn more about the data set as follows: library(tigerData) help(reviews) Each row of the data frame contains: the 1-5 rating that the reviewer assigned to the book a URL fragment that locates the review online; the summary-title of the review; the content of the review itself. Let’s focus on reviews for Hunger Games series. The following code creates a new data frame that contains only those reviews: hunger &lt;- subset(reviews, book == &quot;hunger&quot;) That’s still a lot of reviews! We can tell by asking for the number of rows in the hunger data frame: nrow(hunger) ## [1] 24027 We are looking at 24,027 reviews—some of which, by the way, are quite long. Explore the plain-text of some of the reviews. For example, the text of the second review can be viewed with: hunger$content[2] ## # A single long string. We will show just the first few characters: ## [1] &quot;\\&quot;&lt;span class=\\&quot;\\&quot;a-size-base review-text\\&quot;\\&quot;&gt;Clearly ... Perusing this review, we come upon the following passage: There is a certain strain of book that can hypnotize you into believing that you are in another time and place roughly 2.3 seconds after you put that book down. &lt;a class=\\“\\”a-link-normal\\“\\” href=&quot;&quot;/Life-As-We-Knew-It/dp/0152061541\\“\\”&gt;Life As We Knew It by Susan Beth Pfeffer could convince me that there were simply not enough canned goods in my home. The author has linked to another book sold on Amazon, Susan Beth Pfeffer’s Life As We Knew It. The Amazon.com URL for the book is found by prepending the company’s domain to the URL-fragment seen in the excerpt above, resulting in the link: http://www.amazon.com/Life-As-We-Knew-It/dp/0152061541 We might be curious to know what other books on Amazon our reviewers link to when they are discussing the Hunger Games. Regular expressions can help us to extract the links from the mass of text in hunger$content. All of the Amazon links are generated for the user by the computer, so they will all have the same format. Hence we can use a look-behind and a look-ahead to construct a regex that will be matched by any URL-fragment within such an anchor: (?&lt;=&lt;a class=\\\\&quot;\\\\&quot;a-link-normal\\\\&quot;\\\\&quot; href=\\\\&quot;\\\\&quot;)(.+?)(?=\\\\&quot;\\\\&quot;&gt;) Checking carefully, we see that none of the tokens require extra escaping: we can use this text as our pattern in regex function in R: linkPattern &lt;- &#39;(?&lt;=&lt;a class=\\\\&quot;\\\\&quot;a-link-normal\\\\&quot;\\\\&quot; href=\\\\&quot;\\\\&quot;)(.+?)(?=\\\\&quot;\\\\&quot;&gt;)&#39; First we create a new variable in hunger that counts the number of links in a review: hungerLinks &lt;- hunger %&gt;% mutate(linkCount = str_count(content, linkPattern)) Now we can tally the number of links: hungerLinks %&gt;% group_by(linkCount) %&gt;% summarise(n = n()) ## # A tibble: 10 x 2 ## linkCount n ## &lt;int&gt; &lt;int&gt; ## 1 0 23854 ## 2 1 110 ## 3 2 34 ## 4 3 15 ## 5 4 7 ## 6 5 3 ## 7 6 1 ## 8 7 1 ## 9 8 1 ## 10 9 1 If you are generating a report with R Markdown, then a better-looking table (see Table 12.4 can be produced as follows: hungerLinks %&gt;% group_by(linkCount) %&gt;% summarise(n = n()) %&gt;% knitr::kable(caption=str_c(&quot;Table showing number of links &quot;, &quot;made by reviewers of the Hunger &quot;, &quot;Games series.&quot;)) Table 12.4: Table showing number of links made by reviewers of the Hunger Games series. linkCount n 0 23854 1 110 2 34 3 15 4 7 5 3 6 1 7 1 8 1 9 1 Most of the reviewers didn’t link at all, but 173 of them did provide at least one link. One reviewer linked to nine books! Let’s find them and add the base URL http://www.amazon.com/: hungerLinks %&gt;% filter(linkCount == max(linkCount)) %&gt;% # get the case having most links .$content %&gt;% # get just the content of the review, # a character vector (of length 1 since there # is only one review with the max number of lengths) str_extract_all(pattern = linkPattern) %&gt;% # get the matches, # but this is a list of # length 1 ... unlist() %&gt;% # ... so unlist it into a character vector str_c(&quot;http://www.amazon.com/&quot;, .) # prepend the base URL to each link ## [1] &quot;http://www.amazon.com//Harry-Potter-Paperback-Box-Set-Books-1-7/dp/0545162076&quot; ## [2] &quot;http://www.amazon.com//The-Dark-Tower-Boxed-Set-Books-1-4/dp/0451211243&quot; ## [3] &quot;http://www.amazon.com//The-Long-Walk/dp/0451196716&quot; ## [4] &quot;http://www.amazon.com//Battle-Royale-The-Novel/dp/1421527723&quot; ## [5] &quot;http://www.amazon.com//Battle-Royale-The-Complete-Collection-Blu-ray/dp/B006L4MX4A&quot; ## [6] &quot;http://www.amazon.com//The-Dark-Tower-Boxed-Set-Books-1-4/dp/0451211243&quot; ## [7] &quot;http://www.amazon.com//Harry-Potter-Paperback-Box-Set-Books-1-7/dp/0545162076&quot; ## [8] &quot;http://www.amazon.com//Abarat/dp/0062094106&quot; ## [9] &quot;http://www.amazon.com//lord-of-the-flies/dp/B0073SQWWC&quot; As we learn more about R’s data-analysis functions we’ll be able to explore a wide variety of interesting questions about the attitudes and practices of Amazon reviewers. This will involve plowing through a lot more text, but now that we know regular expressions we are sure to “save the day”! 12.5.1 Practice Exercises Use reviews to generate a table of the the number of Amazon links in reviews of John Greene’s book The Fault in our Stars. How many times did a reviewer link to Looking for Alaska (another well-known book by John Greene)? From reviews, make a data frame called shades that contains the reviews of Fifty Shades of Gray. This bestseller received an unusually high proportion of low ratings. Think of a few choice words that might show up in a negative review and create a logical variable called dislikes that is TRUE when one or more of these words appears in the review, and is FALSE otherwise. Convert the numerical variable rating to a factor variable. Make a bar graph that shows the relation between dislikes and rating. 12.5.2 Solutions to the Practice Exercises Try this: linkPattern &lt;- &quot;(?&lt;=&lt;a class=\\&quot;\\&quot;a-link-normal\\&quot;\\&quot; href=\\&quot;\\&quot;/)(.+?)(?=\\&quot;\\&quot;&gt;)&quot; fault &lt;- reviews %&gt;% filter(book == &quot;fault&quot;) fault %&gt;% mutate(linkCount = str_count(content, linkPattern)) %&gt;% group_by(linkCount) %&gt;% summarise(n = n()) ## # A tibble: 6 x 2 ## linkCount n ## &lt;int&gt; &lt;int&gt; ## 1 0 35827 ## 2 1 10 ## 3 2 3 ## 4 3 2 ## 5 6 1 ## 6 7 1 Try this: fault %&gt;% .$content %&gt;% str_extract_all(pattern = linkPattern) %&gt;% unlist() %&gt;% str_detect(&quot;(?i)Looking-For-Alaska&quot;) %&gt;% sum() ## [1] 5 Here is one possibility: reviews %&gt;% filter(book == &quot;shades&quot;) %&gt;% mutate(dislikes = str_detect(content, &quot;bad|awful|terrible|waste&quot;)) %&gt;% mutate(rating = factor(rating)) %&gt;% ggplot(aes(x = rating)) + geom_bar(aes(fill = dislikes), position = &quot;dodge&quot;) References "],
["glossary-9.html", "Glossary", " Glossary Regular Expression A sequence of characters that represents a pattern. Regular Expression Engine A specific implementation of regular expressions used by a specific programming language. Literal Character A character in a regular expression that matches itself. Character Class A set of characters enclosed in brackets. It matches any one of the characters in the set. Metacharacter (also called “Special Character”) A character in a regular expression that does not match itself, but instead has a special role in specifying the overall pattern. "],
["exercises-8.html", "Exercises", " Exercises Write a function called findMister() that, when given any string, will return a character vector of the words that immediately follow the string “Mister”, with exactly one space in between. The function should take a single argument called str, the string to search. A typical example of use is as follows: text &lt;- &quot;Here are Mister Tom, MisterJerry, Mister Mister, and Mister\\tJoe.&quot; findMister(text) ## [1] &quot;Tom&quot; &quot;Mister&quot; Write a function called findMr() that, when given any string, will return a character vector of all words following the string “Mr.”, with exactly one space in between. The function should take a single argument called str, the string to search. A typical example of use is as follows: text &lt;- &quot;Here are Mr. Tom, Mr Jerry, Mr. Mister, and Mr.\\tJoe.&quot; findMr(text) ## [1] &quot;Tom&quot; &quot;Mister&quot; For each of the following expressions, write a regular expression to test whether any of the sub-string(s) described occur in a given string. The regular expression should match any of the sub-strings described, and should not match any other sub-string. Try to make the regular expression as short as possible. Write the regular expression as a string that could be used in one of R’s regex functions (i.e. extra backslash escapes as needed). The first item is done for you, as an example. bot and bat. Regex string: &quot;b[oa]t&quot;. (This is the one to submit, because it’s shorter than other alternatives such as&quot;box|bat&quot;). cart and cars and carp. slick and sick Any word ending in ity (such as velocity and ferocity). Be sure to pay attention to word-boundaries. You should match velocity but not velocity (includes a space before the “v”) or velocity;. A whole number consisting of more than six digits. A word that is between 3 and 6 characters long. Pay attention to word-boundaries. One or more white-space characters, followed by a hyphen or a semicolon or a colon. Write a function called findTitled() that, when given any string, will return a character vector of all words following any one of these titles: “Mr.” “Mister” “Missus” “Mrs.” “Miss” “Ms.” There should be exactly one space between the title and the following word. The function should take a single argument called str, the string to search. A typical example of use is as follows: text &lt;- &quot;Here are Mr. Tom, Ms. Thatcher, Miss Ellen, and Helen.&quot; findTitled(text) ## [1] &quot;Tom&quot; &quot;Thatcher&quot; &quot;Ellen&quot; Write a function called capRepeats() that, when given a string, searches for all repeated-word pairs (with at least one character of white-space in between) and replaces them with the same pair where all letters are capitalized. The function should take a single argument called str, the string to be searched. A typical example of use would be as follows: capRepeats(&quot;I have a boo boo on my knee \\tknee!&quot;) ## [1] &quot;I have a BOO BOO on my KNEE \\tKNEE!&quot; Use str_subset() to write a function called longWord() that, when given a character vector of strings, returns a vector consisting of the strings that contain a word at least eight characters long. The function should take a single argument called strs. An example of use would be: myText &lt;- c(&quot;Very short words.&quot;, &quot;Got a gargantuan word.&quot;, &quot;More short words!&quot;) longWord(strs = myText) ## [1] &quot;Got a gargantuan word.&quot; Write a function called longWord2() that, when given a character vector of strings, returns a list of character vectors, where each vector consists of the words in the corresponding string that are at least eight characters long. The function should take a single argument called strs. An example of use would be: myText &lt;- c(&quot;Very short words.&quot;, &quot;Got a gargantuan word.&quot;, &quot;More short words!&quot;) longWord2(strs = myText) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;gargantuan&quot; ## ## [[3]] ## character(0) Write a function called phoneNumber() that, when given a vector of strings returns a logical vector indicating which of the strings contain a valid phone number. For our purposes a valid phone number shall be any string of the form xxx-xxx-xxxx or xxx.xxx.xxx Thus, 502-863-8111 is valid and so is 502.863.8111, but not 502-863.8111. In the code for the function, specify the pattern using (?x) so you can ignore whitespace and leave detailed comments for each portion of the regular expression. The function should take a single parameter called strs. A typical example of use would be: sentences &lt;- c(&quot;Ted&#39;s number is 606-255-3143.&quot;, &quot;Rhonda&#39;s number is 403-28-1259.&quot;, &quot;Lydia&#39;s number is 502.255.3921.&quot;, &quot;Raj&#39;s number is 502.367-4432.&quot;) phoneNumber(strs = sentences) ## [1] TRUE FALSE TRUE FALSE "],
["files.html", "Chapter 13 Files", " Chapter 13 Files Figure 13.1: Scarecrow, Tin Man, Dorothy, Toto and the Cowardly Lion wearing Emerald City Specticals: an original llustration from The Wonderful Wizard of Oz, by L. Frank Bloom. Most computer programming tasks involve the processing or analysis of data, and unless we are doing a simulation, that data has not been created within the program that is supposed to process it. This Chapter covers some basic techniques for importing data into R, saving it for future use, and exporting it for use by others. "],
["downloading-files.html", "13.1 Downloading Files", " 13.1 Downloading Files First we’ll deal with the situation in which the data we want is in a file somewhere on the Internet. In this case we need only download the file to our computer. It’s a good idea to keep one’s work organized. Since we plan to begin downloading data files, we might as well create a directory dedicated to them. It’s easy to use the R Studio IDE to create the directory, but we might as well learn how the same task could be accomplished with an R-command. We will use the function dir.create(). dir.create(&quot;downloads&quot;) We are ready to begin downloading. Let’s begin with a file32 at the URL: https://homerhanumat.github.io/r-notes/downloads/words.zip The relevant function is download.file(): download.file(url = &quot;https://github.com/homerhanumat/r-notes/blob/master/downloads/words.zip?raw=true&quot;, destfile = &quot;downloads/words.zip&quot;) The file should now be in the downloads folder of your Home directory. We see that it’s a zip-file. R can unzip it for us: unzip(zipfile = &quot;downloads/words.zip&quot;) We now have the text-file words.txt in our downloads directory. In R Studio you can examine the contents of the file if you click on the file-name in your Files tab. You see something like this: aa aah aahed aahing aahs aal ... The file is a fairly comprehensive list of words in the English language—all in lowercase, one word per line. This file is a compressed version of words.txt file used in Think Python (Downey 2015).↩ "],
["reading-text-files-with-readlines.html", "13.2 Reading Text Files with readLines()", " 13.2 Reading Text Files with readLines() Let’s transfer the contents of words.txt to a character vector in R. The function for this is readLines(): words &lt;- readLines(con = &quot;downloads/words.txt&quot;) readLines() is similar to readline(), which we have used in the past to get a single line of input from the user. readLines() can also read from the console—this is called standard input—but it can also make a connection33 with any file. In the code above, we set the connection to be the file words.txt. By default readLines() reads the file—one line at a time as a string. The resulting character vector is named words.34 Let’s look at words to see if it came out the way we expected. The head() function works not only on data frames but also on vectors: head(words) ## [1] &quot;aa&quot; &quot;aah&quot; &quot;aahed&quot; &quot;aahing&quot; &quot;aahs&quot; &quot;aal&quot; Yes, it looks like we got one word into each element of the vector. The total number of words is: length(words) ## [1] 113809 A connection, also known to R-programmers as a “generalized file”, is any one of a wide range of interfaces that can be established with the world outside of the R-session for the purpose of sending or receiving data. One can make a connection with files stored locally on one’s computer, with URL addresses on the internet, with databases, and so on.↩ Note that the stringr package contains a vector named words that is used for practicing with regular expressions. This vector is now masked by the words vector you have created, but you can still access it as stringr::words.↩ "],
["reading-text-files-with-readr.html", "13.3 Reading Text Files with readr", " 13.3 Reading Text Files with readr words.txt was unusually simple—just one piece of data per line. It made sense to read it into a vector. Most of the files that we encounter have a more complex structure. In many cases it is best to incorporate them into R as data frames. R has several tools for reading data into data frames. One of the most convenient—and most popular—is the set of functions in the readr package (Wickham, Hester, and Francois 2018). It’s attached automatically when you load the tidy-verse, but you can also attach it separately: library(readr) Let’s practice reading in a file from the Internet. The URL is: https://query.data.world/s/b6plbxp3ym20s5a5iey36geul The file is taken from data.world, a site very much worth exploring, and it addresses part of a study on alcohol consumption and life-expectancy in the nations of the world. (The file-extension .csv indicates that the it is expected to use commas to separate data values.) The easiest way to learn the functions of readr is to use a widget supplied by the R Studio IDE: In the Environment Pane, find the drop-down menu Import Dataset, Ask to Import CSV …. You will be taken to a dialog box. Enter the above URL in the File/URL field and press the Update button. A preview of the data is shown. At the bottom left there are a number of Import Options. The most important one at this point is the Name. Instead of the messy name that is shown, type something descriptive. (We’ll choose alcGDP.) Note the Code Preview box at the bottom right. It contains the R-commands needed to download and read the text-file alcGDP into R as a data frame. You should copy the code and save it somewhere (in an R script or R Markdown document) in order to keep a record of your work. You may then press the Import button. The data is read into alcGDP according to the read_csv() call below: alcGDP &lt;- read_csv(&quot;https://query.data.world/s/b6plbxp3ym20s5a5iey36geul&quot;) If you pressed the Import button, then you can see alcGDP in the Editor window. Notice that is has five variables. Two of them have only NA values, and the final two of them have names that are simply too long to be practical. Go ahead and fix this: names(alcGDP)[c(4,5)] &lt;- c(&quot;liters&quot;, &quot;gdp&quot;) alcGDP$YearDisplay &lt;- NULL alcGDP$SexDisplay &lt;- NULL Now take a look at the frame: head(alcGDP) ## # A tibble: 6 x 3 ## country liters gdp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 0 20842 ## 2 Albania 4.9 13370 ## 3 Azerbaijan 1.3 75198 ## 4 Madagascar 0.8 10593 ## 5 Malawi 1.5 4258 ## 6 Malaysia 0.3 326933 liters gives the mean total liters of alcohol consumed per person in each country, and GDP is the country’s Gross Domestic Product in millions of dollars. From the Console output you can tell that alcGDP is a tibble rather than a data frame. (The default behavior for read_csv() is to import data as tibbles.) We won’t analyze alcGDP here, but you might want to look at it later. You can save it permanently to your Home directory with the save() function: save(alcGDP, file = &quot;downloads/alcGDP.rda&quot;) alcGDP is still in your Global Environment. If you clear the environment later on, you can reload alcGDP as follows: load(&quot;downloads/alcGDP.rda&quot;) References "],
["writing-to-files.html", "13.4 Writing to Files", " 13.4 Writing to Files If you would like to send the data in a data frame to a colleague who does not use R, then you should convert it to a common text-file format such as CSV. For this purpose readr provides the write_csv() command. The following code writes m11survey to a CSV file in your Home directory. write_csv(bcscr::m111survey, path = &quot;m111survey.csv&quot;) You may now transmit the file to your colleague. "],
["application-making-a-lexicon.html", "13.5 Application: Making a Lexicon", " 13.5 Application: Making a Lexicon A lexicon is any list of words—usually the words of a language or of some body of texts produced in that language. In this Section we’ll combine our file-handling skills with regular expressions to create a lexicon for L. Frank Bloom’s classic The Wizard of Oz. First you need to get hold of the text itself. The Wizrd of Oz has been in the public domain for many years now, and is available from the Gutenberg Project. You could look it up there and find the URL for download: http://www.gutenberg.org/cache/epub/55/pg55.txt Go ahead and download the file: ozURL &lt;- &quot;http://www.gutenberg.org/cache/epub/55/pg55.txt&quot; if ( !(file.exists(&quot;downloads/oz.txt&quot;)) ) { download.file(url = ozURL, destfile = &quot;downloads/oz.txt&quot;) } Next, read in the file, line by line: oz &lt;- readLines(con = &quot;downloads/oz.txt&quot;) Take some time to look through oz.txt. If we plan to make a lexicon for the book, then we probably don’t want to include Gutenberg’s header material or their discussion of licensing at the end. We’ll need to cut this material out of oz: # a helper function findIndex &lt;- function(pattern, text) { str_detect(text, pattern = pattern) %&gt;% which() } # now find lines to start and end at: firstLine &lt;- findIndex(&quot;^\\\\*\\\\*\\\\* START OF THIS PROJECT GUTENBERG&quot;, oz) + 1 lastLine &lt;- findIndex(&quot;^End of Project Gutenberg&#39;s&quot;, oz) - 1 # trim oz to the desired text: oz2 &lt;- oz[firstLine:lastLine] Let us now take a first pass at splitting the text into all of its “words.” Our first thought is that words are the parts of the text that are separated by one or more white-space characters, so we might try this: ozwds &lt;- oz2 %&gt;% str_split(pattern = &quot;\\\\s+&quot;) %&gt;% unlist() Next, let’s convert all of the words to lowercase, then make a new word-list with no repeats, then sort that list: ozWords &lt;- ozwds %&gt;% str_to_lower() %&gt;% unique() %&gt;% str_sort() It’s time now to examine our prospective lexicon. Look around a bit in ozWords. There are some numbers. We’ll get rid of them. There are an awful lot of strings that begin or end with punctuation. This should not be difficult to remove with str_replace(). There are plenty of contractions, like &quot;aren't&quot;. It seems reasonable to count these as words, so we’ll leave them alone. There are hyphenated words. What should we do with them? In a book for grown-ups you’ll find lots of hyphenated words where the components words are meaningful in themselves. That’s because of a grown-up grammar rule that says we should “hyphenate two or more words when they come before a noun they modify and act as a single idea.” This is important: after all,“short-listed candidates” refers to candidates who appear on our short list, whereas “short listed candidates” appears to refer to short candidates who appear on our list. If this were a grown-up text then I’d want to split on hyphens in order to capture the meaningful word-components. In The Wizard of Oz, though, it seems that hyphenation is used mainly to create interesting new words out nonsense sound-fragments, as in: So the Wicked Witch took the Golden Cap from her cupboard and placed it upon her head. Then she stood upon her left foot and said slowly: “Ep-pe, pep-pe, kak-ke!” Next she stood upon her right foot and said: “Hil-lo, hol-lo, hel-lo!” After this she stood upon both feet and cried in a loud voice: “Ziz-zy, zuz-zy, zik!” It would seem that (for example) “zuz-zy” should count as a word, but its parts “zuz” and “zy” should not count as words. On the other hand, we often find pairs of hyphens that appear to act as the emdash character (—): The cyclone had set the house down very gently--for a cyclone--in the midst of a country of marvelous beauty. This causes such strings as “gently--for” and “cyclone--in” to appear in our lexicon. We don’t want that, so we need to split on double-hyphens. Let’s go back and try the splitting again: ozwds &lt;- oz2 %&gt;% str_split(pattern = &quot;(?x) # allow comments (-{2,}) # two or more hyphens | # or (\\\\s+) # whitespace &quot;) %&gt;% unlist() Now let’s strip off any leading or trailing punctuation. In ICU Unicode, \\p{P} is a shortcut for any punctuation character: ozWords &lt;- ozwds %&gt;% str_replace(pattern = &quot;^\\\\p{P}+&quot;, replacement = &quot;&quot;) %&gt;% # strip leading punctuation str_replace(pattern = &quot;\\\\p{P}+$&quot;, replacement = &quot;&quot;) %&gt;% # strip trailing punctuation str_to_lower() %&gt;% unique() %&gt;% str_sort() Taking a second look at ozWords, we see that we need to get rid of some numbers and a spurious empty string: isNumber &lt;- str_detect(ozWords, pattern = &quot;^\\\\d+&quot;) isEmpty &lt;- ozWords == &quot;&quot; validWord &lt;- !isNumber &amp; !isEmpty ozWords &lt;- ozWords[validWord] A final check of ozWords appears not turn up any serious problems. We’ll take it as our lexicon for The Wizard of Oz. For fun, let’s make an index to the book. First, a little helper function: indexFactory &lt;- function(lexicon, fn) { index &lt;- list() fileLines &lt;- readLines(con = fn) for ( i in seq_len(length(lexicon)) ) { word &lt;- lexicon[i] pattern &lt;- paste0(&quot;(?i)&quot;, word) hasWord &lt;- str_detect(fileLines, pattern = pattern) index[[word]] &lt;- which(hasWord) } index } Now we call our helper function to create the index: ozIndex &lt;- indexFactory(ozWords, &quot;downloads/oz.txt&quot;) We can use the index to look up words in the original text, without having to use regular expressions explicitly. First we make a convenience-function for looking up words:: ozLookup &lt;- function(word) { fn &lt;- &quot;downloads/oz.txt&quot; lexicon &lt;- ozWords index &lt;- ozIndex file &lt;- readLines(con = fn) if ( !(word %in% lexicon ) ) { message &lt;- paste0(&quot;\\&quot;&quot;, word, &quot;\\&quot; is not in the lexicon!\\n&quot;) return(cat(message)) } matchLines &lt;- index[[word]] number &lt;- length(matchLines) cat(&quot;There are &quot;, number, &quot;lines that contain your request.\\n\\n&quot;) hrule &lt;- rep(&quot;-&quot;, times = 30) for ( i in 1:number ) { lineNum &lt;- matchLines[i] cat(hrule, &quot;\\n&quot;) cat(lineNum, &quot;: &quot;, file[lineNum], &quot;\\n&quot;) } } Now we give it a try: ozLookup(&quot;lolliop&quot;) ## &quot;lolliop&quot; is not in the lexicon! And another try: ozLookup(&quot;humbug&quot;) ## There are 10 lines that contain your request. ## ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 61 : 16. The Magic Art of the Great Humbug ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3421 : a humbug.&quot; ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3424 : it pleased him. &quot;I am a humbug.&quot; ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3438 : &quot;Doesn&#39;t anyone else know you&#39;re a humbug?&quot; asked Dorothy. ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3472 : being such a humbug.&quot; ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3603 : one I am a humbug.&quot; ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3607 : Terrible Humbug,&quot; as she called him, would find a way to send her back ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3613 : 16. The Magic Art of the Great Humbug ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3738 : they wanted. &quot;How can I help being a humbug,&quot; he said, &quot;when all these ## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ## 3802 : &quot;Yes, of course,&quot; replied Oz. &quot;I am tired of being such a humbug. If "],
["glossary-10.html", "Glossary", " Glossary Connection (also called a “Generalized File”) An interface with the world outside of the R-session, for the purpose of sending or receiving data. "],
["exercises-9.html", "Exercises", " Exercises The word “caracara” is in words. Note that it in this word a sequence of four letters is immediately repeated. Write a function that uses a regular expression to find all of the words in words that contain a doublet like this: specifically, a sequence of four or more letters that are immediately repeated. (The repeated sequence need NOT make up the entire word, as in the case of “caracara.”) The program should cat() the words to the console, one per line. Write a program that uses a regular expression to find all of the words in words that contain a “q” that is not immediately followed by a “u”. The program should cat() the words to the console, one per line. Write a program that uses a regular expression to find all of the words in words that are 4-letter or 5-letter palindromes. The program should cat() the words to the console, one per line. (Hint: consult Section 12.3.8.) It can be proven mathematically that there is no regular expression, no matter how complex, that matches all and only the palindromes. We can write regular expressions to match all and only the palindromes that are less than some fixed number of characters, but we can’t match palindromes of arbitrary length. Write a program to find all of the palindromes in words. Obviously this program won’t have to use a regular expression! (*) Gutenburg’s version of Jane Austin’s classic novel Pride and Prejudice may be downloaded from the URL: https://www.gutenberg.org/files/1342/1342-0.txt Your mission is to create a lexicon for Austin’s novel. Follow the pattern of the work done in the text to make a lexicon for The Wizard of Oz. You will have to make different choices, though, about what constitutes a “word”. For example, Austin’s prose is complex and “grown-up”in comparison to the prose of Oz, so the parts of hyphenated words probably constitute valid words in and of themselves. Austin has a habit of concealing certain place-names with dashes, and occasionally in letters to each other Austin’s characters will refer to a person by an initial. Should initials and sequences of dashes count as words? And what about “12th” as in “the 12th of December”? As you examine the text and your initial word list you will have to make decisions about these and other matters. Write a report in R Markdown in which you create the lexicon. Include the code for all of your work—beginning from the file-download—so that a person who runs all of the code in the document will create the very same lexicon you made. As you develop the lexicon, explain your code and the rationale for your choices about what counts as a “word” in Austin’s novel. Conclude the report with a data frame of the twenty most common words in Austin’s novel that are more than eight letters long. The frame should have two variables: one for the words and another for the number of occurrences. The frame should be sorted so that the words appear in decreasing order of frequency (i.e., most common word comes first). (*) Install the tidytext and gutenbergr packages. gutenbergr simplifies the task of downloading a Project Gutenberg text, stripping off the spurious leading and trailing material. tidytext automates a number of basic text-analysis tasks. Read the Vignette in the gutenberg packages and learn how to find the words in a text. Find the unique words in The Wizard of Oz as determined by tidytext, and use the setdiff() function to compare the ozWords in this Chapter with the word-list according to tidytext. What are the primary differences? "],
["functional.html", "Chapter 14 Functional Programming in R", " Chapter 14 Functional Programming in R It was simple, but you know, it’s always simple when you’ve done it. —Simone Gabbriellini In this Chapter we aren’t going to cover any fundamentally new R powers. Instead we’ll get acquainted with just one aspect of a computer programming paradigm known as functional programming. We will examine a set of R-functions for which functions themselves are supplied as arguments. These functions allow us to accomplish a great deal of computation in rather concise and expressive code. Not only are they useful in R itself, but they help you to reason abstractly about computation and prepare you for functional-programming aspects of other programming languages. "],
["programming-paradigms.html", "14.1 Programming Paradigms", " 14.1 Programming Paradigms Let us begin by exploring the notion of a programming paradigm in general. We will go on in this Chapter to consider two programming paradigms for which R provides considerable support. In the next Chapter we will consider a third programming paradigm that exists in R. A programming paradigm is a way to describe some of the features of programming languages. Often a paradigm includes principles concerning the use of these features, or embodies a view that these features have special importance and utility in good programming practice. 14.1.1 Procedural Programming One of the older programming paradigms in existence is procedural programming. It is supported in many popular languages and is often the first paradigm within which beginners learn to program. In fact, if one’s programming does not progress beyond a rudimentary level, one may never become aware that one is working within the procedural paradigm—or any paradigm at all, for that matter. Before we define procedural programming, let’s illustrate it with an example. Almost any of the programs we have written so far would do as examples; for specificity, let’s consider the following snippet of code that produces from the data frame m111survey a new, smaller frame consisting of just the numerical variables: library(bcscr) # find the numer of columns in the data frame: cols &lt;- length(names(m111survey)) #set up a logical vector of length equal to the number of columns: isNumerical &lt;- logical(cols) # loop through. For each variable, say if it is numerical: for ( i in seq_along(isNumerical) ) { isNumerical[i] &lt;- if (is.numeric(m111survey[, i])) TRUE else FALSE } # pick the numerical variables from the data frame numsm111 &lt;- m111survey[, isNumerical] # have a look at the result: str(numsm111) ## &#39;data.frame&#39;: 71 obs. of 6 variables: ## $ height : num 76 74 64 62 72 70.8 70 79 59 67 ... ## $ ideal_ht : num 78 76 NA 65 72 NA 72 76 61 67 ... ## $ sleep : num 9.5 7 9 7 8 10 4 6 7 7 ... ## $ fastest : int 119 110 85 100 95 100 85 160 90 90 ... ## $ GPA : num 3.56 2.5 3.8 3.5 3.2 3.1 3.68 2.7 2.8 NA ... ## $ diff.ideal.act.: num 2 2 NA 3 0 NA 2 -3 2 0 ... By now there is nothing mysterious about the above code-snippet. What we want to become conscious of is the approach we have taken to the problem of selecting the numerical variables. In particular, observe that: We worked throughout with data, some of which, like m111survey, was given to us and some of which we created on our own to help solve the problem. For example, we created the variable cols. Note also the very helpful index-variable i in the for-loop. We set up the data structure isNumerical in order to hold a set of data (TRUEs and FALSEs). We relied on various procedures to create data and to manipulate that data in order to produce the desired result. Some of the procedures appeared as special blocks of code—most notably the for-loop, but also the if-else construct within the loop. Other procedures took the form of functions. As we know, a function encapsulates a useful procedure so that it can be easily reused in a wide variety of circumstances, without the user having to know the details of how it works. We know that names() will give us the vector of names of the columns of m111survey, that length() will tell us how many names, there are, that is.numeric() will tell us whether or not a given variable in m111survey is a numerical variable, and so on. The procedures embodied in these functions were written by other folks and we could examine them if we had the time and interest, but for the most part we are content simply to know how to access them. Procedural programming is a paradigm that solves problems with programs that can be broken up into collections of variables, data structures and procedures. In this paradigm, there is a sharp distinction between variables and data structures on the one hand and procedures on the other. Variables and data structures are data—they are the “stuff” that a program manipulates to produce other data, other “stuff.” Procedures do the manipulating, turning stuff into other stuff. "],
["the-functional-programming-paradigm.html", "14.2 The Functional Programming Paradigm", " 14.2 The Functional Programming Paradigm Let us now turn to the second of the two major programming paradigms that we study in this Chapter: Functional Programming. 14.2.1 The Ubiquity of Functions in R Let’s a bit more closely at our code snippet. Notice how prominently functions figure into it, on nearly every line. In fact, every line calls at least one function! This might seem unbelievable: after all, consider the line below: numsm111 &lt;- m111survey[, isNumerical] There don’t appear to be any functions being called, here! But in fact two functions get called: The so-called assignment operator &lt;- is actually a function in disguise: the more official—albeit less readable—form of variable &lt;- value is: `&lt;-`(variable, value) Thus, to assign the value 3 to that variable a one could write: `&lt;-`(a, 3) a # check that a is really 3 ## [1] 3 The sub-setting operator for vectors [, more formally known as extraction (see help(Extract)) is also a function. The expression m111survey[, isNumerical] is actually the following function-call in disguise: `[`(m111survey, isNumerical) Indeed functions are ubiquitous in R. This is part of the significance of the following well-known remark by a developer of S, the precursor-language of R: “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.&quot; —John Chambers The second slogan indicates that functions are everywhere in R. It also corresponds to the first principle of the functional programming paradigm, namely: Computation is regarded as the evaluation of functions. 14.2.2 Functions as First-Class Citizens So functions are ubiquitous in R. Another interesting thing about them is that even though they seem to be associated with procedures—after all, they make things happen—they are, nevertheless, also objects. They are data, or “stuff” if you like. This may not seem obvious at first. But look at the following code, where you can ask what type of thing a function is: typeof(is.numeric) ## [1] &quot;builtin&quot; The so-called “primitive” functions of R—the functions written not in R but in C-code—are “built in” objects. On the other hand, consider this user-defined function: f &lt;- function(x) x+3 typeof(f) ## [1] &quot;closure&quot; Functions other than primitive functions are objects of type “closure.”35 If a function can be a certain type of thing, then it must be a “thing”—an object, something you can manipulate. For example, you can put functions in a list: lst &lt;- list(is.numeric, f) lst ## [[1]] ## function (x) .Primitive(&quot;is.numeric&quot;) ## ## [[2]] ## function(x) x+3 Very importantly, you can make functions serve as argument for other functions, and functions can return other functions as their results. The following example demonstrates both of these possibilities. cuber &lt;- function(f) { g &lt;- function(x) f(x)^3 g } h &lt;- cuber(abs) h(-2) # returns |-2|^3 = 2^3 = 8 ## [1] 8 In fact, in R functions can be treated just like any variable. In computer programming, we say that such functions are first-class citizens. Although it is not often stated as a separate principle of the functional programming paradigm it is true that in languages that provide support for functional programming, the following principle holds true: Functions are first-class citizens. 14.2.3 Minimize Side Effects In the code-snippet under consideration, we note that there are two types of functions: functions that return a value; functions that provide output to the console or make a change in the Global Environment. Example of the first type of function included: length() names() seq_along() is.numeric() the extraction-function `[`() A function that produced output to the console was str(). The assignment function `&lt;-`() added cols, isNumerical and numsm111 to the Global Environment, and also made changes to isNumerical in the course of the for-loop. Of course we have seen examples of functions that do two of these things at once, for example: myFun &lt;- function(x) { cat(&quot;myFun is running!\\n&quot;) # output to console x + 3 # return a value } myFun(6) ## myFun is running! ## [1] 9 In computer programming, output to the console, along with changes of state—changes to the Global Environment or to the file structure of your computer—are called side-effects. Functions that only return values and do not produce side-effects are called pure functions. A third principle of the functional programming paradigm is: Functions should be pure. Now this principle is difficult to adhere to, and in fact if you were to adhere strictly to it in R then your programs would never “do” anything. There do exist quite practical programming languages in which all of the functions are pure—and this leads to some very interesting features such as that the order in which operations are evaluated doesn’t affect what the function returns—but these “purely functional” languages manage purity by having other objects besides functions produce the necessary side-effects. In R we happily let our functions have side-effects: we certainly want to do some assignment, and print things out to the console from time to time. One way that R does support the third principle of functional programming is that it makes it easy to avoid having your functions modify the Global Environment. To see this consider the following example: addThree &lt;- function(x) { heavenlyHash &lt;- 5 x+3 # returns this value } result &lt;- addThree(10) result heavenlyHash ## [1] 13 ## Error: object &#39;heavenlyHash&#39; not found This is as we expect: the variable heavenlyHash exists only in the run-time environment that is created in the call to addThree(). As soon as the function finishes execution that environment dies, and heavenlyHash dies long with it. In particular, it never becomes part of the Global Environment. If you really want you functions to modify the Global Environment—or any environment other than its run-time environment, for that matter—then you have to take special measures. You could, for example, use the super-assignment operator &lt;&lt;-: addThreeSideEffect &lt;- function(x) { heavenlyHash &lt;&lt;- 5 x+3 # returns this value } result &lt;- addThreeSideEffect(10) result ## [1] 13 heavenlyHash ## [1] 5 The super-assignment operator looks for the name heavenlyHash in the parent environment of the run-time environment, If if finds heavenlyHash there then it changes its value to 5 and stops. Otherwise it looks in the next parent up, and so on until it reaches the Global Environment, at which point if it doesn’t find a heavenlyHash it creates one and gives it the value. In the example above, assuming you ran the function from the console, the parent environment is the Global Environment and the function has made a change to it: a side-effect. Except in the case of explicit assignment functions like `&lt;-`(), changes made by functions to the Global Environment can be quite problematic. After all, we are used to using functions without having to look inside them to see how they do their work. Even if we once wrote the function ourselves, we may not remember how it works, so if it creates side effects we may not remember that it does, and calling them could interfere with other important work that the program is doing. (If the program already has heavenlyHash in the Global Environment and the we call a function that changes it value, we could be in for big trouble.) Accordingly, R supports the third principle of functional programming to the extent of making it easy for you to avoid function calls that change your Global Environment. 14.2.4 Procedures as Higher-Order Function Calls The last principle of the functional programming paradigms that we will state here isn’t really a formal principle: it is really more an indication of the programming style that prevails in languages where functions are first-class objects and that provide other support for functional programming. The final principle is: As much as possible, procedures should be accomplished by function calls, In particular, loops should be replaced by calls to higher-order functions. A higher-order function is simply a function that takes other functions as arguments. R provides a nice set of higher-order functions, many of which substitute for iterative procedures such as loops. In subsequent sections we will study the some of the most important higher-order functions, and see how they allow us to express some fairly complex procedures in a concise and readable way. You will also see how this style really blurs the distinction—so fundamental to procedural programming—between data and procedures. In functional programming, functions ARE data, and procedures are just function calls. 14.2.5 Functional Programming: A Summary For our purposes, the principles of the functional programming paradigm are as follows: Computation consists in the evaluation of functions. Functions are first-class citizens in the language. Functions should only return values; they should not produce side-effects. (At the very least they should not modify the Global Environment unless they are dedicated to assignment in the first place.) As much as possible, procedures should be written in terms of function calls. In particular, loops should be replaced by calls to higher-order functions. The term “closure” comes from the fact that every function we define in R consists of three elements: its formal arguments, its body, and a pointer to its enclosing environment. (Recall that in R the enclosing environment is the environment that was active at the time the function was defined, and that it is the second place—after the run-time environment—where R consult when looking up names during the execution of the function.) Due to the importance of its enclosing environment a function gets the name “closure.”↩ "],
["purrr-higher-order-functions-for-iteration.html", "14.3 purrr Higher-Order Functions for Iteration", " 14.3 purrr Higher-Order Functions for Iteration In the remainder of the Chapter we will study important higher-order functions: functions that take a function as an argument and apply that function to each element of another data structure. As we have said previously, such functions often serve as alternatives to loops. The higher-order functions we study come from the package purrr, which is attached whenever we load the tidy-verse. 14.3.1 map() and Variations Suppose that we want to generate five vectors, each of which consists of ten numbers randomly chosen between 0 and 1. We accomplish the task with a loop, as follows: # set up a list of length 10: lst &lt;- vector(mode = &quot;list&quot;, length = 5) for ( i in 1:5 ) { lst[[i]] &lt;- runif(10) } str(lst) ## List of 5 ## $ : num [1:10] 0.271 0.189 0.267 0.956 0.473 ... ## $ : num [1:10] 0.5677 0.9629 0.5131 0.0181 0.7333 ... ## $ : num [1:10] 0.268 0.477 0.263 0.107 0.608 ... ## $ : num [1:10] 0.2411 0.3267 0.0647 0.1426 0.5102 ... ## $ : num [1:10] 0.364 0.524 0.604 0.119 0.835 ... If we wanted the vectors to have length \\(1, 4, 9, 16,\\) and 25, then we could write: lst &lt;- vector(mode = &quot;list&quot;, length = 5) for ( i in 1:5 ) { lst[[i]] &lt;- runif(i^2) } str(lst) ## List of 5 ## $ : num 0.647 ## $ : num [1:4] 0.394 0.619 0.477 0.136 ## $ : num [1:9] 0.06738 0.12915 0.39312 0.00258 0.62021 ... ## $ : num [1:16] 0.409 0.54 0.961 0.654 0.547 ... ## $ : num [1:25] 0.96407 0.07147 0.95581 0.94798 0.00119 ... In the first example, the elements in the vector 1:5 didn’t matter—we wanted a vector of length ten each time—and in the second case the elements in the 1:5 did matter, in that they determined the lengths of the five vectors produced. Of course in general we could apply runif() to each element of any vector at all, like this: vec &lt;- c(5, 7, 8, 2, 9) lst &lt;- vector(mode = &quot;list&quot;, length = length(vec)) for ( i in seq_along(vec) ) { lst[[i]] &lt;- runif(vec[i]) } str(lst) ## List of 5 ## $ : num [1:5] 0.647 0.394 0.619 0.477 0.136 ## $ : num [1:7] 0.06738 0.12915 0.39312 0.00258 0.62021 ... ## $ : num [1:8] 0.826 0.423 0.409 0.54 0.961 ... ## $ : num [1:2] 0.1968 0.0779 ## $ : num [1:9] 0.818 0.942 0.884 0.166 0.355 ... If we can apply runif() to each element of a vector, why not apply an arbitrary function to each element? That’s what the function map() will do for us. The general form of map() is: map(.x, .f, ...) In the template above: .x can be a list or any atomic vector; .f is a function that is to be applied to each element of .x. In the default operation of map(), each element of .x becomes in turn the first argument of .f. ... consists of other arguments that are supplied as arguments for the .f function, in case you have to set other parameters of the function in order to get it to perform in the way you would like. The result is always a list. With map() we can get the list in our second example as follows: howMany &lt;- c(5, 7, 8, 2, 9) lst &lt;- howMany %&gt;% map(runif) str(lst) ## List of 5 ## $ : num [1:5] 0.647 0.394 0.619 0.477 0.136 ## $ : num [1:7] 0.06738 0.12915 0.39312 0.00258 0.62021 ... ## $ : num [1:8] 0.826 0.423 0.409 0.54 0.961 ... ## $ : num [1:2] 0.1968 0.0779 ## $ : num [1:9] 0.818 0.942 0.884 0.166 0.355 ... If we had wanted the random numbers to be between—say—4 and 8, then we would supply extra arguments to runif() as follows: lst &lt;- howMany %&gt;% map(runif, min = 4, max = 8) str(lst) ## List of 5 ## $ : num [1:5] 6.59 5.58 6.47 5.91 4.54 ## $ : num [1:7] 4.27 4.52 5.57 4.01 6.48 ... ## $ : num [1:8] 7.3 5.69 5.64 6.16 7.84 ... ## $ : num [1:2] 4.79 4.31 ## $ : num [1:9] 7.27 7.77 7.54 4.66 5.42 ... The default behavior of map() is that the .x vector supplies the first argument of .f. However, if some ... parameters are supplied then .x substitutes for the first parameter that is not mentioned in .... In the above example, the min and maxparameters are the second and third parameters for runif() so .x substitutes for the first parameter—the one that determines how many random numbers will be generated. In the example below, the vector lowerBounds substitutes for min, the second parameter of runif(): lowerBounds &lt;- 1:3 lowerBounds %&gt;% map(runif, n = 2, max = 8) ## [[1]] ## [1] 3.008575 5.964877 ## ## [[2]] ## [1] 6.514459 6.282105 ## ## [[3]] ## [1] 6.688118 7.431739 Sometimes we wish to vary two or more of the parameters of function. In that case we use pmap(). The first parameter of pmap() is named .l and takes a list of vectors (or lists). For example: howMany &lt;- c(3,1,4) upperBounds &lt;- c(1, 5, 10) list(howMany, upperBounds) %&gt;% pmap(runif, min = 0) ## [[1]] ## [1] 0.4142409 0.5140328 0.6190231 ## ## [[2]] ## [1] 0.193564 ## ## [[3]] ## [1] 3.0889976 7.4509632 3.6170952 0.2348365 Observe that pmap() knows to interpret the first element of the input-list—the vector howmany as giving the values of the first argument of runif(). The second parameter of runif() (min) is set at 0, so pmap() deduces that upperBounds—the second element of the input-list—gives the values for the next next parameter in line, the parameter max. One might just as well use pmap() to vary all three parameters: howMany &lt;- c(3,1,4) lowerBounds &lt;- c(-5, 0, 5) upperBounds &lt;- c(0, 5, 10) args &lt;- list(howMany, lowerBounds, upperBounds) args %&gt;% pmap(runif) %&gt;% str() ## List of 3 ## $ : num [1:3] -0.00743 -2.35882 -3.90104 ## $ : num 1.01 ## $ : num [1:4] 5.38 9.16 8.45 9.67 The .f parameter can be any function, including one that you define yourself. Here’s an example: rLetters &lt;- function(n, upper) { if ( upper ) { sample(LETTERS, size = n, replace = TRUE) } else { sample(letters, size = n, replace = TRUE) } } george &lt;- c(3, 6, 9) # vary number of letters to pick bettina &lt;- c(TRUE, FALSE, TRUE) # vary the case (upper, lower) list(george, bettina) %&gt;% pmap(rLetters) ## [[1]] ## [1] &quot;O&quot; &quot;G&quot; &quot;A&quot; ## ## [[2]] ## [1] &quot;x&quot; &quot;s&quot; &quot;p&quot; &quot;m&quot; &quot;n&quot; &quot;u&quot; ## ## [[3]] ## [1] &quot;R&quot; &quot;I&quot; &quot;Q&quot; &quot;M&quot; &quot;D&quot; &quot;E&quot; &quot;Y&quot; &quot;M&quot; &quot;O&quot; You could also set f to be a function that you write on the spot, without even bothering to give it a name: c(1, 3, 5) %&gt;% map(function(x) runif(3, min = 0, max = x)) ## [[1]] ## [1] 0.2002036 0.2269999 0.5505148 ## ## [[2]] ## [1] 1.250093 0.430766 2.521417 ## ## [[3]] ## [1] 4.861459 2.029991 2.718963 In computer programming a function is called anonymous when it is not the value bound to some name. . map() allows a shortcut for defining anonymous functions. The above call could have been written as: c(1, 3, 5) %&gt;% map(~runif(3, min = 0, max = .)) ## [[1]] ## [1] 0.4939934 0.8951945 0.7801631 ## ## [[2]] ## [1] 2.5637547 0.6993537 2.7956469 ## ## [[3]] ## [1] 4.790131 4.959646 2.544537 The ~ indicates that the body of the function is about to be begin. The . stands for the parameter of the function. When we introduced map() we said that .x was a vector or a list, In fact .x could be an object that can be coerced into a list. Hence it is quite common to use map() with the data frames: the frame is turned into a list, each element of which is a column of the frame. Here is an example: data(&quot;m111survey&quot;, package = &quot;bcscr&quot;) numberNA &lt;- m111survey %&gt;% map(~sum(is.na(.))) str(numberNA) ## List of 12 ## $ height : int 0 ## $ ideal_ht : int 2 ## $ sleep : int 0 ## $ fastest : int 0 ## $ weight_feel : int 0 ## $ love_first : int 0 ## $ extra_life : int 0 ## $ seat : int 0 ## $ GPA : int 1 ## $ enough_Sleep : int 0 ## $ sex : int 0 ## $ diff.ideal.act.: int 2 Note that the elements of the returned list inherit the names of the input data frame. This holds for any named input: numbers &lt;- c(1, 3, 5) names(numbers) &lt;- c(&quot;one&quot;, &quot;three&quot;, &quot;five&quot;) numbers %&gt;% map(~runif(3, min = 0, max = .)) ## $one ## [1] 0.20446027 0.01439487 0.95556547 ## ## $three ## [1] 1.918565 1.987142 2.199431 ## ## $five ## [1] 4.372549 4.764371 2.637053 When the result can take on a form more simple than a list, it is possible to use variants of map() such as: map_int() map_dbl() map_lgl() map_chr() Thus we could obtain a named integer vector of the number of NA-values for each variable in m11survey as follows: numberNA &lt;- m111survey %&gt;% map_int(~sum(is.na(.))) numberNA ## height ideal_ht sleep fastest weight_feel love_first ## 0 2 0 0 0 0 ## extra_life seat GPA enough_Sleep sex diff.ideal.act. ## 0 0 1 0 0 2 Here are the types of each variable: m111survey %&gt;% map_chr(typeof) ## height ideal_ht sleep fastest weight_feel love_first ## &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; ## extra_life seat GPA enough_Sleep sex diff.ideal.act. ## &quot;integer&quot; &quot;integer&quot; &quot;double&quot; &quot;integer&quot; &quot;integer&quot; &quot;double&quot; Here is a statement of whether or not each variable is a factor: m111survey %&gt;% map_lgl(is.factor) ## height ideal_ht sleep fastest weight_feel love_first ## FALSE FALSE FALSE FALSE TRUE TRUE ## extra_life seat GPA enough_Sleep sex diff.ideal.act. ## TRUE TRUE FALSE TRUE TRUE FALSE 14.3.2 walk() and Variations walk() is similar to map(), but is used when we are interested in producing side-effects. It applies its .f argument to each element of .x is was given, but also returns the .x in case we want to pipe it into some other function. Here we use walk() only for its side-effect: we re-write a familiar function to print a pattern to the Console without using a loop. pattern &lt;- function(char = &quot;*&quot;, n = 5) { lineLength &lt;- c(1:n, (n-1):1) theLine &lt;- function(char, n) { cat(rep(char, times = n), &quot;\\n&quot;, sep = &quot;&quot;) } lineLength %&gt;% walk(theLine, char = char) } pattern(char = &quot;a&quot;, n = 7) ## a ## aa ## aaa ## aaaa ## aaaaa ## aaaaaa ## aaaaaaa ## aaaaaa ## aaaaa ## aaaa ## aaa ## aa ## a The next example illustrates the use of the return-value of walk(). We would like to save plots of all numerical variables from the data frame m111survey, and also print summaries of them to the Console. First we create a directory to hold the plots: if ( !dir.exists(&quot;plots&quot;) ) dir.create(&quot;plots&quot;) Next, we get the numerical variables in m111survey: numericals &lt;- m111survey %&gt;% keep(is.numeric) # purrr::keep() We used purrr::keep(), which retains only the elements of its input .x such that its second argument .p ( a function that returns a single TRUE or FALSE) returns TRUE. We will also need the names of the numerical variables: numNames &lt;- numericals %&gt;% names() We need a function to save the density plot of a single numerical variable: saveGraph &lt;- function(var, varname) { p &lt;- ggplot(data = NULL, aes(x = var)) + geom_density(fill = &quot;burlywood&quot;) + labs(title = paste0(&quot;Density plot for &quot;, varname, &quot;.&quot;)) ggsave(filename = paste0(&quot;plots/density_&quot;, varname, &quot;.png&quot;), plot = p, device = &quot;png&quot;) } We also need a function to produce a summary of a single numerical variable: makeSummary &lt;- function(x, varname) { five &lt;- fivenum(x, na.rm = TRUE) list(variable = varname, min = five[1], Q1 = five[2], median = five[3], Q3 = five[4], max = five[5]) } Now we walk through the process. We will actually use the functionpwalk(), which will take the following inputs: .x (a list with two elements: the data frame of numerical variables and the vector of the names of these variables), and .f (the function saveGraph, to make and save a density plot) We also use pmap_dfr(), which takes a list consisting of the data frame and variable-names and constructs a data frame row-by-row, with each row summarizing one of the variables. list(numericals, numNames) %&gt;% pwalk(saveGraph) %&gt;% # returns the list pmap_dfr(makeSummary) ## # A tibble: 6 x 6 ## variable min Q1 median Q3 max ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 height 51.0 65.0 68.000 71.75 79 ## 2 ideal_ht 54.0 67.0 68.000 75.00 90 ## 3 sleep 2.0 5.0 7.000 7.00 10 ## 4 fastest 60.0 90.5 102.000 119.50 190 ## 5 GPA 1.9 2.9 3.225 3.56 4 ## 6 diff.ideal.act. -4.0 0.0 2.000 3.00 18 Check the plots directory; it should contain these files: density_diff.ideal.act.png density_fastest.png density.GPA.png density_height.png density_ideal_ht.png density_sleep.png 14.3.3 Practice Exercises Use map() to produce a list of the squares of the whole numbers from 1 to 10. Use map_dbl() to produce a numerical vector of the squares of the whole numbers from 1 to 10. Use map_chr to state the type of each element of the following list: lst &lt;- list( letters, seq(2, 20, by = 2), c(1L, 5L, 7L), 1:10 &gt; 5.5 ) Here are some people: people &lt;- c(&quot;Bettina&quot;, &quot;Raj&quot;, &quot;Isabella&quot;, &quot;Khalil&quot;) The following vector tells whether or not each person is a Grand Poo-Bah: status &lt;- c(&quot;humble&quot;, &quot;poobah&quot;, &quot;poobah&quot;, &quot;humble&quot;) Use pwalk() to properly greet each person. The result in the console should be as follows: ## Yo, dawg. ## Hail, O Grand Poo-Bah Raj! ## Hail, O Grand Poo-Bah Isabella! ## Yo, dawg. 14.3.4 Solutions to the Practice Exercises Try this: map(1:10, ~.^2) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 9 ## ## [[4]] ## [1] 16 ## ## [[5]] ## [1] 25 ## ## [[6]] ## [1] 36 ## ## [[7]] ## [1] 49 ## ## [[8]] ## [1] 64 ## ## [[9]] ## [1] 81 ## ## [[10]] ## [1] 100 This is more verbose, but works just as well: map(1:10, function(x) x^2) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 9 ## ## [[4]] ## [1] 16 ## ## [[5]] ## [1] 25 ## ## [[6]] ## [1] 36 ## ## [[7]] ## [1] 49 ## ## [[8]] ## [1] 64 ## ## [[9]] ## [1] 81 ## ## [[10]] ## [1] 100 Try this: map_dbl(1:10, ~.^2) ## [1] 1 4 9 16 25 36 49 64 81 100 Again the more verbose approach works just as well: map_dbl(1:10, function(x) x^2) ## [1] 1 4 9 16 25 36 49 64 81 100 Try this: map_chr(lst, typeof) ## [1] &quot;character&quot; &quot;double&quot; &quot;integer&quot; &quot;logical&quot; Try this: list(people, status) %&gt;% pwalk(function(person, type) { if ( type == &quot;poobah&quot; ) { cat(&quot;Hail, O Grand Poo-Bah &quot;, person, &quot;!\\n&quot;, sep = &quot;&quot;) } else { cat(&quot;Yo, dawg.\\n&quot;) } }) "],
["other-purrr-higher-order-functions.html", "14.4 Other purrr Higher-Order Functions", " 14.4 Other purrr Higher-Order Functions 14.4.1 keep() and discard() keep() is similar to dplyr’s filter(), but whereas filter() chooses rows of a data frame based on a given condition, keep() chooses the elements of the input list or vector .x based on a condition named .p. Examples: # keep the numbers that are 1 more than a multiple of 3 1:20 %&gt;% keep(.p = ~ . %% 3 == 1) ## [1] 1 4 7 10 13 16 19 # keep the factors in m111survey m111survey %&gt;% keep(is.factor) %&gt;% str() ## &#39;data.frame&#39;: 71 obs. of 6 variables: ## $ weight_feel : Factor w/ 3 levels &quot;1_underweight&quot;,..: 1 2 2 1 1 3 2 2 2 3 ... ## $ love_first : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ extra_life : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 2 2 1 1 2 1 2 2 2 1 ... ## $ seat : Factor w/ 3 levels &quot;1_front&quot;,&quot;2_middle&quot;,..: 1 2 2 1 3 1 1 3 3 2 ... ## $ enough_Sleep: Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 1 1 1 1 2 1 2 1 2 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 2 1 1 2 2 2 2 1 1 ... discard(.x,, . p = condition) is equivalent to keep(.x, .p = !condition). Thus: # discard numbers that are 1 more than a multiple of 3 1:20 %&gt;% discard(.p = ~ . %% 3 == 1) ## [1] 2 3 5 6 8 9 11 12 14 15 17 18 20 # discard the factors in m111survey m111survey %&gt;% discard(is.factor) %&gt;% str() ## &#39;data.frame&#39;: 71 obs. of 6 variables: ## $ height : num 76 74 64 62 72 70.8 70 79 59 67 ... ## $ ideal_ht : num 78 76 NA 65 72 NA 72 76 61 67 ... ## $ sleep : num 9.5 7 9 7 8 10 4 6 7 7 ... ## $ fastest : int 119 110 85 100 95 100 85 160 90 90 ... ## $ GPA : num 3.56 2.5 3.8 3.5 3.2 3.1 3.68 2.7 2.8 NA ... ## $ diff.ideal.act.: num 2 2 NA 3 0 NA 2 -3 2 0 ... 14.4.2 reduce() Another important member of the purrr family is reduce() . Given a vector .x and a function .f that takes two inputs, reduce() does the following: applies f to elements 1 and 2 of .x, getting a result; applies f to the result and to element 3 of .x, getting another result; applies f to this new result and to element 4 of .x, getting yet another result … … and so on until all of the elements of .x have been exhausted. then reduce() returns the final result in the above series of operations. For example, suppose that you want to add up the elements of the vector: vec &lt;- c(3, 1, 4, 6) Of course you could just use: sum(vec) ## [1] 14 After all, sum() has been written to apply to many elements at once. But what if addition could only be done two numbers at a time? How might you proceed? You could: add the 3 and 1 of (the first two elements of vec), getting 4; then add 4 to 4, the third element of vec, getting 8; then add 8 to 6, the final element of vec, getting 14; then return 14. reduce() operates in this way. vec %&gt;% reduce(.f = sum) ## [1] 14 Can you see how reduce() gets its name? Step by step, it “reduces” its .x argument, which may consist of many elements, to a single value. A common application of reduce() is to take an operation that is defined on only two items and extend it to operate on any number of items. Consider, for example, the function intersect(), , which will find the intersection of any two vectors of the same type: vec1 &lt;- c(3, 4, 5, 6) vec2 &lt;- c(4, 6, 8, -4) intersect(vec1, vec2) ## [1] 4 6 You cannot intersect three or more vectors at once: intersect(vec1, vec2, c(4, 7, 9)) ## Error in base::intersect(x, y, ...) : unused argument (c(4, 7, 9)) With reduce() you can intersect as many vectors as you like, provided that they are first stored in a list. lst &lt;- list(c(&quot;Akash&quot;, &quot;Bipan&quot;, &quot;Chandra&quot;, &quot;Devadatta&quot;, &quot;Raj&quot;), c(&quot;Raj&quot;, &quot;Vikram&quot;, &quot;Sita&quot;, &quot;Akash&quot;, &quot;Chandra&quot;), c(&quot;Akash&quot;, &quot;Raj&quot;, &quot;Chandra&quot;, &quot;Bipan&quot;, &quot;Lila&quot;), c(&quot;Akash&quot;, &quot;Vikram&quot;, &quot;Devadatta&quot;, &quot;Raj&quot;, &quot;Lila&quot;)) lst %&gt;% reduce(intersect) ## [1] &quot;Akash&quot; &quot;Raj&quot; You can write your own function to supply as the argument for .f, but it has to be able to operate on two arguments. reduce() will take the first argument of the .f function to be what has been “accumulated” so far, and the second argument of the .f function—the value to be combined with what has been accumulated—will be provided by the current element of .x. As a simple example, let’s write our own reduce-summer in a way that shows the user the reduction process at work: ## the .f function: mySummer &lt;- function(acc, curr) { cat(&quot;So far I have &quot;, acc, &quot;,\\n&quot;) cat(&quot;But just now I was given &quot; , curr, &quot; to add in.\\n\\n&quot;, sep = &quot;&quot;) sum(acc, curr) } ## .x will be the whole numbers from 1 to 4: 1:4 %&gt;% reduce(.f = mySummer) ## So far I have 1 , ## But just now I was given 2 to add in. ## ## So far I have 3 , ## But just now I was given 3 to add in. ## ## So far I have 6 , ## But just now I was given 4 to add in. ## [1] 10 When you write your own .f function, it’s a good idea to use names for the parameters that remind you of their role in the reduction process. acc (for “accumulated”) and curr (for “current”) are used above. reduce() can take an argument called .init. When this argument is given a value, operation begins by applying to .f to .init and the first element of .x. For example: 1:4 %&gt;% reduce(.f = mySummer, .init = 100) ## So far I have 100 , ## But just now I was given 1 to add in. ## ## So far I have 101 , ## But just now I was given 2 to add in. ## ## So far I have 103 , ## But just now I was given 3 to add in. ## ## So far I have 106 , ## But just now I was given 4 to add in. ## [1] 110 14.4.2.1 An Extended Example of Reduction Let’s apply reduce() with .init to the task of making a truth table: the set of all \\(2^n\\) logical vectors of a given length \\(n\\). The set \\(S_1\\) of vectors of length \\(n = 1\\) consists of only two vectors: ## ## vec1 TRUE ## vec2 FALSE Now consider a systematic way to construct the set \\(S_2\\) of all the vectors of length two. We know that there are four such vectors: ## ## vec1 TRUE TRUE ## vec2 TRUE FALSE ## vec3 FALSE TRUE ## vec4 FALSE FALSE Observe that the first two of them begin with TRUE and end with the set \\(S_1\\) of vectors of length one: ## ## vec1 TRUE TRUE ## vec2 TRUE FALSE The last two of them begin with FALSE and also end with \\(S_1\\): ## ## vec3 FALSE TRUE ## vec4 FALSE FALSE Now consider \\(S_3\\), the set of all eight vectors of length three: ## ## vec1 TRUE TRUE TRUE ## vec2 TRUE TRUE FALSE ## vec3 TRUE FALSE TRUE ## vec4 TRUE FALSE FALSE ## vec5 FALSE TRUE TRUE ## vec6 FALSE TRUE FALSE ## vec7 FALSE FALSE TRUE ## vec8 FALSE FALSE FALSE Observe that the first four of them end begin with TRUE and and with the vectors of \\(S_2\\): ## ## vec1 TRUE TRUE TRUE ## vec2 TRUE TRUE FALSE ## vec3 TRUE FALSE TRUE ## vec4 TRUE FALSE FALSE The last four of them begin with FALSE and also end with the vectors of \\(S_2\\): ## ## vec5 FALSE TRUE TRUE ## vec6 FALSE TRUE FALSE ## vec7 FALSE FALSE TRUE ## vec8 FALSE FALSE FALSE The pattern is now clear. If for any \\(m \\ge 1\\) you are in possession of the \\(2^m \\times m\\) matrix \\(S_m\\) of all possible vectors of length \\(m\\), then to obtain the \\(2^{m+1} \\times (m+1)\\) matrix \\(S_{m+1}\\) of all possible vectors of length \\(m+1\\) you should: stack \\(2^m\\) TRUEs on top of \\(2^m\\) FALSEs, creating a \\(2^{m+1} \\times 1\\) matrix \\(U\\); stack the \\(S_m\\) underneath itself, creating a \\(2^{m+1} \\times m\\) matrix \\(V\\); place \\(U\\) next to \\(V\\). reduce() with .init set to \\(S_1\\) is appropriate for this iterative building process. Here is an implementation: makeTable &lt;- function(n, verbose = FALSE) { # make .init (S_1) s1 &lt;- matrix(c(TRUE, FALSE), nrow = 2) rownames(s1) &lt;- c(&quot;vec1&quot;, &quot;vec2&quot;) colnames(s1) &lt;- c(&quot;&quot;) # make .f buildNext &lt;- function(accum, value) { if ( verbose ) { cat(&quot;On value &quot;, value, &quot; with accumalated material:&quot;, sep = &quot;&quot;) print(accum) } if ( value == 1 ) return(accum) r &lt;- nrow(accum) u &lt;- c(rep(TRUE, times = r), rep(FALSE, times = r)) v &lt;- rbind(accum, accum) nextMatrix &lt;- cbind(u, v) colnames(nextMatrix) &lt;- rep(&quot;&quot;, times = value) rownames(nextMatrix) &lt;- paste0(&quot;vec&quot;, 1:(2^value), sep = &quot;&quot;) if ( verbose ) { cat(&quot;Finishing value&quot;, value, &quot;, and I&#39;ve built:&quot;, sep = &quot;&quot;) print(nextMatrix) cat(&quot;\\n\\n&quot;) } nextMatrix } # build from .init to the final product S_n reduce(.x = 1:n, .f = buildNext, .init = s1) } We have included a verbose option so we can watch the process as it unfolds. Note also that the parameters for the .f function are named: acc (what has been “accumulated” up to the current step), and value (the value of .x at the current step). It’s conventional to give these or similar names to the parameters of the building-function. Let’s try it out: makeTable(3, verbose = TRUE) ## On value 1 with accumalated material: ## vec1 TRUE ## vec2 FALSE ## On value 2 with accumalated material: ## vec1 TRUE ## vec2 FALSE ## Finishing value2, and I&#39;ve built: ## vec1 TRUE TRUE ## vec2 TRUE FALSE ## vec3 FALSE TRUE ## vec4 FALSE FALSE ## ## ## On value 3 with accumalated material: ## vec1 TRUE TRUE ## vec2 TRUE FALSE ## vec3 FALSE TRUE ## vec4 FALSE FALSE ## Finishing value3, and I&#39;ve built: ## vec1 TRUE TRUE TRUE ## vec2 TRUE TRUE FALSE ## vec3 TRUE FALSE TRUE ## vec4 TRUE FALSE FALSE ## vec5 FALSE TRUE TRUE ## vec6 FALSE TRUE FALSE ## vec7 FALSE FALSE TRUE ## vec8 FALSE FALSE FALSE ## ## vec1 TRUE TRUE TRUE ## vec2 TRUE TRUE FALSE ## vec3 TRUE FALSE TRUE ## vec4 TRUE FALSE FALSE ## vec5 FALSE TRUE TRUE ## vec6 FALSE TRUE FALSE ## vec7 FALSE FALSE TRUE ## vec8 FALSE FALSE FALSE Of course in practice we would not turn on the verbose option: makeTable(4) ## ## vec1 TRUE TRUE TRUE TRUE ## vec2 TRUE TRUE TRUE FALSE ## vec3 TRUE TRUE FALSE TRUE ## vec4 TRUE TRUE FALSE FALSE ## vec5 TRUE FALSE TRUE TRUE ## vec6 TRUE FALSE TRUE FALSE ## vec7 TRUE FALSE FALSE TRUE ## vec8 TRUE FALSE FALSE FALSE ## vec9 FALSE TRUE TRUE TRUE ## vec10 FALSE TRUE TRUE FALSE ## vec11 FALSE TRUE FALSE TRUE ## vec12 FALSE TRUE FALSE FALSE ## vec13 FALSE FALSE TRUE TRUE ## vec14 FALSE FALSE TRUE FALSE ## vec15 FALSE FALSE FALSE TRUE ## vec16 FALSE FALSE FALSE FALSE 14.4.3 Practice Exercises The operator * (multiplication) is really a function: `*`(3,5) ## [1] 15 But it can only multiply two numbers at once. The R-function prod() cna handle as many numbers as you like: prod(3,5,2,7) ## [1] 210 Use reduce() and * to write your own function product() that takes a numerical vector vec and returns the product of the elements of the vector. It should work liek this: product(vec = c(3,4,5)) ## [1] 60 (Hint: in the call to reduce() you will have to the refer to the *-function as `*`.) Modify the function product() so that it in a single call to reduce() it multiplies the number 2 by the product of the elements of vec. (Hint: set .init to an appropriate value.) The data frame iris gives information on 150 irises. Use keep() to create a new data frame that includes only the numerical variables having a mean greater than 3.5. 14.4.4 Solutions to the Practice Exercises Try this: product &lt;- function(vec) { reduce(vec, .f = `*`) } Try this: product &lt;- function(vec) { reduce(vec, .f = `*`, .init = 2) } Try this: bigIris &lt;- iris %&gt;% keep(is.numeric) %&gt;% keep(~mean(.) &gt; 3.5) str(bigIris) ## &#39;data.frame&#39;: 150 obs. of 2 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... The following does not work. Why? bigIris &lt;- iris %&gt;% keep(function(x) { is.numeric(x) &amp; mean(x) &gt; 3.5 }) } "],
["functionals-vs-loops.html", "14.5 Functionals vs. Loops", " 14.5 Functionals vs. Loops The higher-order functions we have studied in this chapter are often called functionals. As we pointed out earlier, they deliver results that could have been produced by a writing a loop of some sort. Once you get used to functionals, you will find that they are often more “expressive” than loops—easier for others to read and to understand, and less prone to bugs. Also, many of them are optimized by the developers of R to run a bit faster than an ordinary loop written in R. For example, consider the following list. It consists of ten thousand vectors, each of which contains 100 randomly-generated numbers. lst &lt;- map(rep(100, 10000), runif) If we want the mean of each vector, we could write a loop: means &lt;- numeric(10000) for ( i in 1:10000 ) { means[i] &lt;- mean(lst[[i]]) } Or we could use map_dbl(): means &lt;- map_dbl(lst, mean) Comparing the two using system.time() , on my machine I got: system.time(means &lt;- map_dbl(lst, mean)) ## user system elapsed ## 1.557 0.073 1.630 For the loop, I get: system.time({ means &lt;- numeric(10000) for ( i in 1:10000 ) { means[i] &lt;- mean(lst[[i]]) } }) ## user system elapsed ## 1.653 0.075 1.730 The map-function is a bit faster, but the difference is small. Remember also that vectorization is much faster than looping, and is also usually quite expressive, so don’t struggle to take a functional approach when vectorization is possible. (This advice applies to a several examples from this Chapter, in which the desired computations had already been accomplished in earlier chapters by some form of vectorization.) "],
["conclusion.html", "14.6 Conclusion", " 14.6 Conclusion In this Chapter we have concentrated on only a single aspect of the Functional Programming paradigm: exploiting the fact that functions are first-class citizens in R, we studied a number of higher-order functions that can substitute for loops. There is certainly a great deal more to Functional Programming than the mere avoidance of loops, but we’ll end our study at this point. Familiarity with higher-order functions will stand you in good stead when you begin, in subsequent courses on web programming, to learn the JavaScript language. JavaScript makes constant use of higher-order functions! "],
["glossary-11.html", "Glossary", " Glossary Programming Paradigm A programming paradigm is a way to describe some of the features of programming languages. Often a paradigm includes principles concerning the use of these features, or embodies a view that these features have special importance and utility in good programming practice. Procedural Programming A programming paradigm that solves problems with programs that can be broken up into collections of variables, data structures and procedures. This paradigm tends to draw a sharp distinction between variables and data structures on the one hand and procedures on the other. Functional Programming A programming paradigm that stresses the central role of functions. Some of its basic principles are: Computation consists in the evaluation of functions. Functions are first-class citizens in the language. Functions should only return values; they should not produce side-effects. As much as possible, procedures should be written in terms of function calls. Pure Function A function that does not produce side-effects. Side Effect A change in the state of the program (i.e., a change in the Global Environment) or any interaction external to the program (i.e., printing to the console). Higher-Order Function A function that takes another function as an argument. Anonymous Function A function that does not have a name. Refactoring The act of rewriting computer code so that it performs the same task as before, but in a different way. (This is usually done to make the code more human-readable or to make it perform the task more quickly.) "],
["exercises-10.html", "Exercises", " Exercises Explain in words what the following line of code produces when given a numerical vector y: map(y, function(x) x^3 + 1) In the course of your explanation, say whether the result is a vector or a list. Which do you think works faster for a given numerical vector y? This code: map(y, function(x) sqrt(x)) Or this code? sqrt(y) Justify your answer with a convincing example, using system.time(). What moral do you draw from this? To refactor computer code is to rewrite the code so that it does the same thing, but in a different way. We might refactor code in order to make it more readable by humans, or to make it perform its task more quickly. Refactor the following code so that it uses keep() instead of a loop: df &lt;- bcscr::m111survey keepVariable &lt;- logical(length(names(df))) for ( col in seq_along(keepVariable) ) { var &lt;- df[, col] isNumeric &lt;- is.numeric(var) allThere &lt;- !any(is.na(var)) keepVariable[col] &lt;- isNumeric &amp;&amp; allThere } newFrame &lt;- df[, keepVariable] head(newFrame) The following function produces a list of vectors of uniform random numbers, where the lower and upper bounds of the numbers are given by the arguments to the parameters lower and upper respectively, and the number of vectors in the list and the number of random numbers in each vector are given by a vector supplied to the parameter vecs. randomSims &lt;- function(vecs, lower = 0, upper= 1, seed = NULL) { # set seed if none is provided by the user if ( !is.null(seed) ) { set.seed(seed) } lst &lt;- vector(mode = &quot;list&quot;, length = length(vecs)) for ( i in seq_along(vecs) ) { lst[[i]] &lt;- runif(vecs[i], min = lower, max = upper) } lst } Refactor the code for randomSims() so that it uses map() instead of a loop. The following enhanced version of randomSims() is even more flexible, as it allows both the upper and lower limits for the randomly-generated numbers to vary with each vector of numbers that is produced. randomSims2 &lt;- function(vecs, lower, upper, seed = NULL) { # validate input if (!(length(vecs) == length(upper) &amp;&amp; length(upper) == length(lower)) ) { return(cat(&quot;All vectors entered must have the same length.&quot;)) } if ( any(upper &lt; lower) ) { return(cat(paste0(&quot;Every upper bound must be at least as &quot;, &quot;big as the corresponding lower bound.&quot;))) } # set seed if none is provided by the user if ( !is.null(seed) ) { set.seed(seed) } lst &lt;- vector(mode = &quot;list&quot;, length = length(vecs)) for ( i in seq_along(vecs) ) { lst[[i]] &lt;- runif(vecs[i], min = lower[i], max = upper[i]) } lst } Use pmap() to refactor the code for randomSims2() so as to avoid using the loop. Supposing that y is a numerical vector, explain in words what the following code produces: y %&gt;% keep(function(x) x &gt;= 4) Write a line of code using the sub-setting operator [ that produces the same result as the code in the previous problem. Use keep() to write a function called oddMembers() that, given any numerical vector, returns a vector containing the odd numbers of the given vector. Your function should take a single argument called vec, the given vector. A typical example of use would be as follows: oddMembers(vec = 1:10) ## [1] 1 3 5 7 9 You are given the following list of character vectors: lst &lt;- list(c(&quot;Akash&quot;, &quot;Bipan&quot;, &quot;Chandra&quot;, &quot;Devadatta&quot;, &quot;Raj&quot;), c(&quot;Raj&quot;, &quot;Vikram&quot;, &quot;Sita&quot;, &quot;Akash&quot;, &quot;Chandra&quot;), c(&quot;Akash&quot;, &quot;Raj&quot;, &quot;Chandra&quot;, &quot;Bipan&quot;, &quot;Lila&quot;), c(&quot;Akash&quot;, &quot;Vikram&quot;, &quot;Devadatta&quot;, &quot;Raj&quot;, &quot;Lila&quot;)) Use reduce() and the union() function to obtain a character vector that is the union of all the vectors in lst. Remember the function subStrings() from the exercises of the Chapter on Strings? Refactor it so that it does EXACTLY the same thing but makes no use of loops. (*) Run the following code to see what it does. Then analyse the code and explain in detail how it works. Along the way you will have to study some unfamiliar R-functions. dataDir &lt;- &quot;datafiles&quot; if ( !dir.exists(dataDir) ) dir.create(dataDir) urls &lt;- c( &quot;https://data.cityofnewyork.us/api/views/25th-nujf/rows.csv&quot;, &quot;https://data.seattle.gov/api/views/cf52-s8er/rows.csv&quot;, &quot;https://data.ct.gov/api/views/kbxi-4ia7/rows.csv&quot; ) fileNameFrags &lt;- urls %&gt;% str_match(&quot;data\\\\.(\\\\w+)\\\\.&quot;) %&gt;% .[, 2] processFiles &lt;- function(url, frag) { csvDest &lt;- file.path(dataDir, paste0(frag, &quot;.csv&quot;)) download.file(url, csvDest) assign(frag, read_csv(csvDest)) do.call( save, args = list( frag, file = file.path( dataDir, paste0(frag, &quot;.rda&quot;)))) } list(urls, fileNameFrags) %&gt;% pwalk(processFiles) "],
["oo.html", "Chapter 15 Object-Oriented Programming in R", " Chapter 15 Object-Oriented Programming in R repeat { coffeeMug$drinkFrom() workTask$execute() if ( coffeeMug$empty() ) { if ( coffeePot$empty() ) { coffeePot$make() } coffeeMug$fill() } if ( workTask$done() ) { break } } Our journey with R began in the Procedural Programming paradigm. In the last Chapter we learned about R’s extensive support for the more modern paradigm known as Functional Programming. In the present Chapter we will explore the ways in which R supports a third modern programming paradigm: Object-Oriented Programming. "],
["the-object-oriented-programming-paradigm.html", "15.1 The Object-Oriented Programming Paradigm", " 15.1 The Object-Oriented Programming Paradigm We started out with Procedural Programming, which draws a distinction between data and procedures. Data provides our information, and procedures solve problems by manipulating data into new forms. Functional Programming puts functions at the center of attention. As much as possible, procedures are wrapped up in function calls, and by their status as first-class citizens (data) functions become king. Everything that happens is a result of function calls on data–where the data can include other functions. You could say that Object-Oriented Programming reverses the point of view, attempting to put objects–conceived as complex forms of data–at the center of attention. There are two major types of Object-Oriented (OO) Programming: Message-Passing OO Generic-Function OO Message-Passing OO is the type of OO Programming that programmers usually associate with the term “object-oriented”, and since it is the type that you will meet most frequently in other languages that support OO-programming we will discuss it first. Generic-Function OO is actually the older type of OO Programming. Although it is very important for understanding some aspects of how R works, it is met with less frequently in other major programming languages, so we will defer discussion of it until Section 15.7. Accordingly, the following introductory remarks pertain only to message-passing OO. Objects in the world about us are indeed complex entities: they have particular features. Some of these features they have in virtue of the kind of object that they are, and others are features–attributes–that they have on their own, as individuals. And they can do various things. Again, some of the things they do are things that they do simply because of the kind of thing they are, and others things they do might be unique to them. Consider a typical object: my dog, for example. He has various attributes: his name is Beau, he has four legs, he weighs about 50 pounds, his hair is black. And he does various things—he has various methods, let’s say, for making his way through life. For example, when we are out of the house he lies in the sofa, when we are home he lies on the floor. He barks. He eats. He annoys cats. Some of his attributes and methods Beau has simply in virtue of being the kind of thing that he is. He is, after all, a dog—a member of the class Dog, let’s say—and so like all other dogs he will have four legs and he will be able to bark and to annoy cats. Of course all dogs are animals—members of the more general class Animal, let’s say—and all animals eat, so as an animal Beau inherits the method known as eating. Of course all animals are material beings—members of the even-more general class Being, let’s say—and all beings have a weight, and thus Beau has a weight, but the particular value of that weight—50 pounds—is determined by the way he has lived his life thus far. Other dogs, animals and material beings have a weight, but they won’t necessarily have the same weight as Beau. What emerges from this discussion is an (admittedly oversimplified) view of the world as a collection of complex objects. These objects are related to one another in systematic ways–related closely when they are, for instance, both Dogs, and more distantly, as when one is a Dog and another is a Cat. And these objects can act on themselves and on each other in various ways, through their methods. The idea of Object-Oriented Programming is that since we are so used to viewing the world as a collection of objects that are constituted of various attributes and methods and that are related to one another through membership in classes of varying levels of generality, then it might help us to be able to view a computer program similarly—as a collection of objects thus constituted and thus related to one another. Like many other modern programming languages, R provides considerable support for the Object-Oriented paradigm. In fact it provides that support in two different formats: Reference Classes R6 Classes Reference Classes are a relatively recent introduction to R. R6 Classes are a simple and lightweight version of Reference Classes. They are not a part of the core of R—they are enabled by a contributed R-package—but they are quite useful as an introduction to object-oriented programming. Accordingly, we will work with them in this Chapter. "],
["reference-classes-with-package-r6.html", "15.2 Reference Classes with Package R6", " 15.2 Reference Classes with Package R6 The package R6 (Chang 2019) provides access to R6 classes. You will need to attach it: library(R6) We’ll get started by creating a miniature computerized world of objects that is based on characters from the Wizard of Oz. 15.2.1 Defining a Class Construction of the object-world begins with the definition of classes. A class is simply a general prototype on the basis of which actual objects may be created. Let’s define the class Person. This is accomplished with the R6Class() function: Person &lt;- R6Class( classname = &quot;Person&quot;, public = list( name = NULL, age = NULL, desire = NULL, initialize = function(name = NA, age = NA, desire = NA) { self$name &lt;- name self$age &lt;- age self$desire &lt;- desire self$greet() }, set_age = function(val) { self$age &lt;- val cat(&quot;Age of &quot;, self$name, &quot; is: &quot;, val, &quot;.\\n&quot;, sep = &quot;&quot;) }, set_desire = function(val) { self$desire &lt;- val cat(&quot;Desire of &quot;, self$name, &quot; is: &quot;, val, &quot;.\\n&quot;, sep = &quot;&quot;) }, greet = function() { cat(paste0(&quot;Hello, my name is &quot;, self$name, &quot;.\\n&quot;)) } ) ) Let’s analyze the above code. The function R6Class() has a quite a few parameters, but the two with which we will concern ourselves the most are: classname: the name we propose to give to the class; public: a list of members of the class that are “public” in the sense that they can be accessed and used outside of the class.36 Members are of two types: attributes: the objects name, age and desire. Currently these have value NULL, but they can be given other values later on. What makes then attributes, though, is that they will not be given a function as a value. methods: these are members of the class that are functions. You can think of a “method” as a particular way of performing a common task that could be performed in many different ways. The four methods you see in Person are: initialize: This is a function that will be run whenever a new object of class Person is created. As we can see from its arguments, it will be possible to give values to the attributes name. age and desire when this function is called. set_age and set_desire are functions that allow a user to set or to change the value of age and desire for an object of class Person. greet: a function that will permit an object of class Person to issue a greeting. Note the use of the term self in the code for the methods of the class. When a method is called on an object, the term self will refer to the object on which the method is being called. Hence, for example, in the code for greet the term self$name will evaluate to the name of the person who issues the greeting. 15.2.2 Instantiation: Initializing Objects On its own there is not much that a class can do. For anything to happen we need to create a particular individual: an object of class Person. Creation of an object having a particular class is called instantiation. Every class comes with a method—not mentioned in the definition of the class—called new(). This method, when called on the Class, instantiates an object of the class by running the initialize() function. Let’s create a person named Dorothy and store this new object in the variable dorothy: dorothy &lt;- Person$new( name = &quot;Dorothy&quot;, age = 12, desire = &quot;Kansas&quot; ) ## Hello, my name is Dorothy. Note how the dollar-sign is used to indicate the calling of the new() method on the class Person. Note also that the arguments of new() are the arguments of initialize(): that’s because the new() method actually runs initialize() as part of its object-creation process. We can get a look at dorothy by printing her to the console: dorothy ## &lt;Person&gt; ## Public: ## age: 12 ## clone: function (deep = FALSE) ## desire: Kansas ## greet: function () ## initialize: function (name = NA, age = NA, desire = NA) ## name: Dorothy ## set_age: function (val) ## set_desire: function (val) We get the basic information on Dorothy, including also an indication that she can be cloned (copied). We’ll discuss cloning later. We can instantiate as many people as we like. The code below for example, establishes scarecrow as a new instance of Person: scarecrow &lt;- Person$new( name = &quot;Scarecrow&quot;, age = 0.038, desire = &quot;Brains&quot; ) ## Hello, my name is Scarecrow. In The Wizard of Oz, Scarecrow is only two weeks old when Dorothy meets him, so his age is set at \\(2/52 \\approx 0.038\\) years. 15.2.3 Getting and Setting Attributes If we would like to change Dorothy’s age, we can do so by calling the set_age() method on her: dorothy$set_age(13) ## Age of Dorothy is: 13. dorothy$age ## [1] 13 We can also set Dorothy’s age directly, by regular assignment: dorothy$age &lt;- 14 dorothy$age ## [1] 14 The effect is the same as when we use set_age() except that we don’t get a report to the console. 15.2.4 Calling Methods We have seen that in order to call a method on an object, you follow the format: object$method() Thus, we can ask dorothy to issue a greeting: dorothy$greet() ## Hello, my name is Dorothy. In the syntax for calling methods, we see one aspect of “message-passing”: dorothy$greet() essentially passes a message to dorothy: “Please call your greet() method!” 15.2.5 Holding a Reference, not a Value R6 objects operate by what are known in computer programming as reference semantics. This means that when the assignment operator is used to assign an R6 object to a variable, the new variable holds a reference to that object, not a copy of the new object. This is in contrast value semantics, which is the way assignment usually works in R. In value semantics, R a distinct copy of the value of the assigned object is created, and the new variable refers to that copy. Below is an example of the familiar value semantics in action: a &lt;- 10 b &lt;- a b &lt;- 20 a ## [1] 10 b has been changed to 20, but that change did not affect a, which keeps its initial value of 10. We can use the function address() from the package pryr (Wickham 2018) to track what is happening behind the scenes. address() will tell us the current location in memory of the value corresponding to a name. Let’s repeat the above process, but use address() to see where the values are stored: a &lt;- 10 pryr::address(a) ## [1] &quot;0x7febd88d02e8&quot; The value 10 is stored in the memory address given above. Next, let’s create b by assignment from a: b &lt;- a pryr::address(b) ## [1] &quot;0x7febd88d02e8&quot; For the moment b points to the same place in memory as a does, so it will yield 10: b ## [1] 10 We can use b for other operations; for example, we can add 30 to it: b + 30 ## [1] 40 But for now b still points to the same place in memory that a does: pryr::address(b) ## [1] &quot;0x7febd88d02e8&quot; But now let’s assign a new value to b: b &lt;- 20 pryr::address(b) ## [1] &quot;0x7febd8b4fda8&quot; Aha! b now points to a new location in the computer’s memory! That’s because R saw that the assignment operator was going to change the value of b. Since b has value semantics, R knows to set aside a new spot in memory to contain the value 20, and to associate the name b with that spot. That way, the new b won’t interfere with a, which points to the same old spot in memory and thus remains 10: pryr::address(a) ## [1] &quot;0x7febd88d02e8&quot; a ## [1] 10 On the other hand, R6 objects have reference semantics. We can see this in action with the following example. First, let’s check on dorothy’s age: dorothy$age ## [1] 14 Let’s now create dorothy2 by assignment from dorothy: dorothy2 &lt;- dorothy Let’s check the memory locations: c(pryr::address(dorothy), pryr::address(dorothy2)) ## [1] &quot;0x7febe75232c8&quot; &quot;0x7febe75232c8&quot; As with a and b, the two names initially point to the same place in memory. Now let’s change the age of dorothy2 to 30: dorothy2$age &lt;- 30 Let’s check the age of dorothy: dorothy$age ## [1] 30 Whoa! Changing the age of dorothy2 changed the age of dorothy! That’s because of the reference semantics: dorothy2 continues to be associated with the same spot in memory as dorothy, even after we begin to make changes to it: c(pryr::address(dorothy), pryr::address(dorothy2)) ## [1] &quot;0x7febe75232c8&quot; &quot;0x7febe75232c8&quot; 15.2.6 Cloning an Object For the sorts of complex objects created by R6 classes, reference semantics can be a useful feature. But what if we want a new and truly distinct copy of an R6 object? For this we need the clone() method that was alluded to earlier: dorothy2 &lt;- dorothy$clone() dorothy2 ## &lt;Person&gt; ## Public: ## age: 30 ## clone: function (deep = FALSE) ## desire: Kansas ## greet: function () ## initialize: function (name = NA, age = NA, desire = NA) ## name: Dorothy ## set_age: function (val) ## set_desire: function (val) dorothy2 looks just like dorothy. However, the name dorothy2 does not point to the same place in memory: c(pryr::address(dorothy), pryr::address(dorothy2)) ## [1] &quot;0x7febe75232c8&quot; &quot;0x7febd8e477f8&quot; Accordingly, changes to dorothy2 will no longer result in changes to dorothy: dorothy2$age &lt;- 100 dorothy$age ## [1] 30 You should know that if one or more of the members of an object is itself an object with reference semantics (such as an instance of an R6 class), then a copy produced by clone() will hold a reference to that same member-object, not a separate copy of the member-object. In such a case if you still want a totally separate copy, you will have to consult the R6 manual on the topic of “deep cloning.” References "],
["inheritance.html", "15.3 Inheritance", " 15.3 Inheritance Earlier we mentioned that in the real world an object may possess a property in virtue of being the particular kind of thing that it is, or it may possess that property in virtue of being a member of some more general class of things. Thus a dog can eat, not because it is a dog per se, but because it is an animal. You could say that dogs “inherit” the capacity to eat from the class Animal. Most object-oriented frameworks allow for some type of inheritance between classes, and R6 is no exception. In the Wizard of Oz lions appear to be a special type of person: after all, they can speak, and they have desires. Accordingly, we should create a new class Lion that inherits from the class Person: Lion &lt;- R6Class(&quot;Lion&quot;, inherit = Person, public = list( weight = NULL, set_weight = function(val) { self$weight &lt;- val cat(self$name, &quot; has weight: &quot;, val, &quot;.\\n&quot;, sep = &quot;&quot;) }, greet = function() { cat(&quot;Grr! My name is &quot;, self$name, &quot;!&quot;, sep = &quot;&quot;) } ) ) The key to inheritance is the new argument in the code above: inherit = Person The impact of this additional argument is that any instance of the class Lion will possess by default all of the attributes and methods of class Person, in addition to the new attributes and methods (weight, set_weight, and greet) specified explicitly in the definition of class Lion. Of these three explicitly-defined members: weight and set_weightwere not already in Person, so they are simply added on as members of Lion;37 greet was already a member of Person, but the new specification of greet in the definition of Lion overrides the old one. Any instance of class Lion will greet us according to the code for greet() given in the definition of Lion. (Objects that are instances of the class Person, however, will go on greeting us just as they always have done.) Let’s verify all of this by making an instance of class Lion: cowardlyLion &lt;- Lion$new( name = &quot;Cowardly Lion&quot;, age = 18, desire = &quot;courage&quot; ) ## Grr! My name is Cowardly Lion! Since the definition of class Lion did not specify a new method of initialization—we could have asked for this, but chose not to—the instantiation of a lion won’t set its weight. We will have to do that separately: cowardlyLion$set_weight(350) ## Cowardly Lion has weight: 350. Inheritance is an very effective way to re-use code and to keep code for a particular function in one place. Once we have written methods for some class X, those methods will be available to any objects that are instances of classes that inherit from class X. Hence there is no need to repeat the code in the definition of the inheriting classes. Later on if we need to modify one of of the class X methods, we need only make the change in class X: we don’t have to worry about changing it in all of the classes that inherit from X. Let’s ask cowardlyLion to greet us: cowardlyLion$greet() ## Grr! My name is Cowardly Lion! As expected, the greeting includes a growl, since the greet() method for class Lion overrides the growl-less greet() method that it would have otherwise inherited from class Person. We also see a fundamental aspect of message-passing OO at work: The method used for determining how a particular task is performed is determined by the class of the object that is asked to perform the task. Here we have the task of greeting, which is common to objects of class Person and to objects of class Lion. That task may be performed with or without a growl. Precisely how it is performed—the method that is selected for carrying out the task—depends upon the class of the object that performs the greeting: an object of class Person will greet you without a growl, whereas an object of class Lion will greet you with a growl. The common task of greeting may be performed in different ways, depending upon the class of the object involved in the task. This is an example of what programmers call polymorphism. The term “polymorphism” comes from a Greek word that means “many forms”, and it refers to a task being performed differently depending on the class of the object involved. Polymorphism makes programming a bit easier: you only have to remember the name of the one common task. Invoke it on an object and you can rest assured that the task will be performed in the way that is right and proper to that object. In the real world any person—not just any lion—has a weight. By making weight a feature specific to class Lion we are simply indicating that in our program weight is of particular importance to lions, but not to people in general.↩ "],
["adding-members-to-a-class.html", "15.4 Adding Members to a Class", " 15.4 Adding Members to a Class Sometimes we need to add or to modify a member of a class, after we have defined that class. Every class comes with a set() method that allows us to do this. For example, suppose that we would like our people to have a favorite color: Person$set(&quot;public&quot;, &quot;color&quot;, NA, overwrite = TRUE) We now see that color is now one of the public members of class Person: Person ## &lt;Person&gt; object generator ## Public: ## name: NULL ## age: NULL ## desire: NULL ## color: NA ## initialize: function (name = NA, age = NA, desire = NA) ## set_age: function (val) ## set_desire: function (val) ## greet: function () ## clone: function (deep = FALSE) ## Parent env: &lt;environment: R_GlobalEnv&gt; ## Locked objects: TRUE ## Locked class: FALSE ## Portable: TRUE In the above call to set, the argument overwrite = TRUE was not strictly necessary, since color did not previously exist as a member of Person. If you are developing a program, though, and you find yourself repeatedly running a piece of code that sets a new member for a class, it’s useful to have overwriting turned on. While we are at it. let’s write a special set_color() method: Person$set(&quot;public&quot;, &quot;set_color&quot;, function(val) { self$color &lt;- val cat(self$name, &quot; has favorite color: &quot;, val, &quot;.\\n&quot;, sep = &quot;&quot;) }, overwrite = TRUE) You might think that we can now set a favorite color for dorothy: dorothy$set_color(&quot;blue&quot;) Error: attempt to apply non-function Why did this not work? It turns out that when you add a new member to a class it is only available to instances of the class that are created after the new member is added to that class. If we create a new instance of Person, the Good Witch Glinda, let’s say, then we should be able to give her a favorite color: glinda &lt;- Person$new(&quot;Glinda&quot;, &quot;500&quot;, &quot;the good of all&quot;) ## Hello, my name is Glinda. glinda$set_color(&quot;blue&quot;) ## Glinda has favorite color: blue. "],
["method-chaining.html", "15.5 Method Chaining", " 15.5 Method Chaining In this Section we will explore a concise and convenient device for calling multiple methods on an object. The device is known as method chaining. In order to illustrate method chaining, we’ll extend the class Lion a bit, with some new attributes and new methods. First of all, we’d like to add a data frame consisting of possible animals on which a lion might prey. The data frame will contain the name of each type of animal, and an associated weight. animal &lt;- c( &quot;zebra&quot;, &quot;giraffe&quot;, &quot;pig&quot;, &quot;cape buffalo&quot;, &quot;antelope&quot;, &quot;wildebeast&quot; ) mass &lt;- c(50, 100, 25, 60, 45, 55) prey &lt;- data.frame(animal, mass, stringsAsFactors = FALSE) Let’s now add prey as a new attribute to class Lion. We will also add an attribute eaten: a character vector—initially empty—that will contain a record of all the animals that the lion has eaten. Lion$set(&quot;public&quot;, &quot;prey&quot;, prey, overwrite = TRUE) Lion$set(&quot;public&quot;, &quot;eaten&quot;, character(), overwrite = TRUE) Let us now endow our lions with the capacity to eat a beast of prey, by adding the method eat(): Lion$set(&quot;public&quot;, &quot;eat&quot;, function() { n &lt;- nrow(self$prey) item &lt;- self$prey[sample(1:n, size = 1), ] initLetter &lt;- substr(item$animal, 1, 1) article &lt;- ifelse(initLetter %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;), &quot;An &quot;, &quot;A &quot;) cat(article, item$animal, &quot; was eaten just now ...\\n\\n&quot;, sep = &quot;&quot;) self$eaten &lt;- c(self$eaten, item$animal) self$weight &lt;- self$weight + item$mass return(invisible(self)) }, overwrite = TRUE) When it eats an animal—randomly selected from the prey data frame—the lion gains the amount of weight that is associated with its unfortunate victim, and the victim is added to the lion’s eaten attribute. Note that the eat() method returns self invisibly. When the method is called on a lion, that very lion itself is returned as a value, but since it is returned invisibly it won’t be printed to the console. The usefulness of returning self will soon become apparent. Lions enjoy talking about what they have eaten recently, and for some reason they monitor their weight obsessively. The new method report() accounts for these characteristics of lions: Lion$set(&quot;public&quot;, &quot;report&quot;, function() { n &lt;- length(self$eaten) if (n &gt;= 1) { cat(&quot;My name is &quot;, self$name, &quot;.\\n&quot;, sep = &quot;&quot;) cat(&quot;My most recent meal consisted of: &quot;, self$eaten[n], &quot;.\\n&quot;, sep = &quot;&quot;) } cat(&quot;I now weigh &quot;, self$weight, &quot; pounds.\\n&quot;, sep = &quot;&quot;) return(invisible(self)) }, overwrite = TRUE) Note that report() also returns the lion invisibly. Let us now instantiate a new lion named Simba: simba &lt;- Lion$new( name = &quot;Simba&quot;, age = 10, desire = &quot;Hakuna Matata&quot; ) ## Grr! My name is Simba! simba$set_weight(300) ## Simba has weight: 300. Having been created after the addition of the prey and eaten attributes and the eat() and report() methods, simba has access to all of them. in particular, he can eat a random beast of prey: simba$eat() ## A cape buffalo was eaten just now ... simba has eaten, and he has presumably gained some weight as a result. Let’s see verify this by asking for his report: simba$report() ## My name is Simba. ## My most recent meal consisted of: cape buffalo. ## I now weigh 360 pounds. Let’s now have simba eat twice more, and then report. Because eat() and report() both return simba, we can call eat() on `simba, and then immediately call eat() on the result, and finally call report() on the result of our second call. All of this can be accomplished in one line of calls, in which the three method-calls are “chained” together with dollar-signs: simba$eat()$eat()$report() ## A cape buffalo was eaten just now ... ## ## A wildebeast was eaten just now ... ## ## My name is Simba. ## My most recent meal consisted of: wildebeast. ## I now weigh 475 pounds. In object-oriented programming languages you will see method-chaining used quite frequently. "],
["application-whales-in-an-ocean.html", "15.6 Application: Whales in an Ocean", " 15.6 Application: Whales in an Ocean Let’s now write a more elaborate program in the object-oriented style. Our program will simulate the population growth for whales in a ocean. In our model: Whales are mostly solitary: they move randomly about the ocean, happily feeding upon plankton. When a male and female whale are sufficiently close together the female whale will check out the male to see if he is mature enough to mate. If she herself is fertile, then she will mate with him and a child will be produced. That child will be either male or female, with equal likelihood for either option. After mating, the female will be infertile for a period of time. Whales have a set maximum lifetime. In any given time period, it is possible for a whale to starve, causing it to die before reaches its lifespan. The probability of starvation is low when the whale population is small (presumably there is plenty of plankton available then) but the starvation-probability increases in direct proportion to the population. From the above conditions you can see that if the whale population is small then there is low probability of starvation, but on the other hand whales are liable to be spread thinly throughout the ocean. As a result males and females are relatively unlikely to run across each other, and hence births are less likely to occur. With a low enough population there is a strong possibility that the whales will die off before they can reproduce. (This is why biologists worry about some whale populations: if the whales are hunted to the point where the population is below a certain critical threshold, then they can go extinct on their own, even if hunting ceases.) On the other hand, if the whale population grows large then males and female meet frequently, and there are plenty of births. As the populations increases, however, food supplies dwindle, resulting in higher starvation rates. At some point birth and starvation balance each other out, resulting in a long-term equilibrium population-level. We will implement our simulation with various objects: an ocean whales of two types: male whales female whales We will begin by defining the class Whale: Whale &lt;- R6Class(&quot;Whale&quot;, public = list( position = NULL, age = NULL, lifespan = NULL, range = NULL, maturity = NULL, stepSize = NULL, initialize = function(position = NA, age = 3, lifespan = 40, range = 5, maturity = 10, stepSize = 5) { self$position &lt;- position self$age &lt;- age self$lifespan &lt;- lifespan self$range &lt;- range self$maturity &lt;- maturity self$stepSize &lt;- stepSize } ) ) For whales that are instances of the Whale class: position will contain the current x and y-coordinate of the whale in a two-dimensional ocean; age will give the current age of the whale. lifespan is the maximum age that the whale can attain before it dies. range is how close the whale has to be to another whale of the opposite sex in order to detect the presence of that whale. maturity is the age that the whale must attain in order to be eligible to mate. stepSize is the distance that the whale moves in the ocean in a single time-period. Whales need to be able to move about in the sea. A whale moves by picking a random direction—any angle between 0 and \\(2\\pi\\) radians—and then moving stepSize units in that direction. If the selected motion would take the whale outside the boundaries of the ocean, then R will repeat the motion until the whale lands properly within the boundaries. The motion of a whale is implemented in the code below for a move() method that is added to class Whale: Whale$set(&quot;public&quot;, &quot;move&quot;, function(dims, r = self$stepSize) { xMax &lt;- dims[1] yMax &lt;- dims[2] repeat { theta &lt;- runif(1, min = 0, max = 2 * pi) p &lt;- self$position + r * c(cos(theta), sin(theta)) within &lt;- (p[1] &gt; 0 &amp;&amp; p[1] &lt; xMax) &amp;&amp; (p[2] &gt; 0 &amp;&amp; p[2] &lt; yMax) if (within) { self$position &lt;- p break } } }, overwrite = TRUE ) Note the parameter dims for the move function. From the code we can tell that it’s a vector of length 2. In fact the parameter will contain the x and and y-dimensions (the width and breadth) of our ocean. It’s something that will have to be determined by the ocean itself. We haven’t written the class Ocean yet, so this part of the code will have to remain a bit mysterious, for now. We need male and female whales, so we create a class for each sex. Both classes inherit from Whale. The class Male adds only a sex attribute: Male &lt;- R6Class(&quot;Male&quot;, inherit = Whale, public = list( sex = &quot;male&quot; ) ) A female whale is a bit more complex: in addition to a sex attribute, she needs an attribute that specifies how long she will be infertile after giving birth, and another attribute that enables the program to keep track of the number of time-periods she must wait until she is fertile again: Female &lt;- R6Class(&quot;Female&quot;, inherit = Whale, public = list( sex = &quot;female&quot;, timeToFertility = 0, infertilityPeriod = 5 ) ) A female whale also needs a method to determine whether a mature whale is in the vicinity: Female$set(&quot;public&quot;, &quot;maleNear&quot;, function(males, dist) { foundOne &lt;- FALSE for (male in males) { near &lt;- dist(male$position, self$position) &lt; self$range mature &lt;- (male$age &gt;= male$maturity) if (near &amp;&amp; mature) { foundOne &lt;- TRUE break } } foundOne }, overwrite = TRUE ) Again, note the parameters males and dist. Values for these parameters will be provided by the ocean object. males will be a list of the male whales in the population at the current time, and dist will be a function for computing the distance between any two points in the ocean. A female whale also needs to be able to mate: Female$set(&quot;public&quot;, &quot;mate&quot;, function() { babySex &lt;- sample(c(&quot;female&quot;, &quot;male&quot;), size = 1) self$timeToFertility &lt;- self$infertilityPeriod return(babySex) }, overwrite = TRUE ) Now it is time to define the Ocean class. It’s a bit of a mouthful: Ocean &lt;- R6Class(&quot;Ocean&quot;, public = list( dimensions = NULL, males = NULL, females = NULL, malePop = NULL, femalePop = NULL, starveParameter = NULL, distance = function(a, b) { sqrt((a[1] - b[1])^2 + (a[2] - b[2])^2) }, initialize = function(dims = c(100, 100), males = 10, females = 10, starve = 5) { self$dimensions &lt;- dims xMax &lt;- dims[1] yMax &lt;- dims[2] maleWhales &lt;- replicate( males, Male$new( age = 10, position = c( runif(1, 0, xMax), runif(1, 0, yMax) ) ) ) femaleWhales &lt;- replicate( females, Female$new( age = 10, position = c( runif(1, 0, xMax), runif(1, 0, yMax) ) ) ) self$males &lt;- maleWhales self$females &lt;- femaleWhales self$malePop &lt;- males self$femalePop &lt;- females self$starveParameter &lt;- starve }, starvationProbability = function(popDensity) { self$starveParameter * popDensity } ) ) In an instantiation of the class Ocean: dimensions will be numerical vector of length 2 that specifies the width and breadth of the ocean. males and females will be lists that contain respectively the current sets of male whales and female whales. Note that this implies that an ocean will contain as members other items that are themselves R6 classes. This is an example of what is called composition in object-oriented programming. malePop and femalePop give respectively the current counts male and females whales. starveParameter helps determine the probability that each individual whale will starve within the next time-period. Note that the method starvationProbability() makes the probability of starvation equal product of starveParameter and the current density of the population of whales in the ocean. The bigger this attribute is, the more starvation will occur and the lower the long-term upper limit of the population will be. distance() is the method for finding the distance between any two positions in the ocean. It implements the standard distance-formula from high-school geometry. The initialization function permits the user to determine the dimensions of the ocean, the initial number of male and female whales, and the starvation parameter. In the instantiation process for an individual ocean the required number of male and female whales are instantiated and are placed randomly in the ocean. We need to add a method that allows an ocean to advance one unit of time. During that time: Each mature and fertile female whale must check for nearby mature males, mate with one if possible, and produce a baby. Any offspring produced must then be added to the ocean’s lists of male and female whales. The ocean must then subject each whale to the possibility of starvation within the time-period at hand. All whales that survive must then move. The age of each whale must be increased by one time-unit. For females, the time remaining until fertility must also be decreased by a unit. The advance() method is implemented and added to Ocean with the code below: Ocean$set(&quot;public&quot;, &quot;advance&quot;, function() { malePop &lt;- self$malePop femalePop &lt;- self$femalePop population &lt;- malePop + femalePop if (population == 0) { return(NULL) } males &lt;- self$males females &lt;- self$females babyMales &lt;- list() babyFemales &lt;- list() if (malePop &gt; 0 &amp;&amp; femalePop &gt; 0) { for (female in females) { if (female$age &gt;= female$maturity &amp;&amp; female$timeToFertility &lt;= 0 &amp;&amp; female$maleNear( males = males, dist = self$distance )) { outcome &lt;- female$mate() if (outcome == &quot;male&quot;) { baby &lt;- Male$new(age = 0, position = female$position) babyMales &lt;- c(babyMales, baby) } else { baby &lt;- Female$new(age = 0, position = female$position) babyFemales &lt;- c(babyFemales, baby) } } } } # augment the male and female lists if needed: lmb &lt;- length(babyMales) lfb &lt;- length(babyFemales) # throw in the babies: if (lmb &gt; 0) { males &lt;- c(males, babyMales) } if (lfb &gt; 0) { females &lt;- c(females, babyFemales) } # revise population for new births: population &lt;- length(males) + length(females) # starve some of them, maybe: popDen &lt;- population / prod(self$dimensions) starveProb &lt;- self$starvationProbability(popDensity = popDen) maleDead &lt;- logical(length(males)) femaleDead &lt;- logical(length(females)) # starve some males for (i in seq_along(maleDead)) { male &lt;- males[[i]] maleDead[i] &lt;- (runif(1) &lt;= starveProb) male$age &lt;- male$age + 1 if (male$age &gt;= male$lifespan) maleDead[i] &lt;- TRUE if (maleDead[i]) next # if whale is not dead, he should move: male$move(dims = self$dimensions) } # starve some females for (i in seq_along(femaleDead)) { female &lt;- females[[i]] femaleDead[i] &lt;- (runif(1) &lt;= starveProb) female$age &lt;- female$age + 1 if (female$age &gt;= female$lifespan) femaleDead[i] &lt;- TRUE if (femaleDead[i]) next if (female$sex == &quot;female&quot;) { female$timeToFertility &lt;- female$timeToFertility - 1 } # if female is not dead, she should move: female$move(dims = self$dimensions) } # revise male and female whale lists: malePop &lt;- sum(!maleDead) self$malePop &lt;- malePop femalePop &lt;- sum(!femaleDead) self$femalePop &lt;- femalePop if (malePop &gt; 0) { self$males &lt;- males[!maleDead] } else { self$males &lt;- list() } if (femalePop &gt; 0) { self$females &lt;- females[!femaleDead] } else { self$females &lt;- list() } }, overwrite = TRUE ) In simulations we might enjoy looking at a picture of the ocean at any given time moment. Hence we add a plot() method that enables an ocean to produce a graph of the whales within it. In this graph males will be colored red and females green. Mature whales will appear as larger than immature whales. For purposes of speed we use R’s base graphics system rather than ggplot2. Ocean$set(&quot;public&quot;, &quot;plot&quot;, function() { males &lt;- self$males females &lt;- self$females whales &lt;- c(males, females) if (length(whales) == 0) { plot(0, 0, type = &quot;n&quot;, main = &quot;All Gone!&quot;) box(lwd = 2) return(NULL) } df &lt;- purrr::map_dfr(whales, function(x) { list( x = x$position[1], y = x$position[2], sex = as.numeric(x$sex == &quot;male&quot;), mature = as.numeric(x$age &gt;= x$maturity) ) }) # males will be red, females green: df$color &lt;- ifelse(df$sex == 1, &quot;red&quot;, &quot;green&quot;) # mature whales have cex = 3, immature whales cex 0.7 df$size &lt;- ifelse(df$mature == 1, 1.3, 0.7) with( df, plot(x, y, xlim = c(0, self$dimensions[1]), ylim = c(0, self$dimensions[1]), pch = 19, xlab = &quot;&quot;, ylab = &quot;&quot;, axes = FALSE, col = color, cex = size, main = paste0(&quot;Population = &quot;, nrow(df)) ) ) box(lwd = 2) }, overwrite = TRUE ) Finally, we write a simulation function. The function allows the user to specify the number of time-units that the simulation will cover, along with initial numbers of male and female whales. The user will have an option to “animate” the simulation showing a plot of the ocean after each time-unit. If the animation option is chosen, then R will use the Sys.sleep() function to make the computer suspend computations for half a second so that the user can view the plot. The simulation will cease if all of the whales die prior to end of the allotted time. Finally, the function uses ggplot2 to produce a graph of the whale population as a function of time. library(ggplot2) oceanSim &lt;- function(steps = 100, males = 10, females = 10, starve = 5, animate = TRUE, seed = NULL) { if (!is.null(seed)) { set.seed(seed) } ocean &lt;- Ocean$new( dims = c(100, 100), males = males, females = females, starve = starve ) population &lt;- numeric(steps) for (i in 1:steps) { population[i] &lt;- ocean$malePop + ocean$femalePop if (animate) ocean$plot() if (population[i] == 0) break ocean$advance() if (animate) Sys.sleep(0.5) } pop &lt;- population[1:i] df &lt;- data.frame( time = 1:length(pop), pop ) ggplot(df, aes(x = time, y = pop)) + geom_line() + labs(x = &quot;Time&quot;, y = &quot;Whale Population&quot;) } We are now ready for a simulation. The results are graphed in Figure 15.1. oceanSim( steps = 200, males = 15, females = 15, animate = FALSE, seed = 3030 ) Figure 15.1: Simulated whale population. Sadly, they all die after about 130 days. You should try running the simulation yourself a few times, for differing initial numbers of whales. If you like you can watch the whales move about by setting animate to TRUE: oceanSim( steps = 200, males = 15, females = 15, animate = TRUE ) You might also wish to explore varying the starve parameter: recall that the higher it is, the lower the long-term stable whale population will be. In order to better detect long-term stable population sizes, you will want to work with more steps, and you should turn off the step-by-step-animation, thus: oceanSim( steps = 1000, males = 75, females = 75, starve = 2.5, animate = FALSE ) The R package bcscr ((White 2020)) includes a more flexible version of the Ocean class that allows the users to set custom initial populations, including characteristics that vary from whale to whale. The object-oriented approach to simulation is not necessarily the quickest approach: R6 objects do require a bit more time for computation, as compared to a system that stores relevant information about the population in vectors or in a data frame. On the other hand the object-oriented approach makes it easy to encode information about each individual whale as it proceeds through time. In larger applications, an object-oriented approach to programming can result in code that is relatively easy to read and to modify, albeit at some cost in terms of speed. References "],
["generic-function-oo.html", "15.7 Generic-Function OO", " 15.7 Generic-Function OO We now turn to the second major type of object-oriented programming that is supported by R, namely: generic-function OO. 15.7.1 Motivating Examples We begin by revisiting the task of printing to the console. Recall that whenever we type the name of an object into the console and press Enter, R interprets the input as a call to the print() function. Consider, for example, printing some portion of m111survey from the bcscr package: df &lt;- bcscr::m111survey[1:5, c(&quot;height&quot;, &quot;weight_feel&quot;)] If we want to print df, then either of the following two statements accomplish the same thing: print(df) ## explicit directive to print results to Console ## height weight_feel ## 1 76 1_underweight ## 2 74 2_about_right ## 3 64 2_about_right ## 4 62 1_underweight ## 5 72 1_underweight df ## R implicity calls print() at top-level ## height weight_feel ## 1 76 1_underweight ## 2 74 2_about_right ## 3 64 2_about_right ## 4 62 1_underweight ## 5 72 1_underweight Both expressions, as we learned long ago, involve a call to the print() function. But let’s think a bit more deeply about what we see in the Console. It is tempting to think of the above printouts as simply what the object df is. But that’s not quite right. In truth, it merely reflects how R represents df to us in the console. R was programmed to represent df in spreadsheet-format—with variables along columns, individuals along rows, and with handy row-numbers supplied—because human users are accustomed to viewing data tables in that way. But now let us turn df into a list: lst &lt;- as.list(df) str(lst) ## List of 2 ## $ height : num [1:5] 76 74 64 62 72 ## $ weight_feel: Factor w/ 3 levels &quot;1_underweight&quot;,..: 1 2 2 1 1 And let’s print lst: lst # same as print(lst) ## $height ## [1] 76 74 64 62 72 ## ## $weight_feel ## [1] 1_underweight 2_about_right 2_about_right 1_underweight 1_underweight ## Levels: 1_underweight 2_about_right 3_overweight We get the familiar output for a list whose elements are named. Users don’t expect lists to be represented in the console in spreadsheet-style format, even if the elements of the list happen to be vectors that are all of the same length. They expect a more “neutral” representation, and R delivers one. Printing to the console is a common task. It appears, however, that the method by which that task is performed depends on the type of object that is input to the print() function: If your object is a data frame, print() behaves one way. If your object is a list, print does something else. Since the behavior of print() depends on the type of object involved in the operation of printing, you could say that it exhibits polymorphism. . In fact it is the class of the object given to print() that determines the method that prints() employs. The class of an R-object can be accessed with the class() function : class(df) ## [1] &quot;data.frame&quot; class(lst) ## [1] &quot;list&quot; How does the class of df determine the method used for printing? To see how this is done, look at the code for the print() function: print ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x108da3d40&gt; ## &lt;environment: namespace:base&gt; The body of the print() consists of just one expression: UseMethod(&quot;print&quot;). On the fact of it, this doesn’t seem to accomplish anything! In reality, though, a lot is taking place under the hood. Let’s examine what happens, step-by-step, when we call print(df). The data frame df is assigned to the parameter x in the print() function. We call UseMethod(&quot;print&quot;). From help(UseMethod) we learn that UseMethod() takes two parameters: generic: a character string that names the task we want to perform. In this case generic has been set to “print”. object: this is an object whose class will determine the method that will be “dispatched”, i.e., the method that will be used to print the object to the console. By default this is the first argument in the enclosing function print(), so object gets set to the data frame df. Control has now passed to the UseMethod() function, which searches for a suitable method for printing an object of class data.frame. It does this by pasting together “print” (the argument to generic) and data.frame (the class of the object df it was given) with a period in between, getting the string “print.data.frame”. A search is now conducted for a function having that name. The function print.data.frame() will be found. We can tell because it appears on the list of available “methods” for print(). The methods() function will give us the complete list of available methods, if we like methods(&quot;print&quot;) ## [1] print,ANY-method ## [2] print,diagonalMatrix-method ## [3] print,sparseMatrix-method ## [4] print.abbrev* ## [5] print.acf* ## ... ## [87] print.data.frame &lt;== Here it is! ## [88] print.data.table ## ... R now calls the print.data.frame(), passing in df. The data frame is printed to the console. When UseMethod() completes execution, it does not return control to the enclosing function print() from which it was called. The work of printing is done, so R arranges for control to be passed back to whomever called print() in the first place. It is interesting to note that the very act of “printing out” the print function, which we did earlier in order to see the code for the function, involved a search for a printing method: print # this is equivalent to print(print) ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x108da3d40&gt; ## &lt;environment: namespace:base&gt; In the call print(print), R looked at the class of print(), and found that it was of class function: class(print) ## [1] &quot;function&quot; R then searched for a method called print.function and found one. Note that this method gives the sort of output to the console that would be helpful to a user: the code for the function; the location of the function in memory: 0x108da3d40; the environment in which the function was defined (the package base). Things go a little bit differently in the call to print(lst). The class of lst is list, but when you search the results of methods(print) you won’t find a print.list() method; accordingly R uses a fall-back method called print.default(). This is why the console-output for lists looks so “neutral.” 15.7.2 Terminology The print() function is an example of a generic function. A generic function is simply a function that performs a common task by dispatching its input to a particular method-function that is selected on the basis of the class of the input to the generic function. Languages that use generic functions are said to support generic-function OO. In message-oriented OO, objects own their own methods, and the way a task is performed depends on the class of the object that is invoked to perform the task. Generic-function OO, which is most commonly found in languages that support functional programming, puts more stress on functions: the generic function “owns” the methods in the sense that it acts as the central dispatcher, assigning a method function to perform a given task. In a bit of a reversal to message-passing OO, the method selected in generic-function OO depends on the class of the input-object to the generic, not on the class of the generic that was called to perform the task. We should also mention that R actually has two ways to implement generic-function OO: S3 classes; S4 classes. S3 classes were the first to be implemented, and to this day they are more commonly-used than S4 classes are. Therefore they are the implementation we will study. (S4 classes tend to be used by programmers in applications where there significant concern that the rules for formation of S3 classes aren’t strict enough.) 15.7.3 Common Generic Functions There are three very commonly-used generic functions in R: print(), which we have examined already; summary(); plot(). Each of these generics is associated with a large number of method-functions. This is a great advantage to the casual user of R: one has to know only a few R-commands in order to acquire useful information about a wide variety of R-objects. It is always a good idea to “try out” generic functions on objects you are using. You never know if the authors of R, or of a contributed package you have attached, may have written methods that are precisely tailored to that object. Here are some example of the versatile, polymorphic behavior of the generic function summary(): heights &lt;- df$height # vector of class &quot;numeric&quot; summary(heights) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 62.0 64.0 72.0 69.6 74.0 76.0 feelings &lt;- df$weight_feel # has class &quot;factor&quot; summary(feelings) ## 1_underweight 2_about_right 3_overweight ## 3 2 0 summary(df) # summarizing object of class &quot;data.frame&quot; ## height weight_feel ## Min. :62.0 1_underweight:3 ## 1st Qu.:64.0 2_about_right:2 ## Median :72.0 3_overweight :0 ## Mean :69.6 ## 3rd Qu.:74.0 ## Max. :76.0 summary(lst) ## Length Class Mode ## height 5 -none- numeric ## weight_feel 5 factor numeric It is interesting also to see how R’s plot() (from package base) reacts to various types of input. See the Figure 15.2 x &lt;- seq(-3, 3, by = 0.01) plot(x^2) Figure 15.2: Our vector graphed as a parabola! 15.7.4 Writing Your Own Methods As you advance in your programming skills, you will transition from writing programs to help you accomplish your own tasks to writing programs that help others—who are not as proficient in programming as you are—get some of their work done. Since casual users of R often become accustomed to generic functions as providers of useful information about many types of R-objects, you might find yourself writing methods for one or more of the common generic functions. In this Section will we will practice the art of method-writing: we will write some method-functions to report on the results of a simulation. Recall the problem from Section 6.6 about estimating the expected number of uniform random numbers one must create until their sum exceeds a specified target-number. Let’s rewrite the simulation function so that it returns an object of a special class. We will then write print and plot methods that permit a user to obtain information about the results of any simulation that was performed. First of all, let’s rewrite numberNeededSim(): numberNeededSim &lt;- function(target = 1, reps = 1000, seed = NULL) { # set the seed if none is provided if (!is.null(seed)) { set.seed(seed) } numberNeeded &lt;- function(target) { mySum &lt;- 0 count &lt;- 0 while (mySum &lt; target) { number &lt;- runif(1) mySum &lt;- mySum + number count &lt;- count + 1 } count } needed &lt;- numeric(reps) for (i in 1:reps) { needed[i] &lt;- numberNeeded(target) } results &lt;- list(target = target, sims = needed) class(results) &lt;- &quot;numNeededSims&quot; results } In the above code you will note that there is no longer a parameter table to permit printing of a table to the console. Also, nothing at all is cat-ed to the console. Instead we return only a list with two named elements: target: the target you want your randomly-generated numbers to sum up to; sims: the number of numbers required to sum to the target, in each repetition of the simulation. The class of the returned list is set as “numNeededSims”. Next, we write a print-method function. Its name must be print.numNeededSims. All of the table output and cat-ing to the console goes here: print.numNeededSims &lt;- function(x) { cat(&quot;The target was &quot;, x$target, &quot;.\\n&quot;, sep = &quot;&quot;) sims &lt;- x$sims reps &lt;- length(sims) cat(&quot;Here is a table of the results, based on &quot;, reps, &quot; simulations.\\n\\n&quot;, sep = &quot;&quot; ) tab &lt;- prop.table(table(sims)) # for sake of pretty output, # remove &quot;sims&quot; variable name from top of table printout colNames &lt;- dimnames(tab) names(colNames) &lt;- NULL dimnames(tab) &lt;- colNames print(tab) cat(&quot;\\n&quot;) cat(&quot;The expected number needed is about &quot;, mean(sims), &quot;.\\n&quot;, sep = &quot;&quot; ) } Finally, let’s write a plot method. Its name must be plot.numNeededSims. This method will produce a bar graph of the results of the simulations. We’ll use the ggplot2 plotting package, so we should stop if the user hasn’t installed and attached ggplot2. plot.numNeededSims &lt;- function(x) { if (!&quot;package:ggplot2&quot; %in% search()) { return(cat(&quot;Need to load package ggplot2 in order to plot.&quot;)) } sims &lt;- x$sims # for a good bar-plot, convert numerical vector sims # to a factor with appropriate levels levels &lt;- min(sims):max(sims) sims &lt;- factor(sims, levels = levels) df &lt;- data.frame(sims) plotTitle &lt;- paste0(&quot;Results of &quot;, length(sims), &quot; Simulations&quot;) # in the code below, scale_x_discrete(drop = f) ensures that # even if there are no values in sims for a particular level it # will still appear in the plot as a zero-height bar ggplot(df, aes(x = sims)) + geom_bar() + scale_x_discrete(drop = FALSE) + labs(x = &quot;Number Needed&quot;, title = plotTitle) } Let’s give it a try: numberNeededSim(reps = 10000, seed = 4040) ## The target was 1. ## Here is a table of the results, based on 10000 simulations. ## ## 2 3 4 5 6 7 ## 0.4974 0.3354 0.1253 0.0339 0.0068 0.0012 ## ## The expected number needed is about 2.7209. The print function was called implicitly, so we got useful output to the console. It’s also possible to save the results somewhere, for example: results &lt;- numberNeededSim(reps = 10000, seed = 4040) str(results) ## List of 2 ## $ target: num 1 ## $ sims : num [1:10000] 3 2 2 2 3 3 4 2 2 5 ... ## - attr(*, &quot;class&quot;)= chr &quot;numNeededSims&quot; Then it’s possible for the user to recall specific features of the results, for example: results$target # get just the target number ## [1] 1 If we wanted the printout we could just say: results ## The target was 1. ## Here is a table of the results, based on 10000 simulations. ## ## 2 3 4 5 6 7 ## 0.4974 0.3354 0.1253 0.0339 0.0068 0.0012 ## ## The expected number needed is about 2.7209. For a plot we can use the plot() generic. The resulting graph appears as Figure 15.3. plot(results) Figure 15.3: Results of the Number-Needed simulation. 15.7.5 Writing a Generic Function Generic functions are most useful when they correspond to tasks that are so commonly performed that many methods are written for them, so that users get in the habit of “trying out” the generic on their object. As a consequence, the vast majority of method-functions are written for currently-existing, very well-known generics like print(), summary() and plot(). It doesn’t make a lot of sense to write generics that will have only a few methods attached to them. Nevertheless, it’s highly instructive to see how generics do their work, so as an example we’ll write a new generic, along with a couple of method functions.38 First let’s create some objects with special classes. Here are two objects of class “cartesianPoint”. Our intention is that they correspond to points on the plane, represented with the standard \\(x\\) and \\(y\\) Cartesian coordinates. point1 &lt;- list(x = 3, y = 4) class(point1) &lt;- &quot;cartesianPoint&quot; point2 &lt;- list(x = 2, y = 5) class(point2) &lt;- &quot;cartesianPoint&quot; It is also possible to represent a point on the plan with polar coordinates. The elements of a polar coordinates representation are: \\(r\\): a non-negative real number that gives the distance from the origin to the point; \\(\\theta\\): the angle measure (in radians) between the positive \\(x\\)-axis and ray from the origin to the point. point3 &lt;- list(r = 2, theta = pi / 2) point4 &lt;- list(r = 1, theta = pi) class(point3) &lt;- &quot;polarPoint&quot; class(point4) &lt;- &quot;polarPoint&quot; In the definition above, point3 is the point that lies at \\(\\pi/2\\) radians (90 degrees) counter-clockwise from the positive \\(x\\)-axis. That means that it lies along the positive \\(y\\)-axis. It is 2 units from the origin, so in Cartesian coordinates it would be written as \\((0,2)\\). Similarly, point4 would be written in Cartesian coordinates as \\((-1,0)\\), since it lies one unit from the origin along the negative \\(x\\)-axis. Now let us suppose that we would like to find the \\(x\\)-coordinate of a point. For points of class cartesianPoint this is pretty simple: point1$x # gives x-coordinate ## [1] 3 If the point is given in polar coordinates, we must convert it to Cartesian coordinates. You may recall the conversion formulas from a previous trigonometry class. To get \\(x\\), use: \\[x = r\\cos \\theta.\\] To get \\(y\\), use: \\[y = r\\sin \\theta.\\] Thus, to find the \\(x\\)-coordinate for point3, work as follows: point3$r * cos(point3$theta) ## [1] 1.224647e-16 The result is 0 (to a tiny bit of round-off error). We now write a generic function xpos() for the \\(x\\)-coordinate: xpos &lt;- function(x) { UseMethod(&quot;xpos&quot;) } We need to write our method functions, one for each point class: xpos.cartesianPoint &lt;- function(point) { point$x } xpos.polarPoint &lt;- function(point) { point$r * cos(point$theta) } Now we can feed points of either class into the generic xpos() function: xpos(point2) ## [1] 2 xpos(point4) ## [1] -1 The generic we write is drawn from an example provided in the official R Languge Definition (R Core Team (2017)), written by the developers of R.↩ "],
["glossary-12.html", "Glossary", " Glossary Object-Oriented Programming A programming paradigm in which programs are built around objects, which are complex structures that contain data. Class A general prototype from which individual objects may be created. The definition of the class specifies the attributes and methods that shall be possessed by any object created from that class. In addition, the definition of the class includes a function called an initializer that governs the creation of individual objects from the class. Instantiation The creation of an individual object as an instance of a class. The object gets all of the attributes and methods of the class (except for the initializer function). Typically the intializer functions allows for determination of the values of some of the object’s attributes at the time of instantiation. Message-Passing OO A type of object-oriented programming in which a task is performed by passing a message to the object that will perform the task. The method by which the object performs the task is determined solely by the class of which the object is an instance. Attribute A data-field belonging to an object that is not a function. Method (also called “Method-Function”) A function that encapsulates a particular way of performing a task. In message-passing OO, it is a function data-field belonging to an object that as a data-field. Such a function usually has access to its inputs, to other data from its object, and to the objet itself. In generic-function OO, it is a function that is accessed through a generic function. Reference Semantics When an object has reference semantics, assignments involving that object create a pointer to the object, rather than creating a copy of the object itself. Composition The situation that arises when an object with reference semantics contains one or more other objects with reference semantics as data-fields. Inheritance The situation that arises when a class (known as the child class) is defined as being a particular type of some other class (known as the parent class). By default the child class has all of the attributes and methods of the parent class. The child class may be given additional attributes and methods. Overriding When a method defined in a child class has the same name as a method belonging to the parent class, then the child-class method is said to override the parent-class method. When the method is called on an instance of the child class the defining code in the child class, not the parent class, is used to execute the method. Generic Function A function that dispatches an input object to one of a number of method-functions, based on the class of the input. Generic-Function OO A type of object-oriented programming in which tasks are performed by generic functions. The method used to perform a particular task is determined by the class of the input object. Polymorphism A program exhibits polymorphism when a function behaves differently depending either on the type of object to which it belongs or the type of object to which it is applied. "],
["exercises-11.html", "Exercises", " Exercises Write a new class called Witch that inherits from class Person. It should have two additional properties: slippers: Color of slippers worn by an individual witch. The initial value should be NULL. region: the part of Oz over which an individual witch reigns (e.g., “North”, “South”, etc.). The initial value should be NULL. The class should include set-methods for both slippers and region. In addition there should be an initialize() method that overrides the method already provided with class Person. This new method should permit the user to set the value of slippers and region. Create two new witches: The Wicked Witch of the East. Her name and desire are up to you, but her slippers should be silver, and of course she should reign over the East. Glinda, the Good Witch of the North. Her desire and color of slippers are up to you. Install the package bcscr, if you have not done so already: devtools::install.packages(&quot;homerhanumat/bcscr&quot;) Study the documentation for the classes Ocean, Female and Male, and then write your own ocean simulation in which the initial whales have properties that you select. Run the simulation, initializing the ocean with ten whales of each sex and report on the results in an R Markdown document. (Note: Don’t run animations in an R Markdown document.) Recall the function meetupSim() from Section 6.4, with which we investigated the probability that Anna and Raj would meet at the Coffee Shop. Suppose that we are interested not only in the probability that they meet, but also in the distribution of the number of minutes by which the latecomer misses the one who came early on the occasions when they do not manage to connect. Revise meetupSim() so that it does not print any results to the console, but instead returns a list. The list should have two elements: a logical vector indicating, for each repetition of the simulation, whether or not Anna and Raj met; a numerical vector indicating, for each repetition in which they did not meet, the number of minutes by which the latecomer missed meeting the person who arrived earlier. Make the list have class “meetupSims”. A typical example of use should look like this: results &lt;- meetupSim(reps = 10000, seed = 3535) str(results) ## List of 2 ## $ connect: logi [1:10000] FALSE FALSE TRUE FALSE TRUE FALSE ... ## $ noMeet : num [1:6934] 30.275 29.959 22.394 0.491 4.898 ... ## - attr(*, &quot;class&quot;)= chr &quot;meetupSims&quot; Building on the previous exercise, write a method-function called print.meetupSims() that prints the results of a meet-up simulation to the console. The function should provide a table that gives the proportion of times that Anna and Raj met, and a numerical summary of the simulation results when they did not meet. (You could use the summary() function for this.) A typical example of use would look like this: results # has same effect as print(results) ## Here is a table of the results, based on 10000 simulations. ## ## Did not connect Connected ## 0.6934 0.3066 ## ## Summary of how many minutes they missed by: ## ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00131 6.60680 14.55711 16.55834 24.87720 49.30534 Continuing in the same vein, write a method-function called plot.meetupSims() that makes a density plot showing the distribution of the number of minutes by which the latecomer misses the meeting. It should work like this: plot(results) Write a generic function called ypos() that will return the \\(y\\)-coordinate of points of class cartesianPoint and polarPoint. Of course you will need to write the corresponding method functions, as well. Write a generic function called norm() that will return the distance of a point from the origin. The point could be of class cartesianPoint or polarPoint, so you will need to write the corresponding method functions, as well. (It will be helpful to recall that for a point with Cartesian coordinates \\((x,y)\\) the distance from the origin is \\(\\sqrt{x^2 + y^2}\\).) "],
["references.html", "References", " References "]
]
